---
title: "Debugging smart contracts"
---

import {Aside} from "/snippets/aside.jsx";

<Aside>
  All examples from this article are available on [Github](https://github.com/ton-org/docs-examples/tree/main/guidebook/debug).
</Aside>

Errors in smart contracts can produce unexpected [exit code](/tvm/exit-codes), often indicating a bug in the contract.
Use debugging methods to locate and fix the issue.

## Log to the console

Print common values, such as transactions and get-method results to debug the contract.

- `findTransaction()` function helps you find a transaction by its properties.
- `flattenTransaction()` function helps to inspect transactions in a developer-friendly format.

```ts TypeScript
import { toNano } from '@ton/core';
import { Blockchain } from '@ton/sandbox';
import '@ton/test-utils';
import { Test } from './output/sample_Test';
import { findTransaction, flattenTransaction } from '@ton/test-utils';

const setup = async () => {
    const blockchain = await Blockchain.create();
    const owner = await blockchain.treasury('deployer');
    const contract = blockchain.openContract(await Test.fromInit());
    const deployResult = await contract.send(owner.getSender(), { value: toNano(0.5), bounce: true }, null);

    return { blockchain, owner, contract, deployResult };
};

it('should deploy correctly', async () => {
    const { contract, deployResult } = await setup();

    const txToInspect = findTransaction(deployResult.transactions, {
        to: contract.address,
        deploy: true,
    });
    if (txToInspect === undefined) {
        throw new Error('Requested tx was not found.');
    }
    // User-friendly output
    console.log(flattenTransaction(txToInspect));
    // Verbose output
    console.log(txToInspect);
});
```

## Dump values from a contract

There are three TVM debug [instructions](/tvm/instructions#fe-debug): `DUMPSTK`, `STRDUMP`, and `DUMP`.

Availability depends on the language you use.

These instructions are wrapped in functions with different names in each language:

- In Tolk, use functions from the globally available `debug` object.
- In FunC, these methods are available globally in `stdlib.fc`.
- In Tact, use `dumpStack` for `DUMPSTK` and [dump function](https://docs.tact-lang.org/ref/core-debug/#dump) for the other two. Tact also prints the exact line where `dump` is called, so you can quickly find it in your code.

<Aside
  type="caution"
>
  Debug instructions consume gas and affect gas measurement. Remove them before measuring gas or deploying to production.
</Aside>

## Explore TVM logs

```ts TypeScript
const blockchain = await Blockchain.create();
blockchain.verbosity.vmLogs = "vm_logs";
```

Of all [verbosity levels](/ecosystem/blueprint/testing/reference#verbosity-2), two are the most useful:

- `vm_logs` — outputs VM logs for each transaction; includes executed instructions and occurred exceptions.
- `vm_logs_full` — outputs full VM logs for each transaction; includes executed instructions with binary offsets, the current stack for each instruction, and gas used by each instruction.

Typical output for `vm_logs` looks like this:

```text
...
execute SWAP
execute PUSHCONT x30
execute IFJMP
execute LDU 64
handling exception code 9: cell underflow
default exception handler, terminating vm with exit code 9
```

The contract tries to load a 64‑bit integer from the slice, using `LDU 64`. There is not enough data, so [exit code 9](/tvm/exit-codes#9%3A-cell-underflow) occurs.

Inspect the same code with the `vm_logs_full` verbosity level. Output is heavily truncated from the top.

```text
...
execute PUSHCONT x30
gas remaining: 999018
stack: [ 500000000 CS{Cell{02b168008d0d4580cd8f09522be7c0390a7a632bda4a99291c435b767c95367ebe78e9af0023d36bc5f97853f4c898f868f95b035ae8f555a321d0ffce8d9f6165e2252d7a9077359400060e9fc800000000003d0902d1b85b3919} bits: 711..711; refs: 2..2} 0 Cont{vmc_std} ]
code cell hash: F9EAC82B7999AEEF696D592FE2469B9069FB05ED35C92213D7EE516F45AB97CA offset: 344
execute IFJMP
gas remaining: 999000
stack: [ 500000000 CS{Cell{02b168008d0d4580cd8f09522be7c0390a7a632bda4a99291c435b767c95367ebe78e9af0023d36bc5f97853f4c898f868f95b035ae8f555a321d0ffce8d9f6165e2252d7a9077359400060e9fc800000000003d0902d1b85b3919} bits: 711..725; refs: 2..2} ]
code cell hash: F9EAC82B7999AEEF696D592FE2469B9069FB05ED35C92213D7EE516F45AB97CA offset: 352
execute LDU 64
handling exception code 9: cell underflow
default exception handler, terminating vm with exit code 9
```

<Aside type="tip">
  To investigate the error in more detail, examine the source code of TVM for the `LDU` instruction.
  Sometimes several instructions are implemented in a single exec_* method, e.g. [LDU](/tvm/instructions#d3-ldu) (`load_uint`), [LDI](/tvm/instructions#d2-ldi) (`load_int`) and it's preload versions `(`preload\_uint`and`preload\_int\`).
  See, how `LDU` [is implemented](https://github.com/ton-blockchain/ton/blob/34823b1ea378edbe3bc59f3bcc48126480a0b768/crypto/vm/cellops.cpp#L981)
</Aside>

Stack is printed as `[bottom, ..., top]`, where `top` is the top of the stack.

Here, the stack contains two values:

- The slice being read (`CS{Cell{...} bits: 711..725; refs: 2..2}`)
- Integer (`500000000`)

However, the slice has only **725** bits, and **711** bits were already read, as were both [references](/tvm/serialization/cells). The contract tried to read **64** bits, but there was not enough data in the slice.

In FunC, locate the `load_uint(64)` call causing the issue and ensure enough bits are available or adjust the read width.

**TVM log limits**

The size of TVM debug output depends on the verbosity level:

| Level |                                     Setting                                    |        Max size       |
| ----- | :----------------------------------------------------------------------------: | :-------------------: |
| 0     |                                     `none`                                     | 256 bytes _(default)_ |
| 1–4   | `vm_logs` <br /> `vm_logs_location` <br /> `vm_logs_gas` <br /> `vm_logs_full` |          1 MB         |
| 5     |                                `vm_logs_verbose`                               |         32 MB         |

When the output exceeds its limit, it is truncated **from the bottom** —
older entries are discarded, and only the most recent lines are kept.
Logs are **not rotated**.

## Explore the trace

For traces that are not too large, print all transactions and inspect them.

```ts TypeScript
const deployRes = await contract.send(owner.getSender(), { value: toNano(0.5), bounce: true }, null);
for (const tx of deployRes.transactions) {
    console.log(flattenTransaction(tx));
}
```

For complex traces, use a GUI tool. Two tools are commonly used:

- [TonDevWallet trace view](/ecosystem/wallet-apps/dev) — requires the TonDevWallet application; does not require a custom `@ton/sandbox`; requires the `@tondevwallet/traces` package.
- [TxTracer Sandbox](https://txtracer.ton.org/sandbox/) — requires a custom `@ton/sandbox` package; runs in your browser.

Also, these tools allow you to explore each transaction's logs.
