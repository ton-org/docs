---
title: "Vanity"
---

A [vanity contract](https://github.com/ton-community/vanity-contract) allows _customizing_ the address of a smart contract that is being deployed. It does that by making its own StateInit depend on some constant data that is then randomly generated many times until a desired address is found. It is often used to deploy smart contracts with some specific prefix or a suffix so that it's visible in explorers.

Actual code and data of the smart contract being deployed are included in the deploy message of the vanity contract, which it takes and simply replaces its own state with that. As a result, the smart contract is initially deployed with a certain StateInit producing the desired address (see [Addresses overview](/foundations/addresses/overview#account-id)), and actual state is then immediately set based on what is provided.

## How it works

The code of vanity contract:

```func
(int) slice_equal(slice s1, slice s2) asm "SDEQ";

() recv_internal(cell in_msg_cell, slice in_msg) impure {
    ;; Parse data
    var ds = get_data().begin_parse();
    ds~skip_bits(5); ;; Padding
    var owner = ds~load_msg_addr();
    ds~skip_bits(256);
    ds.end_parse();

    ;; Parse message
    var cs = in_msg_cell.begin_parse();
    var flags = cs~load_uint(4);  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
    slice sender = cs~load_msg_addr();

    ;; Allow deployment only to owner
    throw_unless(8, slice_equal(sender, owner));

    ;; Set code and data
    var code = in_msg~load_ref();
    var data = in_msg~load_ref();
    in_msg.end_parse();
    set_code(code);
    set_data(data);
}
```

It checks whether the message is coming from an owner specified in data, and replaces its code and data with the new ones provided in the incoming message. This logic is trivial and the whole trick is in the 256-bit salt that is present in this contract's StateInit apart from 5 padding bits and owner address. Salt is skipped in the contract code with `ds~skip_bits(256);` as it's not needed during the execution, but it serves a purpose of deciding what address the contract will have.

Since contract addresses depend on the hash of StateInit, it is possible to add some data to that StateInit in order to change the address randomly. Vanity contract utilizes this by generating millions of random salt parameters that are included in StateInit and searching for ones that produce the desired address. This is pretty similar to how mining works in proof-of-work blockchains. The salt generation logic lives in a separate Python script that uses OpenCL for faster search on GPU.

## Generating salt

To generate the salt, copy the code available in [src/generator](https://github.com/ton-community/vanity-contract/tree/main/src/generator) directory of the same [vanity contract](https://github.com/ton-community/vanity-contract) repository. It includes `run.py` script and `vanity.cl` OpenCL kernel.

Then run a command with desired search parameters, including `-w` for workchain and the owner address which will be allowed to perform the deployment. For example, the following command is for search in basechain for `TEST` suffix.

```bash
python3 run.py -w 0 --end 'TEST' --case-sensitive UQCSQnz9h3iilIHMueOPs8RaryGqzb-bJpReZuZAUsm6TDRo
```

After running, it will print some logs and then start the search, printing every found salt. It also writes found salts into `found.txt` file. The search will continue until you stop it, or after the first found salt if `--only-one` flag is used. Example output:

```
Searching wallets case-sensitive, with "TEST" in the end
Owner:  UQCSQnz9h3iilIHMueOPs8RaryGqzb-bJpReZuZAUsm6TDRo
Flags:  1100
Kernel conditions: result[44] == 'T' && result[45] == 'E' && result[46] == 'S' && result[47] == 'T'

Using device:  Apple M2 Max
Speed: 198 Mh/s, miss: 4, found: 0
Speed: 204 Mh/s, miss: 2, found: 0
Found:  EQBas7IlwGKmd6CT7_l0PLynkUv2fmrANn2FFgcMntBATEST salt:  1045adb4ffb9af72021354a07a6f3e64ebc9822775f80b7d98beb195f57093df
Speed: 207 Mh/s, miss: 1, found: 1
Speed: 206 Mh/s, miss: 4, found: 1
Found:  EQB1p467NtIyNpwVAF0qZYDCaXzA56mk8P6nqt6QJFeQTEST salt:  fa683a39082696af7bafecaa63f6172b615f5b7d89fea24c941d52aa3310bbc3
Speed: 208 Mh/s, miss: 0, found: 2
Speed: 205 Mh/s, miss: 2, found: 2
Speed: 208 Mh/s, miss: 2, found: 2
Found:  EQBXaec9-r5Ge65hXTQopw7akH6LQr4rms9DdzkhxcUiTEST salt:  e7336b387099b3f8a31fa114ff801b799f14f3fe7f6c27c6cf0ccbb542ab743d
Speed: 206 Mh/s, miss: 2, found: 3
Speed: 203 Mh/s, miss: 2, found: 3
Speed: 203 Mh/s, miss: 3, found: 3
```

The more specific search is, the rarer the matches, and the more compute will be spent to find one. It takes just a couple of seconds to find a 4 character match on a laptop. Once the salt is found, it can be used to deploy an arbitrary smart contract on that address.

## Deploying contract

[Blueprint](/contract-dev/blueprint/overview#blueprint-overview) will be used further. Let's suppose that some `ExampleContract` will be deployed. A vanity contract wrapper at `wrappers/VanityContract.ts` is also needed:

```ts
import { Address, beginCell, Cell, Contract, contractAddress, ContractProvider, Sender, SendMode } from '@ton/core';

export type VanityContractConfig = {
    owner: Address;
    salt: Buffer;
};

export function vanityContractConfigToCell(config: VanityContractConfig): Cell {
    return beginCell().storeUint(0, 5).storeAddress(config.owner).storeBuffer(config.salt, 32).endCell();
}

// from https://github.com/ton-community/vanity-contract/blob/main/src/contract/vanity-address.cell
const vanityCode = Cell.fromBoc(
    Buffer.from(
        'b5ee9c72010102010032000114ff00f4a413f4bcf2c80b010046d3ed44d075d721fa408307d721d102d0d30331fa403058c705f288d4d4d101fb04ed54',
        'hex',
    ),
)[0];

export class VanityContract implements Contract {
    constructor(
        readonly address: Address,
        readonly init?: { code: Cell; data: Cell },
    ) {}

    static createFromAddress(address: Address) {
        return new VanityContract(address);
    }

    static createFromConfig(config: VanityContractConfig, workchain = 0) {
        const data = vanityContractConfigToCell(config);
        const init = { code: vanityCode, data };
        return new VanityContract(contractAddress(workchain, init), init);
    }

    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint, newCode: Cell, newData: Cell) {
        await provider.internal(via, {
            value,
            sendMode: SendMode.PAY_GAS_SEPARATELY,
            body: beginCell().storeRef(newCode).storeRef(newData).endCell(),
        });
    }
}
```

Now a script for deployment can be implemented at `scripts/deployExampleContract.ts`:

```ts
import { toNano, Address } from '@ton/core';
import { ExampleContract } from '../wrappers/ExampleContract';
import { VanityContract } from '../wrappers/VanityContract';
import { compile, NetworkProvider } from '@ton/blueprint';

export async function run(provider: NetworkProvider) {
    const vanityContract = provider.open(
        VanityContract.createFromConfig({
            owner: Address.parse('UQCSQnz9h3iilIHMueOPs8RaryGqzb-bJpReZuZAUsm6TDRo'),
            salt: Buffer.from('06ba57939d1baf392b9664c79cc08cd4b684727589451a9a11bbf16146877a5b', 'hex'),
        }),
    );

    const exampleContract = provider.open(ExampleContract.createFromConfig({}, await compile('ExampleContract')));

    await vanityContract.sendDeploy(
        provider.sender(),
        toNano('0.01'),
        exampleContract.init!.code,
        exampleContract.init!.data,
    );

    await provider.waitForDeploy(vanityContract.address);
}
```

Now it's possible to run the script via `npx blueprint run` and the contract should be deployed if the salt and owner are correct. The `ExampleContract` can be replaced with any contract and can have any code and data, since vanity contract does not care about these specifics.
