---
title: "Your first smart contract"
---

import { Aside } from "/snippets/aside.jsx";
import { FenceTable } from "/snippets/fence-table.jsx";

This tutorial covers building, deploying, and interacting with a smart contract on TON from start to finish.

## Prerequisites

- Basic programming: variables, functions, if/else statements
- Basic familiarity with a commandâ€‘line interface and executing commands
- Node.jsâ€”v22 or laterâ€” [download here](https://nodejs.org/)
  - Check if installed: `node -v` in terminal
- [TON wallet](/ecosystem/wallet-apps/overview)


## Development environment

  <Steps>
    <Step
      title="Set up development environment"
    >

      Use the [Blueprint](/contract-dev/blueprint/overview) development toolkit for smart contracts. Start a new project with:

      ```bash
      npm create ton@latest -- Example --contractName FirstContract --type tolk-empty
      ```

      This command creates a project named "Example", containing a contract named "FirstContract".

      The generated project structure is:

      <FenceTable>
        Example/
        â”œâ”€â”€contracts/                        # smart contract source code
        â”‚   â””â”€â”€ first_contract.tolk          # main contract file
        â”œâ”€â”€ scripts/                         # deployment and on-chain interaction scripts
        â”‚   â””â”€â”€ deployFirstContract.ts       # script to deploy the contract
        â”œâ”€â”€ tests/                           # testing specifications
        â”‚   â””â”€â”€ FirstContract.spec.ts        # contract test file
        â”œâ”€â”€ wrappers/                        # TypeScript wrappers for contract interaction
        â”‚   â”œâ”€â”€ FirstContract.ts             # wrapper class for the smart contract
        â”‚   â””â”€â”€ FirstContract.compile.ts     # configuration for compiling contract

      </FenceTable>

      <Aside>
        The TON ecosystem provides editor plugins with syntax support for IDEs and code editors. View them [here](/contract-dev/ide/overview).
      </Aside>

    </Step>

    <Step
      title="Move into the project directory"
    >

      ```bash
      cd Example
      ```

    </Step>
  </Steps>


## Smart contract architecture

A **smart contract** is a computer program stored on [TON Blockchain](/foundations/overview) â€” a distributed database that many computers maintain together. It runs on the [TVM](/tvm/overview) (TON Virtual Machine) â€” the "computer" that runs smart contract code on TON.

The contract is made of two parts:

- **Code** (compiled TVM instructions) - the "rules" or "program logic"
- **Data** (persistent state) - the "memory" that remembers things between interactions

Both are stored at a specific **address** on TON Blockchain, a unique identifier for each smart contract.

Every smart contract in TON is typically divided into three sections: **storage**, **messages**, and **getters**.

- **Storage**: Defines the contractâ€™s persistent data. For example, our _counter_ variable must keep its value across calls from different users.
- **Messages**: Define how the contract reacts to incoming messages. On TON, the primary way to interact with contracts is by sending [messages](/foundations/transaction). Each processed message produces a [transaction](/foundations/transaction) â€” a recorded change on the blockchain (like "Alice sent 5 TON to Bob").
- **Getters**: Provide read-only access to contract data without modifying state. For example, weâ€™ll create a getter to return the current value of the counter.

<Aside
  type="caution"
>
  Due to the [TON architecture](/from-ethereum#on-chain-get-methods), getters cannot be called from other contracts.
  Inter-contract communication is possible only through **messages**.
</Aside>

## Write the smart contract

To build a simple counter contract:
- Start with an initial counter value.
- Send `increase` messages to add to the counter or `reset` messages to set it to 0.
- Call a `getter` to return the current counter value.

The contract uses [**Tolk**](/languages/tolk). Tolk syntax is similar to TypeScript and Rust, designed for smart contract development.

<Steps>
  <Step
    title="Define contract storage"
  >

    To define contract storage, store the counter value. Tolk makes it simple with <Tooltip tip="A structure is a composite data type that groups named fields, each having its own type, into one unit." cta="Learn more" href="/languages/tolk">structures</Tooltip>:

    ```tolk title="./contracts/first_contract.tolk"
    struct Storage {
    counter: uint64; // the current counter value
  }

    // load contract data from persistent storage
    fun Storage.load() {
    return Storage.fromCell(contract.getData())
  }

    // save contract data to persistent storage
    fun Storage.save(self) {
    contract.setData(self.toCell())
  }
    ```

    Structures serialize and deserialize automatically into [cells](/foundations/serialization/cells), the storage unit in TON. The `fromCell` and `toCell` functions handle conversion between structures and cells.

  </Step>

  <Step
    title="Implement message handlers"
  >

    To process messages, implement the `onInternalMessage` function. It receives one argument â€” the incoming message. Focus on the `body` field, which contains the payload sent by a user or another contract.

    Define two message structures:

    - `IncreaseCounter` â€” contains one field `increaseBy` to increment the counter.
    - `ResetCounter` â€” resets the counter to 0.

    Each structure has a unique prefix â€”`0x7e8764ef` and `0x3a752f06`â€” called opcodes, that  which allows the contract to distinguish between messages.


    ```tolk title="./contracts/first_contract.tolk"
    struct(0x7e8764ef) IncreaseCounter {
    increaseBy: uint32
  }

    struct(0x3a752f06) ResetCounter {}
    ```

    Group the messages into a union. A union bundles multiple types into a single type and supports automatic serialization and deserialization:

    ```tolk title="./contracts/first_contract.tolk"
    type AllowedMessage = IncreaseCounter | ResetCounter;
    ```

    Now implement the message handler:

    ```tolk title="./contracts/first_contract.tolk"
    fun onInternalMessage(in: InMessage) {
    // use `lazy` to defer parsing until fields are accessed
    val msg = lazy AllowedMessage.fromSlice(in.body);

    // matching the union to determine body structure
    match (msg) {
    IncreaseCounter => {
    // load contract storage lazily (efficient for large or partial reads/updates)
    var storage = lazy Storage.load();
    storage.counter += msg.increaseBy;
    storage.save();
  }

    ResetCounter => {
    var storage = lazy Storage.load();
    storage.counter = 0;
    storage.save();
  }

    // this match branch would be executed if the message body does not match IncreaseCounter or ResetCounter structures
    else => {
    // reject user message (throw) if body is not empty
    assert(in.body.isEmpty()) throw 0xFFFF
  }
  }
  }
    ```

  </Step>

  <Step
    title="Add getter functions"
  >
    Write a getter function to return the current counter:

    ```tolk title="./contracts/first_contract.tolk"
    get fun currentCounter(): int {
    val storage = lazy Storage.load();
    return storage.counter;
  }
    ```

  </Step>

  <Step
    title="Complete contract code"
  >

    The contract now includes:
    - Storage â€” persistent `counter` value
    - Messages â€” `IncreaseCounter` and `ResetCounter` handlers
    - Getter â€” `currentCounter` function

    <Accordion
    title="Full source code">

      ```tolk title="./contracts/first_contract.tolk"
      struct Storage {
      counter: uint64;
    }

      fun Storage.load() {
      return Storage.fromCell(contract.getData());
    }

      fun Storage.save(self) {
      contract.setData(self.toCell());
    }

      struct(0x7e8764ef) IncreaseCounter {
      increaseBy: uint32
    }

      struct(0x3a752f06) ResetCounter {}

      type AllowedMessage = IncreaseCounter | ResetCounter;

      fun onInternalMessage(in: InMessage) {
      val msg = lazy AllowedMessage.fromSlice(in.body);

      match (msg) {
      IncreaseCounter => {
      var storage = lazy Storage.load();
      storage.counter += msg.increaseBy;
      storage.save();
    }

      ResetCounter => {
      var storage = lazy Storage.load();
      storage.counter = 0;
      storage.save();
    }

      else => {
      assert(in.body.isEmpty()) throw 0xFFFF;
    }
    }
    }

      get fun currentCounter(): int {
      val storage = lazy Storage.load();
      return storage.counter;
    }
      ```

    </Accordion>

  </Step>

</Steps>


## Compile the contract

To build the contract, compile it into bytecode for execution by the TVM. Use Blueprint with command:

```bash
npx blueprint build FirstContract
```

Expected output:

```
Build script running, compiling FirstContract
ðŸ”§ Using tolk version 1.1.0...

âœ… Compiled successfully! Cell BOC result:

{
  "hash": "fbfb4be0cf4ed74123b40d07fb5b7216b0f7d3195131ab21115dda537bad2baf",
  "hashBase64": "+/tL4M9O10EjtA0H+1tyFrD30xlRMashEV3aU3utK68=",
  "hex": "b5ee9c7241010401005b000114ff00f4a413f4bcf2c80b0102016202030078d0f891f24020d72c23f43b277c8e1331ed44d001d70b1f01d70b3fa0c8cb3fc9ed54e0d72c21d3a9783431983070c8cb3fc9ed54e0840f01c700f2f40011a195a1da89a1ae167fe3084b2d"
}

âœ… Wrote compilation artifact to build/FirstContract.compiled.json
```

The compilation artifact contains the contract bytecode. This file is required for deployment.

Next, deploy the contract to the TON blockchain and interact with it using scripts and wrappers.

## Deploy to testnet

<Steps>
  <Step
    title="Create a wrapper file"
  >

    Create a wrapper class to deploy and interact with the contract. Wrappers implement the `Contract` interface and TypeScript integration.

    Create `./wrappers/FirstContract.ts` with the following code:

    ```typescript title="./wrappers/FirstContract.ts"
    import { Address, beginCell, Cell, Contract, contractAddress, ContractProvider, Sender, SendMode } from '@ton/core';

    export class FirstContract implements Contract {
    constructor(
    readonly address: Address,
    readonly init?: { code: Cell; data: Cell },
    ) {}

    static createFromConfig(config: { counter: number }, code: Cell, workchain = 0) {
    const data = beginCell().storeUint(config.counter, 64).endCell();
    const init = { code, data };
    return new FirstContract(contractAddress(workchain, init), init);
  }

    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {
    await provider.internal(via, {
    value,
    sendMode: SendMode.PAY_GAS_SEPARATELY,
  });
  }
  }
    ```

    Wrapper class details:

    - [`@ton/core`](https://www.npmjs.com/package/@ton/core) â€” a library with base TON types.
    - The function `createFromConfig` builds a wrapper using:
        - code â€” compiled bytecode
        - data â€” the initial storage layout
    - The contract [address](/foundations/addresses/overview) is derived deterministically from `code + data` using `contractAddress`.
    - The method `sendDeploy` sends the first message with `stateInit`, triggering deployment. In practice, this can be an empty message with Toncoin attached.

  </Step>

  <Step
    title="Choose the network">

    TON provides two networks for deployment:

    - **testnet** â€” developer sandbox.
    - **mainnet** â€” production blockchain.

    This tutorial uses testnet. Mainnet deployment is possible once the contract is verified and ready for production.

  </Step>

  <Step
    title="Create the deployment script">

    Write a script `./scripts/deployFirstContract.ts` to deploy the contract:

    ```typescript title="./scripts/deployFirstContract.ts"
    import { toNano } from '@ton/core';
    import { FirstContract } from '../wrappers/FirstContract';
    import { compile, NetworkProvider } from '@ton/blueprint';

    export async function run(provider: NetworkProvider) {
    const firstContract = provider.open(
    FirstContract.createFromConfig(
  { counter: Math.floor(Math.random() * 10000000) },
    await compile('FirstContract')
    )
    );

    await firstContract.sendDeploy(provider.sender(), toNano('0.05'));

    await provider.waitForDeploy(firstContract.address);
  }
    ```

    The `sendDeploy` method accepts three arguments. Only two arguments are passed because `provider.open` automatically provides the `ContractProvider` as the first argument.

  </Step>

  <Step title="Run the script">

    Run the script with:

    ```bash
    npx blueprint run deployFirstContract --testnet --tonconnect --tonviewer
    ```

    Learn more about [Blueprint deployment](/contract-dev/blueprint/deploy).

  </Step>
  <Step title="Confirm transaction">

    <Aside title="Wallet required" type="note">
      If a wallet is not installed, check the [wallets overview](/ecosystem/wallet-apps/overview) to select and install a wallet before deploying the contract.
    </Aside>

    Choose the wallet, scan the QR code displayed in the console, and confirm the transaction in your wallet app.

    Expected output:

    ```text
    Using file: deployFirstContract
    ? Choose your wallet Tonkeeper

    <QR_CODE_HERE>

    Connected to wallet at address: ...
    Sending transaction. Approve in your wallet...
    Sent transaction
    Contract deployed at address kQBz-OQQ0Olnd4IPdLGZCqHkpuAO3zdPqAy92y6G-UUpiC_o
    You can view it at https://testnet.tonviewer.com/kQBz-OQQ0Olnd4IPdLGZCqHkpuAO3zdPqAy92y6G-UUpiC_o
    ```

    The link opens the contract on [Tonviewer](/ecosystem/explorers/tonviewer), a [blockchain explorer](/ecosystem/explorers/overview) showing transactions, messages, and account data.

    Next, interact with the contract by sending messages and calling getter functions.
  </Step>

</Steps>


## Contract interaction

Technically speaking, we've already sent messages to the contract - the deploy message in previous steps. Now let's see how to send messages with a body.


  <Steps>

    <Step title="Update wrapper class">
      Update our wrapper class with three methods: `sendIncrease`, `sendReset`, and `getCounter`:

      ```typescript title="./wrappers/FirstContract.ts" expandable
      import { Address, beginCell, Cell, Contract, contractAddress, ContractProvider, Sender, SendMode } from '@ton/core';

      export class FirstContract implements Contract {
      constructor(
      readonly address: Address,
      readonly init?: { code: Cell; data: Cell },
      ) {}

      static createFromConfig(config: { counter: number }, code: Cell, workchain = 0) {
      const data = beginCell().storeUint(config.counter, 64).endCell();
      const init = { code, data };
      return new FirstContract(contractAddress(workchain, init), init);
    }

      async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {
      await provider.internal(via, {
      value,
      sendMode: SendMode.PAY_GAS_SEPARATELY,
      body: beginCell().endCell(),
    });
    }

      async sendIncrease(
      provider: ContractProvider,
      via: Sender,
      opts: {
      increaseBy: number;
      value: bigint;
    },
      ) {
      await provider.internal(via, {
      value: opts.value,
      sendMode: SendMode.PAY_GAS_SEPARATELY,
      body: beginCell().storeUint(0x7e8764ef, 32).storeUint(opts.increaseBy, 32).endCell(),
    });
    }

      async sendReset(
      provider: ContractProvider,
      via: Sender,
      opts: {
      value: bigint;
    },
      ) {
      await provider.internal(via, {
      value: opts.value,
      sendMode: SendMode.PAY_GAS_SEPARATELY,
      body: beginCell().storeUint(0x3a752f06, 32).endCell(),
    });
    }

      async getCounter(provider: ContractProvider) {
      const result = await provider.get('currentCounter', []);
      return result.stack.readNumber();
    }
    }
      ```

      The only difference from the deploy message is that we pass a **body** to it â€” remember the cells I talked about previously? The message body is a cell that contains our instructions.

      **Building message bodies**

      Construction of cells starts with the `beginCell` method:

      - `beginCell()` - creates a new cell builder
      - `storeUint(value, bits)` - adds an unsigned integer of specified bit length
      - `endCell()` - finalizes the cell

      **Example**: `beginCell().storeUint(0x7e8764ef, 32).storeUint(42, 32).endCell()`

      - First 32 bits: `0x7e8764ef` (opcode for "increase")
      - Next 32 bits: `42` (increase by this amount)
    </Step>

    <Step title="Send messages to your contract">

      Now that our contract is deployed and we have wrapper methods, let's interact with it by sending messages.

      Let's create a script `./scripts/sendIncrease.ts` that would increase the counter:

      ```typescript title="./scripts/sendIncrease.ts"
      import { Address, toNano } from '@ton/core';
      import { FirstContract } from '../wrappers/FirstContract';
      import { NetworkProvider } from '@ton/blueprint';

      const contractAddress = Address.parse('<CONTRACT_ADDRESS>');

      export async function run(provider: NetworkProvider) {
        const firstContract = provider.open(new FirstContract(contractAddress));
        await firstContract.sendIncrease(provider.sender(), { value: toNano('0.05'), increaseBy: 42 });
        await provider.waitForLastTransaction();
      }
      ```

      Do not forget to replace `<CONTRACT_ADDRESS>` with your actual contract address from Step 5!

        **Understanding the script breakdown:**

        - **Address parsing**: `Address.parse()` converts the string address to a TON Address object
        - **Contract opening**: `provider.open()` creates a connection to the deployed contract
        - **Value attachment**: `toNano('0.05')` converts 0.05 TON to nanotons (the smallest TON unit)
        - **Message parameters**: `increaseBy: 42` tells the contract to increase the counter by 42
        - **Transaction waiting**: `waitForLastTransaction()` waits for the transaction to be processed on-chain

      To run this script:

      ```bash
      npx blueprint run sendIncrease --testnet --tonconnect --tonviewer
      ```

      Expected result:

      ```text
      Using file: sendIncrease
      Connected to wallet at address: ...
      Sending transaction. Approve in your wallet...
      Sent transaction
      Transaction 0fc1421b06b01c65963fa76f5d24473effd6d63fc4ea3b6ea7739cc533ba62ee successfully applied!
      You can view it at https://testnet.tonviewer.com/transaction/fe6380dc2e4fab5c2caf41164d204e2f41bebe7a3ad2cb258803759be41b5734
      ```

      **What happens during execution:**

      1. **Wallet Connection**: Blueprint connects to your wallet using [TON Connect](/ecosystem/ton-connect/overview) protocol
      1. **Transaction Building**: The script creates a transaction with the message body containing the opcode `0x7e8764ef` and the value `42`
      1. **User Approval**: Your wallet app shows the transaction details for approval
      1. **Blockchain Processing**: Once approved, the transaction is sent to the TON network
      1. **Validator Consensus**: Validators need to produce a new block containing your transaction
      1. **Contract Execution**: The contract receives the message, processes it in the `onInternalMessage` function, and updates the counter
      1. **Confirmation**: The transaction hash is returned, and you can view it on the explorer

      <Aside type={"tip"}>
        **Composability**: Messages can be sent to your contract by other contracts, too! This means different contracts can increment your counter, allowing the TON ecosystem to create composable apps and protocols that build on top of each other and interact in unforeseen ways.
      </Aside>
    </Step>

    <Step title="Reset the counter">
      Let's create a script `./scripts/sendReset.ts` that would reset the counter:

      ```typescript title="./scripts/sendReset.ts"
      import { Address, toNano } from '@ton/core';
      import { FirstContract } from '../wrappers/FirstContract';
      import { NetworkProvider } from '@ton/blueprint';

      const contractAddress = Address.parse('<CONTRACT_ADDRESS>');

      export async function run(provider: NetworkProvider) {
        const firstContract = provider.open(new FirstContract(contractAddress));
        await firstContract.sendReset(provider.sender(), { value: toNano('0.05') });
        await provider.waitForLastTransaction();
      }
      ```

      To run this script:

      ```bash
      npx blueprint run sendReset --testnet --tonconnect --tonviewer
      ```

      Expected result:

      ```text
      Using file: sendReset
      Connected to wallet at address: ...
      Sending transaction. Approve in your wallet...
      Sent transaction
      Transaction 0fc1421b06b01c65963fa76f5d24473effd6d63fc4ea3b6ea7739cc533ba62ee successfully applied!
      You can view it at https://testnet.tonviewer.com/transaction/fe6380dc2e4fab5c2caf41164d204e2f41bebe7a3ad2cb258803759be41b5734
      ```

    </Step>

    <Step title="Read contract data with get methods">

      Get methods are special functions in TON smart contracts that allow you to read data without modifying the contract state or spending gas fees. Unlike message-based interactions, get methods:

      - **Cost nothing**: No gas fees required since they don't modify blockchain state
      - **Execute instantly**: No need to wait for blockchain confirmation
      - **Read-only**: Cannot change contract storage or send messages

      To call a get method, use `provider.get(<GET_METHOD_NAME>)`:

      ```typescript title="./scripts/getCounter.ts"
      import { Address } from '@ton/core';
      import { FirstContract } from '../wrappers/FirstContract';
      import { NetworkProvider } from '@ton/blueprint';

      const contractAddress = Address.parse('<CONTRACT_ADDRESS>');

        export async function run(provider: NetworkProvider) {
          const firstContract = provider.open(new FirstContract(contractAddress));
          const counter = await firstContract.getCounter();
          console.log('Counter: ', counter);
        }
        ```

        **Understanding the get method execution:**

        1. **Direct contract call**: The `getCounter()` method directly calls the contract's `currentCounter` getter
        1. **Instant response**: The result is returned immediately without blockchain confirmation
        1. **Data parsing**: Our wrapper automatically converts the returned stack value to a JavaScript number

        <Aside>
          Getters are only accessible **off-chain** (from JavaScript clients, web apps, etc.) through RPC service providers. **Contracts cannot call getters on other contracts** - inter-contract communication must use messages only.
        </Aside>

        To run this script:

        ```bash
        npx blueprint run getCounter --testnet --tonconnect
        ```

        Expected output:

        ```bash
        Using file: getCounter
        Counter:  42
        ```

    </Step>

  </Steps>

<Aside
  title={"ðŸ“ Complete example code"}
>
  You can find the full working code for this tutorial in our [GitHub repository](https://github.com/ton-org/docs-examples/tree/main/guidebook/first-smart-contract/Example). This includes all contract files, scripts, and wrappers ready to use.
</Aside>



