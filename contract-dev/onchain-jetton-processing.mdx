---
title: "Onchain Jetton Processing"
sidebarTitle: "Jetton Processing"
---

import { Aside } from '/snippets/aside.jsx';

<Aside>
  Перед ознакомлением с данной статьёй нужно хорошо понять [архитектуру jetton](/standard/tokens/jettons/overview).
</Aside>

Очень часто в контрактах нужно работать с jetton. Например, при реализации DEX, ескроу-контрактов, лендинг протоколов и т.д. Проблема, которую нужно решать, звучит так: если пришёл Jetton Notify, то какой жетон был получен?

```mermaid
graph LR
A((Jetton Wallet)) -->|JettonNotify (0x7362d09c)| B((Contract))
```

## Простой случай - работа с конкретным jetton

Часто, в контракте не нужна поддержка произвольных jetton, а достаточно некоторого заранее известного набора. Например контракт может в качестве оплаты принимать только USDT. В случае когда набор jetton masters заранее известен, можно предпосчитать адреса jetton wallet-ов, с которых нужно обрабатывать пополнения. Тогда код в контракте будет выглядеть тривиально

```tolk
tolk 1.2;

struct Storage {
    jettonWalletSetter: address;
    trustedJettonWallet: address?;
}

fun Storage.load(): Storage {
    return Storage.fromCell(contract.getData());
}

fun Storage.save(self) {
    return contract.setData(self.toCell())
}

struct (0x7362d09c) JettonNotify {
    queryId: uint64
    jettonAmount: coins
    transferInitiator: address
    jettonVaultPayload: RemainingBitsAndRefs
}

struct (0x12345678) SetTrustedJettonWallet {
    trustedJettonWallet: address
}

type AllowedMessage = JettonNotify | SetTrustedJettonWallet;

fun onInternalMessage(in: InMessage) {
    val msg = lazy AllowedMessage.fromSlice(in.body);
    match (msg) {
        SetTrustedJettonWallet => {
            var storage = Storage.load();
            if (storage.jettonWalletSetter != in.senderAddress || storage.trustedJettonWallet != null) {
                return;
            }
            storage.trustedJettonWallet = msg.trustedJettonWallet;
            storage.save();
        },
        JettonNotify => {
            var storage = Storage.load();
            if (storage.trustedJettonWallet == null || storage.trustedJettonWallet != in.senderAddress) {
                return;
            }
            // Process jettons
        }
    }
}
```

При использовании такого подхода при деплое контракта нужно будет [посчитать корректный адрес jetton wallet-a](/standard/tokens/jettons/find), который будет обрабатывать пополнения. Важно понимать, что положить адрес jettonWallet сразу в стейт инит контракта нельзя, т.к. в этом случае адрес жетон-воллета зависит от адреса контракта, и получается кольцевая зависимость.

## Работа с любым TEP-89 совместимым jetton

Все современные жетоны обычно поддерживают [TEP-89](https://github.com/ton-blockchain/TEPs/blob/master/text/0089-jetton-wallet-discovery.md), который позволяет явно проверить, принадлежит ли jetton wallet конкретному jetton master-у.

В общем случае возможны два варианта того, откуда взять адрес jetton master. Иногда, как, например в [Dedust DEX](https://dedust.io/), адреса jetton master хранятся в контрактах, обрабатывающих пополнения соответствующих jetton. В других случаях, адрес жетон-мастера можно передавать в payload в `JettonNotify`. Какой вариант использовать, зависит от конкретной системы контрактов.

Когда адрес jetton master известен, то на него можно отправить сообщение providesWalletAddress и получить адрес jetton wallet.

```mermaid
graph LR
A((Contract))
B((Jetton Master))
C((Contract))

    A -->|provideWalletAddress (0x2c76b973)| B
    B -->|takeWalletAddress (0xd1735400)| C
```

Тогда контракт, инициализирующий jetton wallet таким образом может выглядеть так:
```tolk
tolk 1.2

struct Storage {
    jettonMasterAddress: address
    jettonWalletAddress: address?
}

fun Storage.load(): Storage {
    return Storage.fromCell(contract.getData());
}

fun Storage.save(self) {
    return contract.setData(self.toCell())
}

struct (0x2c76b973) ProvideWalletAddress {
    queryId: uint64
    ownerAddress: address
    includeAddress: bool
}

struct (0xd1735400) TakeWalletAddress {
    queryId: uint64
    walletAddress: address
    ownerAddress: Cell<address>?
}

struct (0x7362d09c) JettonNotify {
    queryId: uint64
    jettonAmount: coins
    transferInitiator: address
    jettonVaultPayload: RemainingBitsAndRefs
}

struct (0x12345678) InitContract {}

type AllowedMessage = InitContract | TakeWalletAddress | JettonNotify

fun onInternalMessage(in: InMessage) {
    val msg = lazy AllowedMessage.fromSlice(in.body);
    match (msg) {
        InitContract => {
            var storage = Storage.load();
            val msg = createMessage({
                bounce: true,
                value: 0,
                dest: storage.jettonMasterAddress,
                body: ProvideWalletAddress {
                    queryId: 0,
                    ownerAddress: contract.getAddress(),
                    includeAddress: false,
                },
            });
            msg.send(SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE);
        }
        TakeWalletAddress => {
            var storage = Storage.load();
            if (storage.jettonMasterAddress != in.senderAddress) {
                return;
            }
            storage.jettonWalletAddress = msg.walletAddress;
            storage.save();// After receiving such message contract is initialized
        }
        JettonNotify => {
            var storage = Storage.load();
            if (storage.jettonWalletAddress == null || storage.jettonWalletAddress != in.senderAddress) {
                return;
            }
            // Process jettons
        }
    }
}

```
## Jettons не поддерживающие TEP-89

Это ситуация является довольно редкой, и, например [TONCO DEX](https://tonco.io/) не поддерживает жетоны, не совместимые с TEP-89. Другие же DEX, такие как [Dedust](https://dedust.io/) и [Bidask](https://bidask.finance/en/) поддерживают такие жетоны через централизованное одобрение жетонов в ручном режиме. Если по какой-то причине такие жетоны в любом случае требуется обрабатывать, то существует два варианта. Оба варианта объединены идеей того, что если пользователь может прислать [state](/foundations/messages/state-init) контракта, на котором, используя инструкцию [RUNVM](/tvm/instructions#db4-runvm) можно ончейн выполнить [get-method](/tvm/get-method) `get_wallet_address`, который возвращает адрес jetton wallet для любого владельца. Чтобы это сделать можно использовать такую функцию на TVM-assembly:

```tolk
fun calculateJettonWallet(owner: address, jettonData: cell, jettonCode: cell, jettonMaster: address): address asm """
    c7 PUSHCTR
    0 INDEX // Unpack environment information from c7
    // https://docs.ton.org/tvm/registers#c7-%E2%80%94-environment-information-and-global-variables
    SWAP
    8 SETINDEX
    SWAP
    DUP
    ROTREV
    10 SETINDEX
    1 TUPLE // Make it singleton back
    // owner md mc c7
    ROTREV
    CTOS            // owner_addr c7 md mc"
    2 PUSHINT       // owner_addr c7 md mc args"
    103289 PUSHINT  // owner_addr c7 md mc args get_jwa_method_id"
    5 0 REVERSE     // owner_addr get_jwa_method_id args mc md c7"
    ONE 2 -ROLL // Moves the top stack value (ONE) to the third position: [A, B, C] -> [B, C, A]. We expect only 1 return value. Flag +256 for runvm enables this argument
    // Here is the full list of modes of RUNVM
    // +1 = same_c3 (set c3 to code)
    // +2 = push_0 (push an implicit 0 before running the code); only works with +1 enabled
    // +4 = load c4 (persistent data) from stack and return its final value
    // +8 = load gas limit from stack and return consumed gas
    // +16 = load c7 (smart-contract context)
    // +32 = return c5 (actions)
    // +64 = pop hard gas limit (enabled by ACCEPT) from stack as well
    // +128 = isolated gas consumption (separate set of visited cells, reset CHKSIGNU counter)
    // +256 = pop number N, return exactly N values from stack (only if res=0 or 1; if not enough then res=stk_und)
    //
    // We use only +1 +4 +16 +256 = 277
    // Mode 256 is crucial, because it ignores all stack values except the first one, and protects us from stack poisoning
    277 RUNVM        // address exit_code c4'"
    2 BLKDROP       // address";
"""
```

### Jettons не поддержвляющие TEP-89, но задеплоенные не через vanity
Если jetton был задеплоен не через [vanity](/contract-dev/vanity), то можно заметить, что всё время существования контракта, у него был этот гет-метод, а значит, можно использовать `StateInit`. Правильность присланного `StateInit` можно проверить, посчитав от него хэш и сверив его с требуемым JettonMaster

## Jettons, которым не подходит предыдущий метод
Если в `StateInit` жетона не было гет-метода `get_wallet_address` либо он возвращал неправильные адреса, то нужно использовать актуальный State. Для этого, нужно proof, что предоставленный State сейчас действительно находится на адресе jetton master. Это довольно сложно, и требует очень глубокого понимания организации данных в блокчейне TON, а поэтому описано в [отдельной статье](/foundations/proofs/overview).


