---
title: "Onchain Jetton Processing"
sidebarTitle: "Jetton Processing"
---

import { Aside } from '/snippets/aside.jsx';

<Aside>
  Read this article after understanding the [jetton architecture](/standard/tokens/jettons/overview).
</Aside>

Onchain contracts routinely process jettons for DEX routing, escrow, and lending protocols. Each contract must determine which jetton arrived when a `JettonNotify` message shows up.

```mermaid
graph LR
A((Jetton Wallet)) -->|JettonNotify (0x7362d09c)| B((Contract))
```

## Handle a fixed jetton

Many contracts accept payments only from a known set of jettons, such as a single USDT jetton minter. When the jetton minters are known, precompute the jetton wallet addresses to monitor and allow only those senders.

```tolk
tolk 1.2;

struct Storage {
    jettonWalletSetter: address;
    trustedJettonWallet: address?;
}

fun Storage.load(): Storage {
    return Storage.fromCell(contract.getData());
}

fun Storage.save(self) {
    return contract.setData(self.toCell())
}

struct (0x7362d09c) JettonNotify {
    queryId: uint64
    jettonAmount: coins
    transferInitiator: address
    jettonVaultPayload: RemainingBitsAndRefs
}

struct (0x12345678) SetTrustedJettonWallet {
    trustedJettonWallet: address
}

type AllowedMessage = JettonNotify | SetTrustedJettonWallet;

fun onInternalMessage(in: InMessage) {
    val msg = lazy AllowedMessage.fromSlice(in.body);
    match (msg) {
        SetTrustedJettonWallet => {
            var storage = Storage.load();
            if (storage.jettonWalletSetter != in.senderAddress || storage.trustedJettonWallet != null) {
                return;
            }
            storage.trustedJettonWallet = msg.trustedJettonWallet;
            storage.save();
        },
        JettonNotify => {
            var storage = Storage.load();
            if (storage.trustedJettonWallet == null || storage.trustedJettonWallet != in.senderAddress) {
                return;
            }
            // Process jettons
        }
    }
}
```

When deploying with this pattern, [calculate the jetton wallet address](/standard/tokens/jettons/find) that must receive top-ups. It is impossible to hardcode the jetton wallet address in the contractâ€™s state init, because the wallet address depends on the contract address and creates a circular dependency.

## Handle any TEP-89 jetton

Most modern jettons implement [TEP-89](https://github.com/ton-blockchain/TEPs/blob/master/text/0089-jetton-wallet-discovery.md), which proves whether a jetton wallet belongs to a specific jetton minter.

- Store trusted jetton minter addresses in the receiving contracts, as done in [Dedust DEX](https://dedust.io/).
- Send a `provideWalletAddress` request to get the jetton wallet address.

```mermaid
graph LR
A((Contract))
B((Jetton minter))
C((Contract))

    A -->|provideWalletAddress (0x2c76b973)| B
    B -->|takeWalletAddress (0xd1735400)| C
```

The contract that initializes the jetton wallet with this pattern can look like this:

```tolk
tolk 1.2

struct Storage {
    jettonMinterAddress: address
    jettonWalletAddress: address?
}

fun Storage.load(): Storage {
    return Storage.fromCell(contract.getData());
}

fun Storage.save(self) {
    return contract.setData(self.toCell())
}

struct (0x2c76b973) ProvideWalletAddress {
    queryId: uint64
    ownerAddress: address
    includeAddress: bool
}

struct (0xd1735400) TakeWalletAddress {
    queryId: uint64
    walletAddress: address
    ownerAddress: Cell<address>?
}

struct (0x7362d09c) JettonNotify {
    queryId: uint64
    jettonAmount: coins
    transferInitiator: address
    jettonVaultPayload: RemainingBitsAndRefs
}

struct (0x12345678) InitContract {}

type AllowedMessage = InitContract | TakeWalletAddress | JettonNotify

fun onInternalMessage(in: InMessage) {
    val msg = lazy AllowedMessage.fromSlice(in.body);
    match (msg) {
        InitContract => {
            var storage = Storage.load();
            val msg = createMessage({
                bounce: true,
                value: 0,
                dest: storage.jettonMinterAddress,
                body: ProvideWalletAddress {
                    queryId: 0,
                    ownerAddress: contract.getAddress(),
                    includeAddress: false,
                },
            });
            msg.send(SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE);
        }
        TakeWalletAddress => {
            var storage = Storage.load();
            if (storage.jettonMinterAddress != in.senderAddress) {
                return;
            }
            storage.jettonWalletAddress = msg.walletAddress;
            storage.save();// After receiving such message contract is initialized
        }
        JettonNotify => {
            var storage = Storage.load();
            if (storage.jettonWalletAddress == null || storage.jettonWalletAddress != in.senderAddress) {
                return;
            }
            // Process jettons
        }
    }
}
```

## Jettons without TEP-89 support

Non-TEP-89 jettons are rare. [TONCO DEX](https://tonco.io/) rejects them, while platforms such as [Dedust](https://dedust.io/) and [Bidask](https://bidask.finance/en/) allow them after a manual approval flow. When processing such jettons is mandatory, two approaches remain. Each approach assumes the contract can receive the jetton minter [state init](/foundations/messages/state-init) and execute the `get_wallet_address` [get-method](/tvm/get-method) on-chain via [RUNVM](/tvm/instructions#db4-runvm) to derive the wallet address for any owner. The following TVM assembly helper performs that call:

```tolk
fun calculateJettonWallet(owner: address, jettonData: cell, jettonCode: cell, jettonMinter: address): address asm """
    c7 PUSHCTR
    0 INDEX // Unpack environment information from c7
    // https://docs.ton.org/tvm/registers#c7-%E2%80%94-environment-information-and-global-variables
    SWAP
    8 SETINDEX
    SWAP
    DUP
    ROTREV
    10 SETINDEX
    1 TUPLE // Make it singleton back
    // owner md mc c7
    ROTREV
    CTOS            // owner_addr c7 md mc"
    2 PUSHINT       // owner_addr c7 md mc args"
    103289 PUSHINT  // owner_addr c7 md mc args get_jwa_method_id"
    5 0 REVERSE     // owner_addr get_jwa_method_id args mc md c7"
    ONE 2 -ROLL // Moves the top stack value (ONE) to the third position: [A, B, C] -> [B, C, A]. We expect only 1 return value. Flag +256 for runvm enables this argument
    // Here is the full list of modes of RUNVM
    // +1 = same_c3 (set c3 to code)
    // +2 = push_0 (push an implicit 0 before running the code); only works with +1 enabled
    // +4 = load c4 (persistent data) from stack and return its final value
    // +8 = load gas limit from stack and return consumed gas
    // +16 = load c7 (smart-contract context)
    // +32 = return c5 (actions)
    // +64 = pop hard gas limit (enabled by ACCEPT) from stack as well
    // +128 = isolated gas consumption (separate set of visited cells, reset CHKSIGNU counter)
    // +256 = pop number N, return exactly N values from stack (only if res=0 or 1; if not enough then res=stk_und)
    //
    // We use only +1 +4 +16 +256 = 277
    // Mode 256 is crucial, because it ignores all stack values except the first one, and protects us from stack poisoning
    277 RUNVM        // address exit_code c4'"
    2 BLKDROP       // address";
"""
```

### Jettons without TEP-89 that avoided vanity addresses

If the jetton was not deployed with [vanity](/contract-dev/vanity), the contract always exposed `get_wallet_address`, so the original `StateInit` is enough. Verify the supplied `StateInit` by hashing it and comparing the result with the expected jetton minter address.

## Jettons where the previous method fails

If the jetton `StateInit` lacks the `get_wallet_address` method or returns incorrect addresses, rely on the current state instead. Proving that the provided state is live at the jetton minter address requires a full state proof, described in the [state proof overview](/foundations/proofs/overview).
