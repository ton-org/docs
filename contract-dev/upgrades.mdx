---
title: "Upgrading contracts"
---

import { Aside } from '/snippets/aside.jsx';

TON supports upgrading contract code and data. In Tolk, use `contract.setCodePostponed()` and `contract.setData()`. The upgrade completes in the [action phase](/foundations/phases#action-phase).

This pattern is used in [vanity](/patterns/vanity) contracts and when protocols need to upgrade while preserving existing contracts, such as DEXs where liquidity is critical.

<Aside type="caution">
  Contract upgrades change code behavior and can affect funds or contract state. Unauthorized upgrades can cause loss of control or funds. Restrict upgrade messages to trusted admin addresses only. For production contracts, use delayed upgrades to allow users to react to compromised admin keys.
</Aside>

## Basic upgrade pattern

The contract accepts upgrade messages containing new code and data. Only the admin can trigger upgrades.

```tolk Tolk 
struct (0x1111) UpgradeContract {
    Data: cell?
    Code: cell?
}

type AllowedMessages =
    | UpgradeContract

fun onInternalMessage(in: InMessage) {

    val msg = lazy AllowedMessages.fromSlice(in.body);

    match (msg) {

        UpgradeContract => {
            var storage = lazy Storage.load();
            assert (in.senderAddress == storage.adminAddress) throw 1111;
            if (msg.Code != null) {
                contract.setCodePostponed(msg.Code!);
            }
            if (msg.Data != null) {
                contract.setData(msg.Data!);
            }
        }

        else => { 
            // just accept TON 
        }
    }
}

struct Storage {
    adminAddress: address
}

fun Storage.load() {
    return Storage.fromCell(contract.getData());
}

fun Storage.save(self) {
    contract.setData(self.toCell());
}
```

## Delayed upgrades for production safety

When upgrading protocols that are already running and have users, delayed upgrades are a best practice. This provides additional security layers: if an admin is compromised, you can react in time. Users can also see the upgrade and withdraw funds from the protocol if it has been compromised.

The pattern adds a time delay between requesting and approving an upgrade. The admin must first request an upgrade, wait for a timeout period, then approve it.

```tolk Tolk
struct UpgradeContract {
    Data: cell?
    Code: cell?
}

struct CurrentRequest {
    newUpgrade: UpgradeContract
    timestamp: uint32
}

struct (0x00000001) RequestUpgrade {
    newUpgrade: UpgradeContract
}

struct (0x00000002) RejectUpgrade { }

struct (0x00000003) ApproveUpgrade { }

type AllowedMessages =
    | RequestUpgrade
    | RejectUpgrade
    | ApproveUpgrade

fun onInternalMessage(in: InMessage) {

    val msg = lazy AllowedMessages.fromSlice(in.body);

    match (msg) {

        RequestUpgrade => {
            var storage = lazy Storage.load();

            assert (in.senderAddress == storage.adminAddress) throw 1111;
            assert (storage.CurrentRequest == null) throw 101;

            storage.CurrentRequest = {
                newUpgrade: msg.newUpgrade,
                timestamp: blockchain.now()
            };

            storage.save();
        }

        RejectUpgrade => {
            var storage = lazy Storage.load();

            assert (in.senderAddress == storage.adminAddress) throw 1111;
            assert (storage.CurrentRequest != null) throw 201;

            storage.CurrentRequest = null;
            storage.save();
        }

        ApproveUpgrade => {
            var storage = lazy Storage.load();
            
            assert (in.senderAddress == storage.adminAddress) throw 1111;
            assert (storage.CurrentRequest != null) throw 301;
            assert (storage.CurrentRequest!.timestamp + storage.timeout < blockchain.now()) throw 302;

            if (storage.CurrentRequest!.newUpgrade.Code != null) {
                contract.setCodePostponed(storage.CurrentRequest!.newUpgrade.Code!);
            }
            if (storage.CurrentRequest!.newUpgrade.Data != null) {
                contract.setData(storage.CurrentRequest!.newUpgrade.Data!);
            }
            storage.CurrentRequest = null;
            storage.save();
        }

        else => { 
            // just accept TON 
        }
    }
}

get fun currentRequest() {
    var storage = lazy Storage.load();
    return storage.CurrentRequest;
}

struct Storage {
    adminAddress: address,
    timeout: uint32,
    CurrentRequest: CurrentRequest?
}

fun Storage.load() {
    return Storage.fromCell(contract.getData());
}

fun Storage.save(self) {
    contract.setData(self.toCell());
}
```
