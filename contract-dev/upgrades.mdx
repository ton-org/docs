---
title: "Upgrading contracts"
---

import { Aside } from '/snippets/aside.jsx';

## What is contract upgrading?

TON allows smart contracts to upgrade their code and data while preserving the contract's identity. During an upgrade:

- **Address remains unchanged** — the contract keeps its original address
- **Balance is preserved** — all TON and jettons remain for the contract
- **State persists** — the contract's data can be updated or preserved
- **Code is replaced** — new logic takes effect immediately after the upgrade

This is useful for fixing bugs, adding features, or adapting to protocol changes without migrating to a new contract. 

Upgrades are critical when other contracts reference the contract being upgraded. For example, NFT items reference their collection contract. The collection admin cannot modify these references stored in existing NFT items. Without upgrades, fixing bugs or adding features would require deploying a new collection and migrating all items—an expensive and complex process. Upgrades solve this by allowing the collection contract to evolve in place while preserving all existing references.

The pattern is also essential for [vanity](/contract-dev/vanity) contracts and protocols like DEXs where preserving the contract address and liquidity is critical.

## How upgrades work

TON provides two functions for upgrades in Tolk:

- **`contract.setCodePostponed(code: cell)`** — schedules the code to be replaced during the [action phase](/foundations/phases#action-phase). The new code takes effect after the current transaction completes.
- **`contract.setData(data: cell)`** — immediately replaces the contract's persistent storage. This happens during the [compute phase](/foundations/phases#compute-phase), before the transaction ends.

**Key difference**: `setCodePostponed()` applies changes *after* the current transaction, while `setData()` applies changes *immediately*. This means the new code won't run until the next message arrives, but the new data is already active.

<Aside
  type="caution"
>
  Contract upgrades change code behavior and can affect funds or contract state. Unauthorized upgrades can cause loss of control or funds. Restrict upgrade messages to trusted admin addresses only. For production contracts, use delayed upgrades to allow users to react to compromised admin keys.
</Aside>

## Basic upgrade pattern

The contract accepts upgrade messages containing new code and data. Only the admin can trigger upgrades.

**How it works step by step:**

1. **Admin sends upgrade message** — the message contains new code and/or data cells
1. **Contract verifies sender** — checks that the sender is the admin address
1. **Code is scheduled** — if new code is provided, `setCodePostponed()` schedules it for replacement
1. **Data is updated** — if new data is provided, `setData()` immediately replaces the storage
1. **Transaction completes** — the action phase executes, applying the new code
1. **Next message uses new code** — subsequent messages will execute with the upgraded logic

```tolk
struct (0x1111) UpgradeContract {
    data: cell?
    code: cell?
}

type AllowedMessages =
    | UpgradeContract

fun onInternalMessage(in: InMessage) {

    val msg = lazy AllowedMessages.fromSlice(in.body);

    match (msg) {

        UpgradeContract => {
            var storage = lazy Storage.load();
            assert (in.senderAddress == storage.adminAddress) throw 1111;
            if (msg.code != null) {
                contract.setCodePostponed(msg.code!);
            }
            if (msg.data != null) {
                contract.setData(msg.data!);
            }
        }

        else => { 
            // just accept TON 
        }
    }
}

struct Storage {
    adminAddress: address
}

fun Storage.load() {
    return Storage.fromCell(contract.getData());
}

fun Storage.save(self) {
    contract.setData(self.toCell());
}
```

## Delayed upgrades for production safety

When upgrading protocols that are already running and have users, delayed upgrades are a best practice. This provides additional security layers: if an admin is compromised, you can react in time. Users can also see the upgrade and withdraw funds from the protocol if it has been compromised.

The pattern adds a time delay between requesting and approving an upgrade. The admin must first request an upgrade, wait for a timeout period, then approve it.

```tolk
struct UpgradeContract {
    data: cell?
    code: cell?
}

struct CurrentRequest {
    newUpgrade: UpgradeContract
    timestamp: uint32
}

struct (0x00000001) RequestUpgrade {
    newUpgrade: UpgradeContract
}

struct (0x00000002) RejectUpgrade { }

struct (0x00000003) ApproveUpgrade { }

type AllowedMessages =
    | RequestUpgrade
    | RejectUpgrade
    | ApproveUpgrade

fun onInternalMessage(in: InMessage) {

    val msg = lazy AllowedMessages.fromSlice(in.body);

    match (msg) {

        RequestUpgrade => {
            var storage = lazy Storage.load();

            assert (in.senderAddress == storage.adminAddress) throw 100;
            assert (storage.CurrentRequest == null) throw 101;

            storage.CurrentRequest = {
                newUpgrade: msg.newUpgrade,
                timestamp: blockchain.now()
            };

            storage.save();
        }

        RejectUpgrade => {
            var storage = lazy Storage.load();

            assert (in.senderAddress == storage.adminAddress) throw 100;
            assert (storage.CurrentRequest != null) throw 201;

            storage.CurrentRequest = null;
            storage.save();
        }

        ApproveUpgrade => {
            var storage = lazy Storage.load();
            
            assert (in.senderAddress == storage.adminAddress) throw 100;
            assert (storage.CurrentRequest != null) throw 301;
            assert (storage.CurrentRequest!.timestamp + storage.timeout < blockchain.now()) throw 302;

            if (storage.CurrentRequest!.newUpgrade.code != null) {
                contract.setCodePostponed(storage.CurrentRequest!.newUpgrade.code!);
            }
            if (storage.CurrentRequest!.newUpgrade.data != null) {
                contract.setData(storage.CurrentRequest!.newUpgrade.data!);
            }
            storage.CurrentRequest = null;
            storage.save();
        }

        else => { 
            // just accept TON 
        }
    }
}

get fun currentRequest() {
    var storage = lazy Storage.load();
    return storage.CurrentRequest;
}

struct Storage {
    adminAddress: address,
    timeout: uint32,
    CurrentRequest: CurrentRequest?
}

fun Storage.load() {
    return Storage.fromCell(contract.getData());
}

fun Storage.save(self) {
    contract.setData(self.toCell());
}
```
