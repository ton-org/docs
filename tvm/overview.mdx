---
title: "Overview"
description: "TON Virtual Machine (TVM) is a stack-based virtual machine which executes smart contracts on TON blockchain"
---

import { Aside } from '/snippets/aside.jsx';

## Key properties

- No linear, addressable RAM and no raw pointers. Data lives in a tree of [Cells](./serialization/cells) with read/write cursors (Slice/Builder). Code is executed from bitcode inside [continuations](./continuations).
- Every instruction consumes [gas](./gas), paid by the smart contract when executed on‑chain. Gas exhaustion raises an exception and aborts effects.
- Deterministic execution: same inputs and prior state ⇒ same outputs on any [validator](/foundations/consensus).

## When TVM runs

TVM is invoked in three common scenarios:

1. On‑chain message handling by an account (contract):
   - External message (from outside the blockchain),
   - Internal message (from another on‑chain account).
     In both cases, execution happens on‑chain, gas is paid, and effects may modify persistent state and enqueue outbound actions/messages.

1. Off‑chain get‑methods:
   - Run outside the blockchain (locally by a node/client). Gas is free, but the state is read‑only: you cannot write persistent state and cannot produce real outbound messages. Get methods used as an API to access contract storage.

## TVM data types

Values you’ll see on the stack and inside registers:

- **Integer** — signed up to 257 bits (with a special `NaN` for arithmetic faults).
- **Cell** — piece of data: up to 1023 bits + up to 4 references to other Cells.
- **Slice** — read cursor over a Cell.
- **Builder** — write cursor to construct a new Cell.
- **Tuple** — list of up to 255 elements of arbitrary types.
- **Continuation** — executable Slice consisting of instructions bitcode; callable like a function.
- **Null** — empty value.

<Aside type="tip">The most important types: **Slice** (to read incoming messages and storage), **Builder** (to write outgoing messages and to update storage), **Cell** (store/transport).</Aside>

## TVM state

### Data Stack

LIFO stack; the vast majority of instructions pop operands from the top and push results back.

### Control registers

A small fixed set of special registers, denoted as `c0`, `c1`, ..., `c5`, and `c7` (`c6` does not exist). Most important are `c4` (account persistent storage) and `c7` (environment information and global variables).

<Aside type="note">Only `c4` (new state) and `c5` (final actions) represent durable effects of a successful on‑chain run. Everything else is transient.</Aside>

<Aside type="tip">For more info about registers, take a look at [TVM > Registers](./registers)</Aside>

### Current codepage (`cp`)

The current codepage determines how to decode the next instruction in `cc`. Different codepages may implement different instruction sets, allowing for adding new features to TVM without affecting old smart contracts. Currently, only codepage `0` (`cp0`) is implemented.

Smart contract runs [`SETCP0`](./instructions#ff-setcp) instruction to explicitly use codepage `0`.

### Current continuation (`cc`)

A special register that stores a list of the next instructions to execute. Similar to the instruction pointer in traditional architectures.

### Gas counter

Tracks remaining computation budget. Each instruction decrements gas; on zero/negative, an exception is raised, and the run aborts.

<Aside type="tip">Look at [TVM > Gas](./gas) for more info about gas usage</Aside>

## Example of a smart contract: counter

Here is a simple contract, written in Fift-ASM (TVM assembler). It accepts an internal message with a 32-bit number, checks that it is equal to the 32-bit number stored in `c4`, increments it, and saves it back to `c4`.

TVM stack initialized with values describing the event that occurred (e.g., receiving a message) and the current balance of the contract:

1. `s0` (top of stack) - function selector. It is the ID of a function to call. Transaction executor passes `0` when we received an internal message, `-1` in case of an external message, and `-2` in case of a tick-tock event. IDs greater than `0x10000` are for get methods.
1. `s1` - message body. This is an arbitrary payload of a message, which can be used for text comments (when sending TONs from one wallet to another) or for smart contract commands (that is our case).
1. `s2` - message cell. Cell containing message metadata (sender, receiver, amount) as well as message body.
1. `s3` - message value. Amount of TONs we received. Both the message body and value are provided for convenience, so we do not need to parse the message cell every time.
1. `s4` - contract balance.

<Aside type="tip">Look at [TVM > Initialization](./initialization) for more info about initial stack values</Aside>

In this contract, we will use only two top values (message body and function selector); the other three we will not take into account. After finishing execution, TVM silently drops all remaining values. In comments, we will represent stack values from the bottom to the top (e.g., `s2 s1 s0`, where s0 is the top of the stack) to understand the current stack layout.

```fift Fift
<{
    // initial stack: msg_body selector

    // use codepage 0 (just pick the single instruction set available now)
    // this instruction does not affect the stack
    SETCP0

    // consume `selector` from the top of the stack
    // stop execution if `selector != 0`
    IFRET
    // => continue execution if we received an internal message

    // current stack: msg_body

    // load (LD) unsigned (U) 32-bit integer from a slice
    // this instruction consumes a slice from the stack, pushes an integer, and then pushes a new slice
    32 LDU
    // current stack: msg_counter msg_body'
    // msg_body' is a slice whose read cursor was moved by 32 bits when we loaded a 32-bit integer
    // for example: if we had slice x{00000001} on the stack and then invoked 32 LDU, there will be integer `1` and `x{}` (empty slice) on the stack

    // assert the END of a slice (S)
    //these instructions consume a slice and check that it is empty (no more data to read)
    // otherwise it throws an exception, because there was more data than we expected
    ENDS
    // current stack: msg_counter

    // push c4 (persistent storage) on the stack, `storage` is a cell
    c4 PUSH
    // current stack: msg_counter storage

    // convert cell to a slice (make it readable)
    CTOS
    // current stack: msg_counter storage_slice

    // read 32-bit unsigned integer from the storage
    32 LDU
    // current stack: msg_counter storage_counter storage_slice'

    // assert there is no more data in the storage
    ENDS
    // current stack: msg_counter storage_counter

    // duplicate s0 (top of stack) under two top values
    TUCK
    // current stack: storage_counter msg_counter storage_counter

    // check counters are equal
    EQUAL
    // current stack: storage_counter msg_counter==storage_counter?

    // throw an exception with code 33 if it is not equal
    33 THROWIFNOT
    // current stack: storage_counter

    // increase counter
    INC
    // current stack: storage_counter+1

    // create an empty builder
    NEWC
    // current stack: storage_counter+1 builder

    // store (ST) unsigned (U) 32-bit integer `storage_counter+1` to a builder
    32 STU
    // current stack: builder'

    // finalize builder to a cell
    ENDC
    // current stack: new_storage

    // save `new_storage` to c4 (persistent storage)
    c4 POP
    // current stack: (no values)
}>
```
