---
title: "FunC types"
sidebarTitle: "Types"
noindex: "true"
---

import { Aside } from '/snippets/aside.jsx';

FunC includes built-in types forming the language’s core.

## Atomic types

- `int` is a 257-bit signed integer type. Overflow checks are enabled by default and trigger an exception if exceeded.

- `cell` is a [TVM cell type](/foundations/whitepapers/tvm#1-1-3-preliminary-list-of-value-types) used to store persistent data in TON Blockchain. Data is organized in a [bag of cells](/tvm/serialization/boc), with each cell containing up to 1023 bits of arbitrary data and up to four references to other cells.

- `slice` is a read-only view of a cell that allows sequential access to its data and references. A cell can be converted into a slice, extracting stored bits and references without modifying the original cell.

- `builder` is a mutable structure used to construct cells by adding data and references before finalizing them into a new cell.

- `tuple` is an ordered collection of up to 255 elements, each capable of holding a value of any type.

- `cont` is a TVM continuation used to manage execution flow in [TVM instructions](/tvm/instructions).

- `Null`  is a type with a single value, used to represent empty lists or the absence of a return value.

Each of these types occupies a single slot in the [TVM stack](/foundations/whitepapers/tvm#1-1-tvm-is-a-stack-machine).

### No boolean type

FunC does not have a boolean type.
Instead, booleans are represented as integers:

- `false` is `0`, `true` is `-1`, a 257-bit integer with all bits set to 1.
- Logical operations are performed using [bitwise operations](/languages/func/operators).
- In [conditional checks](/languages/func/statements#conditional-statements), any nonzero integer is treated as `true`.

### Null values

In FunC, the `null` value represents the absence of a value for a given atomic type.

Any atomic type can be `null`. Keep the following in mind when working with functions:

- Functions that return an atomic type may return `null`.
- Functions that expect an atomic type as input could also accept `null`.
- For [library functions](/languages/func/stdlib) specifications explicitly indicate when `null` is accepted as a valid input or output.

Example: [`cell_depth(cell c)`](/languages/func/stdlib#cell-depth) receives a `cell` as input, and its specification states that if the input cell is `null`, the function returns `0`.

## Hole type

FunC supports type inference. The hole types `_` and `var` serve as placeholders resolved during type checking: `_` is for functions, and `var` is for variables.

Example:

```func
var x = 2;
```

The type checker determines that `x` is of type `int` since `2` is an `int`.

As another example, in the following function declaration:

```func
_ someFunction(int a) {
  return a + 1;
}
```

the type checker infers that `_` has type `int`, as the return expression `a + 1` is of type `int`.

See [Function declarations](/languages/func/functions#function-declaration) for more details.

## Composite types

Types can be combined to form more complex structures.

### Functional type

A functional type is written in the form `A -> B`, where:

- `A` is the input type, which is called domain.
- `B` is the output type, which is called codomain.

**Example:**
The type `int -> cell` represents a function that:

- Takes an integer as input.
- Returns a cell as output.

Like in functional programming, it is possible to declare functional types which have in their domain and codomain other functional types.
For example, `(int -> int) -> int` is a function with domain `int -> int` and codomain `int`.
Similarly, `cell -> (slice -> slice)` is a function with domain `cell` and codomain `slice -> slice`

### Tuple type

Tuple types in FunC are written in the form `[A, B, ...]` and represent TVM tuples with fixed length and known component types at compile time. A tuple occupies one entry on the TVM stack, even if it is a zero-length tuple.

For example, `[int, cell]` defines a tuple with exactly two elements:

- The first element is an integer.
- The second element is a cell.

The type `[]` represents an empty tuple with a unique value—the empty tuple itself.

<Aside>
  Unlike the unit type `()`, an empty tuple `[]` occupies one stack entry.
</Aside>

### Tensor type

Tensor types represent collections of values with a fixed order and are written in the form `(A, B, ...)`.
These types occupy multiple TVM stack entries, unlike atomic types, which use a single entry.

**Example:**

A function `foo` of type `int -> (int, int)` takes one integer as input and returns a pair of integers as output.

Example call:

```func
(int a, int b) = foo(42);
```

Internally, the function consumes one stack entry and produces two.

**Type representation:**

Values `(2, (3, 9))` of type `(int, (int, int))` and `(2, 3, 9)` of type `(int, int, int)` are stored identically as three stack entries `(2, 3, and 9)`.
FunC treats them as distinct types.
The following code **will not compile**:

```func
(int a, int b, int c) = (2, (3, 9));
```

However, this code will compile correctly:

```func
(int a, (int b, int c)) = (2, (3, 9));
```

FunC enforces strict type consistency, so only matching tensor structures are allowed.

<Aside>
  Exception: a type of the form `(A)` is considered by the type checker as the same type as `A`.
</Aside>

**Special case: unit type`()`**

The unit type `()` is used to indicate that:

- A function does not return a value or
- A function takes no arguments

The unit type `()` has a single value, also written as `()`, occupying **zero stack** entries.

**Examples**

- `print_int` has the type `int -> ()`, meaning it takes an integer but returns nothing.
- `random` has the type `() -> int`, meaning it takes no arguments but returns an integer.

## Polymorphism with type variables

FunC supports [polymorphic functions](https://en.wikipedia.org/wiki/Polymorphism_\(computer_science\)).

Example:

```func
forall X -> (X, X) duplicate(X value) {
  return (value, value);
}
```

Here, `X` is a type variable that allows the function to operate on values of any type. Type variables are declared after `forall` and before of `->`.

The function receives a value of type `X`, and duplicates this value to return a value of type `(X, X)`.

For example,

- Calling `duplicate(6)` produces `(6, 6)`.
- Calling `duplicate([])` produces two copies of an empty tuple: `([], [])`.

<Aside>
  Type variables in polymorphic functions cannot be instantiated with tensor types.
  The only exception is a tensor of a single element `(a)`, where `a` is not a tensor type itself. The compiler treats `(a)`as equivalent to `a`.
</Aside>

For more details, see the [Polymorphism with forall](/languages/func/functions#polymorphism-with-forall) section.

## User-defined types

FunC does not support defining custom types beyond the type constructions described above.
