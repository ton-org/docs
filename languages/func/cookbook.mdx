---
title: "FunC cookbook"
sidebarTitle: "Cookbook"
noindex: "true"
---

import { Aside } from '/snippets/aside.jsx';

The FunC cookbook was created to consolidate all the knowledge and best practices from experienced FunC developers in one place. 
The goal is to make it easier for future developers to build smart contracts efficiently.

Unlike the rest of the official FunC documentation, this guide focuses on solving everyday challenges that FunC developers encounter 
during smart contract development.

## Statements

### How to use flags in if statements

To check whether an event is relevant, use a flag variable of type integer. 
The flag can either be `0`, representing `false`, or `-1`, representing `true`. 
See [absence of boolean type](./types#no-boolean-type).

When checking the flag in [if..else statements](./statements#if%E2%80%A6else-statement), it is unnecessary to use 
the [`==` operator](./operators#equality%2C-%3D%3D), since a `0` evaluates to `false`, and any nonzero value is 
considered to be `true` in `if..else` statements.

```func
int flag = 0;  ;; false

;; ...
;; ...

if (flag) {    ;; No need to use flag == -1 
    ;; do something
}
else {
    ;; reject
}
```

### How to write a repeat loop

A [repeat loop](./statements#repeat-loop) helps execute an action a fixed number of times. The example below computes 
exponentiation of `number` to the exponent `exponent`, and illustrates it with specific values `number = 2` and `exponent = 5`:

```func
int number = 2;
int exponent = 5;

int result = 1;      ;; Will store the final result: number^exponent

repeat(exponent) {   ;; The repeat multiplies variable "number", 
                     ;; exactly an "exponent" number of times
    result *= number;
}
;; result holds value 32 
```

### How to write a while loop

A [while loop](./statements#while-loop) is useful when the number of iterations is unknown. 
The following example processes the references in the `message` [`cell`](/tvm/serialization/cells).
Each cell can store up to four references to other cells:

```func
cell inner_cell = begin_cell() ;; Create a new empty builder
        .store_uint(123, 16) ;; Store uint with value 123 and length 16 bits
        .end_cell(); ;; Convert builder to a cell

;; Create a cell, which will have two references to inner_cell
cell message = begin_cell()
        .store_ref(inner_cell) ;; Store cell as reference
        .store_ref(inner_cell) ;; A second time
        .end_cell();

slice msg = message.begin_parse(); ;; Convert cell to slice
while (msg.slice_refs_empty?() != -1) { ;; Iterate while there are refs to process
                                        ;; Recall that -1 is true.
                                        
    cell inner_cell = msg~load_ref(); ;; Load cell from slice msg
    ;; do something
}
```

**References:**

- [Non-modifying notation using .](./expressions#non-modifying-notation)                                                                                                                                                                                                                                                                               
- [`begin_cell`](./stdlib#begin-cell)
- [`store_uint`](./stdlib#store-uint)
- [`end_cell`](./stdlib#end-cell)
- [`store_ref`](./stdlib#store-ref)
- [`begin_parse`](./stdlib#begin-parse)
- [`slice_refs_empty?`](./stdlib#slice-refs-empty%3F)
- [`load_ref`](./stdlib#load-ref)

### How to write a do until loop

Use a [`do..until` loop](./statements#until-loop) when the loop must execute at least once.

```func
int flag = 0;

do {
    ;; iterate this as long as "flag" is false (0).
    ;; It would execute at least once even if the flag 
    ;; were already true before entering the loop.
} until (flag == -1); ;; Stop when "flag" becomes -1
```

## Cells and slices 

### How to determine if a slice is empty

Before working with a `slice`, checking whether it contains any data is essential to ensure proper processing. 
The `slice_empty?` method can be used for this purpose. However, it returns `0` (`false`) if the slice contains at least one `bit` of data or one reference.

```func
;; Creating empty slice
slice empty_slice = "";   ;; compile-time built-in "" produces a slice with no bits
;; `slice_empty?()` returns `true` because the slice doesn't have any `bits` and `refs`.
empty_slice.slice_empty?();

;; Creating slice which contains bits only
slice slice_with_bits_only = "Hello, world!";  ;; compile-time built-in produces a slice
                                               ;; containing the ASCII binary code of the string
;; `slice_empty?()` returns `false` because the slice has bits.
slice_with_bits_only.slice_empty?();

;; Create an empty dummy cell for use later 
cell dummy_cell = begin_cell().end_cell();

;; Creating slice which contains refs only
slice slice_with_refs_only = begin_cell()
    .store_ref(dummy_cell)      ;; Add the dummy cell as a reference
    .end_cell()                 ;; this creates the cell
    .begin_parse();             ;; this creates a slice from the cell
;; `slice_empty?()` returns `false` because the slice has no references.
slice_with_refs_only.slice_empty?();

;; Creating slice which contains bits and refs
slice slice_with_bits_and_refs = begin_cell()
    .store_slice("Hello, world!")   ;; Add bits from the slice computed
                                    ;; using the compile-time built-in
    .store_ref(dummy_cell)          ;; Add the dummy cell as a reference
    .end_cell()
    .begin_parse();
;; `slice_empty?()` returns `false` because the slice has bits and references.
slice_with_bits_and_refs.slice_empty?();
```

**References:**

- [Non-modifying notation using .](./expressions#non-modifying-notation)
- [`"<ascii string>"` compile-time builtin](./literals#string-without-suffix), where `<ascii string>` is an ASCII string
- [`slice_empty?`](./stdlib#slice-empty%3F)
- [`begin_cell`](./stdlib#begin-cell)
- [`end_cell`](./stdlib#end-cell)
- [`store_ref`](./stdlib#store-ref)
- [`begin_parse`](./stdlib#begin-parse)
- [`store_slice`](./stdlib#store-slice)


### How to determine if slice is empty (no bits, but may have refs)

If only the presence of bits matters and the cell references in the slice can be ignored, use the `slice_data_empty?` function.

```func
;; Creating empty slice
slice empty_slice = "";   ;; compile-time built-in "" produces a slice with no bits
;; `slice_data_empty?()` returns `true` because the slice doesn't have any bits.
empty_slice.slice_data_empty?();

;; Creating slice which contains bits only
slice slice_with_bits_only = "Hello, world!";  ;; compile-time built-in produces a slice
                                               ;; containing the ASCII binary code of the string
;; `slice_data_empty?()` returns `false` because the slice has bits.
slice_with_bits_only.slice_data_empty?();

;; Create an empty dummy cell for use later 
cell dummy_cell = begin_cell().end_cell();

;; Creating slice which contains refs only
slice slice_with_refs_only = begin_cell()
    .store_ref(dummy_cell)      ;; Add the dummy cell as a reference
    .end_cell()                 ;; this creates the cell
    .begin_parse();             ;; this creates a slice from the cell
;; `slice_data_empty?()` returns `true` because the slice doesn't have any bits
slice_with_refs_only.slice_data_empty?();

;; Creating slice which contains bits and refs
slice slice_with_bits_and_refs = begin_cell()
    .store_slice("Hello, world!")   ;; Add bits from the slice computed
                                    ;; using the compile-time built-in
    .store_ref(dummy_cell)          ;; Add the dummy cell as a reference
    .end_cell()
    .begin_parse();
;; `slice_data_empty?()` returns `false` because the slice has bits.
slice_with_bits_and_refs.slice_data_empty?();
```

**References:**

- [Non-modifying notation using .](./expressions#non-modifying-notation)
- [`"<ascii string>"` compile-time builtin](./literals#string-without-suffix), where `<ascii string>` is an ASCII string.
- [`slice_data_empty?`](./stdlib#slice-data-empty%3F)
- [`begin_cell`](./stdlib#begin-cell)
- [`end_cell`](./stdlib#end-cell)
- [`store_ref`](./stdlib#store-ref)
- [`begin_parse`](./stdlib#begin-parse)
- [`store_slice`](./stdlib#store-slice)

### How to determine if slice is empty (no refs, but may have bits)

If only cell references are of interest, their presence can be checked using the `slice_refs_empty?` function.

```func
;; Creating empty slice
slice empty_slice = "";   ;; compile-time built-in "" produces a slice with no bits
;; `slice_refs_empty?()` returns `true` because the slice doesn't have any cell references.
empty_slice.slice_refs_empty?();

;; Creating slice which contains bits only
slice slice_with_bits_only = "Hello, world!";  ;; compile-time built-in produces a slice
                                               ;; containing the ASCII binary code of the string
;; `slice_refs_empty?()` returns `true` because the slice doesn't have any cell references.
slice_with_bits_only.slice_refs_empty?();

;; Create an empty dummy cell for use later 
cell dummy_cell = begin_cell().end_cell();

;; Creating slice which contains refs only
slice slice_with_refs_only = begin_cell()
    .store_ref(dummy_cell)      ;; Add the dummy cell as a reference
    .end_cell()                 ;; this creates the cell
    .begin_parse();             ;; this creates a slice from the cell
;; `slice_refs_empty?()` returns `false` because the slice has cell references.
slice_with_refs_only.slice_refs_empty?();

;; Creating slice which contains bits and refs
slice slice_with_bits_and_refs = begin_cell()
    .store_slice("Hello, world!")   ;; Add bits from the slice computed
                                    ;; using the compile-time built-in
    .store_ref(dummy_cell)          ;; Add the dummy cell as a reference
    .end_cell()
    .begin_parse();
;; `slice_refs_empty?()` returns `false` because the slice has cell references.
slice_with_bits_and_refs.slice_refs_empty?();
```

**References:**

- [Non-modifying notation using .](./expressions#non-modifying-notation)
- [`"<ascii string>"` compile-time builtin](./literals#string-without-suffix), where `<ascii string>` is an ASCII string.
- [`slice_refs_empty?`](./stdlib#slice-refs-empty%3F)
- [`begin_cell`](./stdlib#begin-cell)
- [`end_cell`](./stdlib#end-cell)
- [`store_ref`](./stdlib#store-ref)
- [`begin_parse`](./stdlib#begin-parse)
- [`store_slice`](./stdlib#store-slice)

### How to determine if a cell is empty

To check whether a cell contains any data, it must first be converted into a slice.

- If only the data bits matter, use `slice_data_empty?`.
- If only cell references matter, use `slice_refs_empty?`.
- If the presence of any data (bits or cell references) needs to be checked, use `slice_empty?`.

```func
;; Create an empty dummy cell for use later 
cell dummy_cell = begin_cell().end_cell();

cell cell_with_bits_and_refs = begin_cell()
    .store_uint(1337, 16)
    .store_ref(dummy_cell)
    .end_cell();

;; To check that cell_with_bits_and_refs is empty,
;; first obtain a slice
slice cs = cell_with_bits_and_refs.begin_parse();

;; Determine if the slice is empty.
if (cs.slice_empty?()) {
    ;; Cell is empty
}
else {
    ;; Cell is not empty
}
```

**References:**

- [Non-modifying notation using .](./expressions#non-modifying-notation)
- [`begin_cell`](./stdlib#begin-cell)
- [`end_cell`](./stdlib#end-cell)
- [`store_ref`](./stdlib#store-ref)
- [`begin_parse`](./stdlib#begin-parse)
- [`slice_empty?`](./stdlib#slice-empty%3F)
- [`slice_data_empty?`](./stdlib#slice-data-empty%3F)
- [`slice_refs_empty?`](./stdlib#slice-refs-empty%3F)

### Determine if the data bits of slices are equal

There are three ways to check if the data bits of two slices are equal:

1. Comparing their hashes.
2. Using the SDEQ asm instruction.
3. Using the `equal_slice_bits` function.

```func
int are_slices_equal_1? (slice a, slice b) {
    return a.slice_hash() == b.slice_hash();
}

int are_slices_equal_2? (slice a, slice b) asm "SDEQ";

int are_slices_equal_3? (slice a, slice b) {
    return equal_slice_bits(a, b);
}

() main () {
    slice s1 = "Some text";    ;; load a slice with the ASCII code of the string
    slice s2 = "Some text";
    ~dump(are_slices_equal_1?(s1, s2));  ;; -1 = true
    ~dump(are_slices_equal_2?(s1, s2));  ;; -1 = true
    ~dump(are_slices_equal_3?(s1, s2));  ;; -1 = true

    s1 = "Text";
    ;; load a slice with the address encoded in the provided string
    s2 = "EQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPrHF"a;
    ~dump(are_slices_equal_1?(s1, s2));  ;; 0 = false
    ~dump(are_slices_equal_2?(s1, s2));  ;; 0 = false
    ~dump(are_slices_equal_3?(s1, s2));  ;; 0 = false
}
```

<Aside type="danger">
    Ways 2 and 3 only check the data bits of the two slices, but way 1 **also** takes into account the cell references in the slices.
    This means that if the two slices have the same data bits but different cell references, way 1 will answer `0` (`false`), but way 2 and 3 will answer `-1` (`true`). 
    For example, the following two slices have the same data bits, but different cell references. 
    Comparing their hashes would return `0` (`false`), but comparing them using `SDEQ` or `equal_slice_bits` would return `-1` (`true`).

    ```func 
    ;; Create a dummy cell to add as a reference later
    cell dummy = begin_cell().end_cell();

    slice s1 = begin_cell()
               .store_slice("Some text")  ;; Add the slice data bits
               .store_ref(dummy)          ;; Add a dummy reference
               .end_cell()
               .begin_parse();            ;; Transform the cell to slice

    slice s2 = "Some text";      ;; This slice contains only data bits

    ~dump(are_slices_equal_1?(s1, s2));  ;; 0 = false
    ~dump(are_slices_equal_2?(s1, s2));  ;; -1 = true
    ~dump(are_slices_equal_3?(s1, s2));  ;; -1 = true
    ```
</Aside>

**References:**

- [Non-modifying notation using .](./expressions#non-modifying-notation)
- [`"<ascii string>"` compile-time builtin](./literals#string-without-suffix), where `<ascii string>` is an ASCII string.
- [`"<address string>"a` compile-time builtin](./literals#string-with-suffix-a), where `<address string>` is a string encoding an address.
- [`slice_hash`](./stdlib#slice-hash)
- [`SDEQ` asm instruction](/tvm/instructions#c705-sdeq)
- `equal_slice_bits`


### Determine if the cells are equal

We can determine if two cells are equal by comparing their hashes.

```func
int are_cells_equal? (cell a, cell b) {
    return a.cell_hash() == b.cell_hash();
}

() main () {
    cell a = begin_cell()
            .store_uint(123, 16)
            .end_cell();

    cell b = begin_cell()
            .store_uint(123, 16)
            .end_cell();

    ~dump(are_cells_equal?(a, b));   ;; -1 = true

    cell dummy_cell = begin_cell().end_parse();

    cell c = begin_cell()     ;; Like cell a, but it has an extra reference 
            .store_uint(123, 16)
            .store_ref(dummy_cell)     
            .end_cell();

    ~dump(are_cells_equal?(a, c));   ;; 0 = false
}
```

**References:** 

- [Non-modifying notation using .](./expressions#non-modifying-notation)
- [`cell_hash`](./stdlib#cell-hash)
- [`begin_cell`](./stdlib#begin-cell)
- [`end_cell`](./stdlib#end-cell)
- [`store_uint`](./stdlib#store-uint)
- [`store_ref`](./stdlib#store-ref)

### How to get only the data bits from a slice

If the cell references within a slice are unnecessary, the raw data bits can be extracted for further processing
using the function `preload_bits`: 

```func
;; Define a slice with data bits and two cell references
slice s = begin_cell()
    .store_slice("Some data bits...")
    .store_ref(begin_cell().end_cell()) ;; some reference
    .store_ref(begin_cell().end_cell()) ;; some reference
    .end_cell()
    .begin_parse();

;; Exttract the data bits as a new slice
slice s_only_data = s.preload_bits(s.slice_bits());
```

Function `preload_bits` needs the amount of bits to extract given as argument. We extract the amount of bits 
of the slice with `s.slice_bits()`. 

**References:**

- [Non-modifying notation using .](./expressions#non-modifying-notation)
- [Builder primitives](./stdlib/#builder-primitives)
- [Slice primitives](./stdlib/#slice-primitives)
- [`preload_bits`](./stdlib/#preload-bits)
- [`slice_bits`](./stdlib/#slice-bits)

### How to iterate a cell tree recursively

Each cell can store up to `1023` bits of data and `4` cell references. 
A tree of cells can be used to handle more complex data structures, requiring recursive iteration.

```func
forall X -> int is_null (X x) asm "ISNULL";
forall X -> (tuple, ()) push_back (tuple tail, X head) asm "CONS";
forall X -> (tuple, (X)) pop_back (tuple t) asm "UNCONS";

() main () {
    ;; just some cell for example
    cell c = begin_cell()
        .store_uint(1, 16)
        .store_ref(begin_cell()
            .store_uint(2, 16)
        .end_cell())
        .store_ref(begin_cell()
            .store_uint(3, 16)
            .store_ref(begin_cell()
                .store_uint(4, 16)
            .end_cell())
            .store_ref(begin_cell()
                .store_uint(5, 16)
            .end_cell())
        .end_cell())
    .end_cell();

    ;; creating tuple with no data, which plays the role of stack
    tuple stack = null();
    ;; bring the main cell into the stack to process it in the loop
    stack~push_back(c);
    ;; do it until stack is not null
    while (~ stack.is_null()) {
        ;; get the cell from the stack and convert it to a slice to be able to process it
        slice s = stack~pop_back().begin_parse();

        ;; do something with s data

        ;; if the current slice has any refs, add them to stack
        repeat (s.slice_refs()) {
            stack~push_back(s~load_ref());
        }
    }
}
```

**References:**

- [`Lisp-style lists`](./stdlib/#lisp-style-lists)
- [`null`](./stdlib/#null)
- [`slice_refs`](./stdlib/#slice-refs)

### How to build a `StateInit` cell

The code follows the TL-B for `StateInit`:

```
_ split_depth:(Maybe (## 5)) special:(Maybe TickTock)
  code:(Maybe ^Cell) data:(Maybe ^Cell)
  library:(HashmapE 256 SimpleLib) = StateInit;
```

which states that `code` and `data` should be added as cell references.
Fields `split_depth` and `special` are usually set to `None` (i.e., `0`)
in standard programming tasks. The `library` field usually set to `0` as well.
See more details for the fields in the `StateInit` TL-B in its article. 

```func
() build_stateinit(cell init_code, cell init_data) {
  var state_init = begin_cell()
    .store_uint(0, 1) ;; split_depth: Maybe (## 5), set to "None"
    .store_uint(0, 1) ;; special: Maybe TickTock, set to "None"
    .store_uint(1, 1) ;; code: Maybe ^Cell, set to "Some cell", 
                      ;; but the cell is provided later as a reference 
    .store_uint(1, 1) ;; data: Maybe ^Cell, set to "Some cell",
                      ;; but the cell is provided later as a reference 
    .store_uint(0, 1) ;; library: HashmapE 256 SimpleLib, set to 0
    .store_ref(init_code)  ;; the code as a cell reference
    .store_ref(init_data)  ;; the data as a cell reference
    .end_cell();
}
```

**References:**

- [Non-modifying notation using .](./expressions#non-modifying-notation)
- TL-B for StateInit
- [Builder primitives](./stdlib/#builder-primitives)

## Data structures

### How to determine if a dict is empty

The `dict_empty?` function checks whether a dictionary contains any data. 
This method is functionally equivalent to `cell_null?`, as a `null` cell typically represents an empty dictionary.

```func
cell d = new_dict();    ;; Create an empty dictionary

;; Set value of key 0 to be a slice containing the ASCII string "hello" 
d~udict_set(256, 0, "hello");
;; Set value of key 1 to be a slice containing the ASCII string "world" 
d~udict_set(256, 1, "world");

if (d.dict_empty?()) { ;; Determine if the dict is empty
    ;; dict is empty
}
else {
    ;; dict is not empty.
    ;; For dictionary d, execution flow will enter this
    ;; branch, since d has two elements.
}
```

In `d~udict_set(256, 0, "hello")`, the function expects unsigned 256-bit integers as keys; also,
`d~udict_set(256, 0, "hello")` will mutate the dictionary `d`, since `udict_set` is called using 
[modifying notation with the symbol `~`](./expressions#modifying-notation).

**References:**

- [Non-modifying notation using .](./expressions#non-modifying-notation)
- [Modifying notation using ~](./expressions#modifying-notation)
- [`"<ascii string>"` compile-time builtin](./literals#string-without-suffix), where `<ascii string>` is an ASCII string.
- [`new_dict`](./stdlib/#new-dict)
- [`dict_set` primitives](./stdlib/#dict-set)
- [`dict_empty?`](./stdlib#dict-empty%3F)

### How to store and load a dictionary in permanent storage

The logic for loading a dictionary from local storage is as follows:

```func
;; Obtain the contract's local persistent storage
slice local_storage = get_data().begin_parse();

;; This initial assignment ensures that if the condition below 
;; fails to find a dictionary already in local storage, 
;; `dictionary_cell` will remain with a new empty dictionary.
cell dictionary_cell = new_dict();

if (~ slice_empty?(local_storage)) {
    ;; A dictionary is already in local storage, load it
    dictionary_cell = local_storage~load_dict();
}
```

Storing the dictionary in local storage is also simple:

```func
set_data(begin_cell().store_dict(dictionary_cell).end_cell());
```

**References:**

- [Non-modifying notation using .](./expressions#non-modifying-notation)
- [Modifying notation using ~](./expressions#modifying-notation)
- [Slice primitives](./stdlib/#slice-primitives)
- [`get_data`](./stdlib/#get-data)
- [`set_data`](./stdlib/#set-data)
- [Builder primitives](./stdlib/#builder-primitives)
- [`new_dict`](./stdlib/#new-dict)
- [`slice_empty?`](./stdlib/#slice-empty%3F)
- [`load_dict`](./stdlib/#load-dict)


### How to iterate dictionaries

To iterate a dictionary from the smallest to biggest key, first call a [`dict_get_min?` primitive](./stdlib/#dict-get-min%3F) to obtain the smallest key in the dictionary,
and then call a [`dict_get_next?` primitive](./stdlib/#dict-get-next%3F) inside a loop while checking a flag for existence of further key-value pairs to process.

Similarly, to iterate a dictionary from the biggest to smallest key, first call a [`dict_get_max?` primitive](./stdlib/#dict-get-max%3F) to obtain the biggest key in the dictionary,
and then call a [`dict_get_prev?` primitive](./stdlib/#dict-get-prev%3F) inside a loop while checking a flag for existence of further key-value pairs to process.

```func
;; Initialize an example dictionary.
;; keys will be unsigned 256-bit integers. Values are slices.
;; Since keys are unsigned, 
;; we should use 'unsigned' versions of the 
;; dict_set, dict_get_min?, dict_get_max?, 
;; dict_get_next?, and dict_get_prev? primitives.
cell d = new_dict();
d~udict_set(256, 1, "value 1");   ;; Map key 1 to a slice containing string "value 1"
d~udict_set(256, 5, "value 2");   ;; Map key 5 to a slice containing string "value 2"
d~udict_set(256, 12, "value 3");  ;; Map key 12 to a slice containing string "value 3"

;; First, we iterate from smallest to biggest key:

;; Obtain the smallest key.
(int key, slice val, int flag) = d.udict_get_min?(256);   

;; Repeat while there are keys to iterate, indicated by "flag".
while (flag) {  
    ;; do something with "key" and "val".

    ;; Obtain the smallest key bigger than "key".
    ;; i.e., the one next to "key" in numerical value.
    ;; "flag" will indicate if such key exists.
    (key, val, flag) = d.udict_get_next?(256, key);
}

;; Now, we iterate from biggest to smallest key:

;; Obtain the biggest key.
(key, val, flag) = d.udict_get_max?(256);   

;; Repeat while there are keys to iterate, indicated by "flag".
while (flag) {  
    ;; do something with "key" and "val".

    ;; Obtain the biggest key smaller than "key",
    ;; i.e., the one previous to "key" in numerical value.
    ;; "flag" will indicate if there is a previous key.
    (key, val, flag) = d.udict_get_prev?(256, key);
}
```

**References:**

- [Non-modifying notation using .](./expressions#non-modifying-notation)
- [Modifying notation using ~](./expressions#modifying-notation)
- [`"<ascii string>"` compile-time builtin](./literals#string-without-suffix), where `<ascii string>` is an ASCII string.
- [`new_dict`](./stdlib/#new-dict)
- [`dict_set` primitives](./stdlib/#dict-set)
- [`dict_get_min?` primitives](./stdlib/#dict-get-min%3F)
- [`dict_get_max?` primitives](./stdlib/#dict-get-max%3F)
- [`dict_get_next?` primitives](./stdlib/#dict-get-next%3F)
- [`dict_get_prev?` primitives](./stdlib/#dict-get-prev%3F)

### How to delete a value from a dictionary

Use the [`dict_delete?` primitives](./stdlib/#dict-delete%3F) to delete keys in a dictionary.

```func
;; Initialize an example dictionary.
;; keys will be unsigned 256-bit integers. Values are slices.
;; Since keys are unsigned, 
;; we should use 'unsigned' versions of the 
;; dict_set, dict_delete?, dict_get? primitives.
cell names = new_dict();
names~udict_set(256, 27, "Alice");  ;; Map key 27 to a slice containing string "Alice"
names~udict_set(256, 25, "Bob");

;; Delete key-value pair with key 27
;; This mutates "names" dictionary, because 
;; udict_delete? is called using ~
names~udict_delete?(256, 27);   

;; Look up the key 27
;; since it was deleted, the "found" flag returns 0 
(slice val, int found) = names.udict_get?(256, 27);
~dump(found);   ;; 0, means that key was not found in the dictionary
```

**References:**

- [`"<ascii string>"` compile-time builtin](./literals#string-without-suffix), where `<ascii string>` is an ASCII string.
- [Non-modifying notation using .](./expressions#non-modifying-notation)
- [Modifying notation using ~](./expressions#modifying-notation)
- [`new_dict`](./stdlib/#new-dict)
- [`dict_set` primitives](./stdlib/#dict-set)
- [`dict_delete?` primitives](./stdlib/#dict-delete%3F)
- [`dict_get?` primitives](./stdlib/#dict-get%3F)

### How to determine if a tuple is empty

When working with `tuples`, checking for existing values before extracting them is crucial. 
Extracting a value from an empty tuple will result in an error: ["not a tuple of valid size" - `exit code 7`](/tvm/exit-codes#7).

```func
;; Declare the tlen assembler function because it's not present in stdlib
;; tlen determines the length of a tuple
int tlen (tuple t) asm "TLEN";

() main () {
    tuple t = empty_tuple();  ;; t is []
    t~tpush(13);              ;; t is [13]
    t~tpush(37);              ;; t is [13, 37]

    if (t.tlen() == 0) {   ;; Evaluates to false
        ;; tuple is empty
    }
    else {
        ;; tuple is not empty
    }
}
```

The `tlen` assembler function uses the [TVM instruction `TLEN`](/tvm/instructions#6f88-tlen) to determine the number of elements in the tuple. 
The `tpush` function appends an element to the tuple, so that it becomes the last element.

**References:**

- [Non-modifying notation using .](./expressions#non-modifying-notation)
- [Modifying notation using ~](./expressions#modifying-notation)
- Assembler functions
- [`empty_tuple`](./stdlib#empty-tuple)
- [`tpush`](./stdlib/#tpush)
- [TVM Exit codes](/tvm/exit-codes)
- [TVM instructions](/tvm/instructions)

### Basic operations with tuples

```func
;; tlen determines the length of a tuple
int tlen (tuple t) asm "TLEN";

;; tpop removes the last element in the tuple and 
;; returns the mutated tuple and the element.
;; The type of the returned element is arbitrary.
forall X -> (tuple, X) ~tpop (tuple t) asm "TPOP";

() main () {
    ;; creating an empty tuple
    tuple names = empty_tuple();

    ;; push new items
    ;; Each element is a slice storing an ASCII string
    names~tpush("Naito");
    names~tpush("Shiraki");
    names~tpush("Akamatsu");
    names~tpush("Takaki");

    ;; names is ["Naito", "Shiraki", "Akamatsu", "Takaki"]

    ;; pop last item, "Takaki"
    slice last_name = names~tpop();

    ;; get first item, "Naito"
    slice first_name = names.first();

    ;; get an item by index, "Akamatsu"
    ;; First element has index 0
    slice best_name = names.at(2);

    ;; getting the length of the tuple
    ;; returns 3, because "Takaki" was popped
    int number_names = names.tlen();
}
```

The `tlen` assembler function uses the [TVM instruction `TLEN`](/tvm/instructions#6f88-tlen) to determine the number of elements in the tuple.

The `tpop` assembler function uses the [TVM instruction `TPOP`](/tvm/instructions#6f8d-tpop) to detach the last element from the tuple, and 
it returns the mutated tuple and the detached element.

**References:**

- [Non-modifying notation using .](./expressions#non-modifying-notation)
- [Modifying notation using ~](./expressions#modifying-notation)
- Assembler functions
- Polymorphic functions
- [`empty_tuple`](./stdlib#empty-tuple)
- [`tpush`](./stdlib/#tpush)
- [`first`](./stdlib/#first)
- [`at`](./built-ins/#at)
- [TVM instructions](/tvm/instructions)

### How to iterate tuples (both directions)

When working with arrays or stacks in FunC, tuples are essential. The first step is learning how to iterate through tuple values for processing.

```func
;; tlen determines the length of a tuple
int tlen (tuple t) asm "TLEN";

;; Casts any type into a tuple
forall X -> tuple to_tuple (X x) asm "NOP";

() main () {
    ;; Cast the fixed length tuple to an arbitrary length tuple.
    ;; This is necessary, because in FunC, fixed-length tuples 
    ;; like [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] cannot be assigned
    ;; directly to arbitrary length tuples.
    ;; Hence, this does NOT compile:
    ;; tuple t = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    tuple t = to_tuple([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
    int len = t.tlen();   ;; 10

    ;; Iterate tuple starting from index 0  
    ;; up to index 9

    int i = 0;
    while (i < len) {
        int x = t.at(i);    ;; Obtain the i-th element 
        ;; do something with x
        i = i + 1;
    }

    ;; Iterate tuple starting from index 9  
    ;; down to index 0

    i = len - 1;   ;; 9
    while (i >= 0) {
        int x = t.at(i);    ;; Obtain the i-th element 
        ;; do something with x
        i = i - 1;
    }
}
```

The `tlen` assembler function uses the [TVM instruction `TLEN`](/tvm/instructions#6f88-tlen) to determine the number of elements in the tuple.

The `to_tuple` casts **any** type into an arbitrary length tuple, which leads to run-time errors if `to_tuple` is used to cast non-tuple types. 
Be careful to only cast fixed-length tuples, like `[1, 2]`. The `to_tuple` is essentially a dummy function that does nothing,
because it uses the [No operation `NOP`](/tvm/instructions#00-nop) instruction. The only purpose of `to_tuple` is to tell the type-checker
to accept the input to `to_tuple` as a `tuple`.

**References:**

- [Non-modifying notation using .](./expressions#non-modifying-notation)
- Assembler functions
- Polymorphic functions
- [`at`](./built-ins/#at)
- [TVM instructions](/tvm/instructions)

### Iterating n-nested tuples

Sometimes, we need to iterate through nested tuples. 
The following example iterates through a tuple starting from the last index,
and finds the biggest number, irrespective if there are nested tuples.

For example, in the tuple `[[2,6],[1,[3,[3,5]]], 3]`, the example finds `6` as the biggest number.

```func
;; Determines the number of elements in a tuple.
int tuple_length (tuple t) asm "TLEN";

;; Removes the last element in the tuple and 
;; returns the mutated tuple and the element.
;; The type of the returned element is arbitrary.
forall X -> (tuple, X) ~tpop (tuple t) asm "TPOP";

;; Checks if the given argument is a tuple
forall X -> int is_tuple (X x) asm "ISTUPLE";

;; Casts the given argument to an arbitrary length tuple.
forall X -> tuple to_tuple (X x) asm "NOP";

;; Casts the given argument to an int.
forall X -> int to_int (X x) asm "NOP";

;; Define a global variable.
;; It will store the biggest number found.
global int max_value;

() iterate_tuple (tuple t) impure {
    repeat (t.tuple_length()) {
        ;; Remove the last element in the tuple.
        var value = t~tpop();    
        if (is_tuple(value)) {
            ;; If the element is a tuple, cast it to a tuple.
            tuple tuple_value = to_tuple(value);
            ;; And then, recursively iterate the element.
            iterate_tuple(tuple_value);
        } else {
            ;; The element is not a tuple, so it must be an int.
            ;; Cast it to an int.
            int int_value = to_int(value);
            if (int_value > max_value) {
                ;; Remember the value in the global variable 
                ;; because it is the biggest so far.
                max_value = int_value;
            }
        }
    }
}

() main () {
    ;; Create an example tuple
    tuple t = to_tuple([[2,6], [1, [3, [3, 5]]], 3]);

    ;; Determine the length of the tuple
    int len = t.tuple_length();

    ;; Set the maximum so far to 0
    max_value = 0; 

    ;; Find the maximum value in the tuple
    iterate_tuple(t);

    ~dump(max_value);    ;; 6
}
```

The `tuple_length` assembler function uses the [TVM instruction `TLEN`](/tvm/instructions#6f88-tlen) to determine the number of elements in the tuple.

The `tpop` assembler function uses the [TVM instruction `TPOP`](/tvm/instructions#6f8d-tpop) to detach the last element from the tuple, and 
it returns the mutated tuple and the detached element.

The `is_tuple` assembler function uses the [TVM instruction `ISTUPLE`](/tvm/instructions#6f8a-istuple) to determine if the argument is a tuple or not.

The `to_tuple` and `to_int` cast **any** type into an arbitrary length tuple and integer, respectively. This leads to run-time errors if 
`to_tuple` and `to_int` are used to cast non-tuple and non-integer types, respectively. The `to_tuple` and `to_int` are essentially dummy functions that do nothing,
because they use the [No operation `NOP`](/tvm/instructions#00-nop) instruction. The only purpose of `to_tuple` and `to_int` is to tell the type-checker
to accept the input to `to_tuple` as a `tuple`, and the input to `to_int` as an `int`.

**References:**

- [Non-modifying notation using .](./expressions#non-modifying-notation)
- [Modifying notation using ~](./expressions#modifying-notation)
- Assembler functions
- Polymorphic functions
- [Global Variables](./global-variables)
- [TVM instructions](/tvm/instructions)


### Casting types in tuples

If a tuple contains various data types X (cell, slice, int, tuple, etc.), we may need to check the value and cast it accordingly before processing.

```func
forall X -> int is_null (X x) asm "ISNULL";
forall X -> int is_int (X x) asm "<{ TRY:<{ 0 PUSHINT ADD DROP -1 PUSHINT }>CATCH<{ 2DROP 0 PUSHINT }> }>CONT 1 1 CALLXARGS";
forall X -> int is_cell (X x) asm "<{ TRY:<{ CTOS DROP -1 PUSHINT }>CATCH<{ 2DROP 0 PUSHINT }> }>CONT 1 1 CALLXARGS";
forall X -> int is_slice (X x) asm "<{ TRY:<{ SBITS DROP -1 PUSHINT }>CATCH<{ 2DROP 0 PUSHINT }> }>CONT 1 1 CALLXARGS";
forall X -> int is_tuple (X x) asm "ISTUPLE";
forall X -> int cast_to_int (X x) asm "NOP";
forall X -> cell cast_to_cell (X x) asm "NOP";
forall X -> slice cast_to_slice (X x) asm "NOP";
forall X -> tuple cast_to_tuple (X x) asm "NOP";
forall X -> (tuple, X) ~tpop (tuple t) asm "TPOP";

forall X -> () resolve_type (X value) impure {
    ;; Value here is of type X, since we dont know what is the exact value - we would need to check what is the value and then cast it

    if (is_null(value)) {
        ;; do something with the null
    }
    elseif (is_int(value)) {
        int valueAsInt = cast_to_int(value);
        ;; do something with the int
    }
    elseif (is_slice(value)) {
        slice valueAsSlice = cast_to_slice(value);
        ;; do something with the slice
    }
    elseif (is_cell(value)) {
        cell valueAsCell = cast_to_cell(value);
        ;; do something with the cell
    }
    elseif (is_tuple(value)) {
        tuple valueAsTuple = cast_to_tuple(value);
        ;; do something with the tuple
    }
}

() main () {
    ;; creating an empty tuple
    tuple stack = empty_tuple();
    ;; let's say we have tuple and do not know the exact types of them
    stack~tpush("Some text");
    stack~tpush(4);
    ;; we use var because we do not know type of value
    var value = stack~tpop();
    resolve_type(value);
}
```

**Reference:** [`TVM instructions`](/tvm/instructions)

### Reversing tuples

The following example reverses any tuple. For example, given the input `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`,
the `reverse_tuple` produces the output `[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]`.

```func
;; Determines the number of elements in a tuple.
int tuple_length (tuple t) asm "TLEN";

;; Removes the last element in the tuple and 
;; returns the mutated tuple and the element.
;; The type of the returned element is arbitrary.
forall X -> (tuple, X) ~tpop (tuple t) asm "TPOP";

;; Casts the given argument to an arbitrary length tuple.
forall X -> tuple to_tuple (X x) asm "NOP";

tuple reverse_tuple (tuple t1) {
    ;; Create an initially empty tuple.
    ;; This variable will be the accumulated result.
    tuple t2 = empty_tuple();

    repeat (t1.tuple_length()) {
        ;; Take the last element in the original tuple.
        var value = t1~tpop();  
        ;; And append it to the new tuple.
        t2~tpush(value);
    }
    return t2;
}

() main () {
    ;; Create an example tuple.
    tuple t = to_tuple([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

    ;; Reverse the tuple.
    tuple reversed_t = reverse_tuple(t);

    ~dump(reversed_t); ;; [10 9 8 7 6 5 4 3 2 1]
}
```

The `tuple_length` assembler function uses the [TVM instruction `TLEN`](/tvm/instructions#6f88-tlen) to determine the number of elements in the tuple.

The `tpop` assembler function uses the [TVM instruction `TPOP`](/tvm/instructions#6f8d-tpop) to detach the last element from the tuple, and 
it returns the mutated tuple and the detached element.

The `to_tuple` casts **any** type into an arbitrary length tuple, which leads to run-time errors if `to_tuple` is used to cast non-tuple types. 
The `to_tuple` is essentially a dummy function that does nothing,
because it uses the [No operation `NOP`](/tvm/instructions#00-nop) instruction. The only purpose of `to_tuple` is to tell the type-checker
to accept the input to `to_tuple` as a `tuple`.

**References:** 

- [Non-modifying notation using .](./expressions#non-modifying-notation)
- [Modifying notation using ~](./expressions#modifying-notation)
- Assembler functions
- Polymorphic functions
- [`empty_tuple`](./stdlib#empty-tuple)
- [`tpush`](./stdlib/#tpush)
- [TVM instructions](/tvm/instructions)

### How to remove an item with a certain index from a tuple

```func
;; Determines the number of elements in a tuple.
int tlen (tuple t) asm "TLEN";

(tuple, ()) remove_item (tuple old_tuple, int place) {

    ;; The result tuple so far. Initially it is empty.
    tuple new_tuple = empty_tuple();

    int i = 0;
    while (i < old_tuple.tlen()) {
        int el = old_tuple.at(i);
        ;; When we reach the place to delete, we skip
        ;; that element by not pushing it to the result tuple.
        if (i != place) {
            ;; Since the current index i is not equal to 
            ;; the place to delete, push the element to 
            ;; the end of the result tuple.
            new_tuple~tpush(el);
        }
        i += 1;
    }
    return (new_tuple, ());
}

() main () {
    ;; Create an example tuple, intially empty
    tuple numbers = empty_tuple();

    ;; Insert some integers to the tuple
    numbers~tpush(19);
    numbers~tpush(999);
    numbers~tpush(54);

    ~dump(numbers);   ;; [19 999 54]

    numbers~remove_item(1);

    ~dump(numbers); ;; [19 54]
}
```

The `tlen` assembler function uses the [TVM instruction `TLEN`](/tvm/instructions#6f88-tlen) to determine the number of elements in the tuple.

**References:** 

- [Non-modifying notation using .](./expressions#non-modifying-notation)
- [Modifying notation using ~](./expressions#modifying-notation)
- Assembler functions
- [`empty_tuple`](./stdlib#empty-tuple)
- [`at`](./built-ins/#at)
- [`tpush`](./stdlib/#tpush)
- [TVM instructions](/tvm/instructions)

### Determine if tuples are equal

A more advanced approach involves iterating through tuples and comparing each value recursively. Since tuples can contain different data types, we must check and cast values dynamically.

```func
int tuple_length (tuple t) asm "TLEN";
forall X -> (tuple, X) ~tpop (tuple t) asm "TPOP";
forall X -> int cast_to_int (X x) asm "NOP";
forall X -> cell cast_to_cell (X x) asm "NOP";
forall X -> slice cast_to_slice (X x) asm "NOP";
forall X -> tuple cast_to_tuple (X x) asm "NOP";
forall X -> int is_null (X x) asm "ISNULL";
forall X -> int is_int (X x) asm "<{ TRY:<{ 0 PUSHINT ADD DROP -1 PUSHINT }>CATCH<{ 2DROP 0 PUSHINT }> }>CONT 1 1 CALLXARGS";
forall X -> int is_cell (X x) asm "<{ TRY:<{ CTOS DROP -1 PUSHINT }>CATCH<{ 2DROP 0 PUSHINT }> }>CONT 1 1 CALLXARGS";
forall X -> int is_slice (X x) asm "<{ TRY:<{ SBITS DROP -1 PUSHINT }>CATCH<{ 2DROP 0 PUSHINT }> }>CONT 1 1 CALLXARGS";
forall X -> int is_tuple (X x) asm "ISTUPLE";
int are_slices_equal? (slice a, slice b) asm "SDEQ";

int are_cells_equal? (cell a, cell b) {
    return a.cell_hash() == b.cell_hash();
}

(int) are_tuples_equal? (tuple t1, tuple t2) {
    int equal? = -1; ;; initial value to true

    if (t1.tuple_length() != t2.tuple_length()) {
        ;; if tuples are differ in length they cannot be equal
        return 0;
    }

    int i = t1.tuple_length();

    while (i > 0 & equal?) {
        var v1 = t1~tpop();
        var v2 = t2~tpop();

        if (is_null(v1) & is_null(v2)) {
            ;; nulls are always equal
        }
        elseif (is_int(v1) & is_int(v2)) {
            if (cast_to_int(v1) != cast_to_int(v2)) {
                equal? = 0;
            }
        }
        elseif (is_slice(v1) & is_slice(v2)) {
            if (~ are_slices_equal?(cast_to_slice(v1), cast_to_slice(v2))) {
                equal? = 0;
            }
        }
        elseif (is_cell(v1) & is_cell(v2)) {
            if (~ are_cells_equal?(cast_to_cell(v1), cast_to_cell(v2))) {
                equal? = 0;
            }
        }
        elseif (is_tuple(v1) & is_tuple(v2)) {
            ;; recursively determine nested tuples
            if (~ are_tuples_equal?(cast_to_tuple(v1), cast_to_tuple(v2))) {
                equal? = 0;
            }
        }
        else {
            equal? = 0;
        }

        i -= 1;
    }

    return equal?;
}

() main () {
    tuple t1 = cast_to_tuple([[2, 6], [1, [3, [3, 5]]], 3]);
    tuple t2 = cast_to_tuple([[2, 6], [1, [3, [3, 5]]], 3]);

    ~dump(are_tuples_equal?(t1, t2)); ;; -1
}
```

**References:**

- [`cell_hash()`](./stdlib/#cell_hash)
- [`TVM instructions`](/tvm/instructions)

### Basic operations in lisp-style lists

[Lisp-style lists](./stdlib#lisp-style-lists) are represented as nested tuples. For example, the list `1, 2, 3` is represented as the 
nested tuple `[1, [2, [3, null]]]`, where the value `null` acts as a marker for the end of the list.

You can use the [`cons`](./stdlib#cons) function to add an element at the front of the list.
The [`null?`](./built-ins#null%3F) function checks if the provided argument is the `null` value.

```func
;; An initially empty list. 
;; "null" marks the end of the list.
;; The null value is obtained by calling the null() function.
tuple numbers = null();

;; Attach 100 as first element of the list
numbers = cons(100, numbers);
;; Attach 200 as first element of the list,
;; now 100 is the second element of the list
numbers = cons(200, numbers);
;; numbers is the list: 200, 100

;; Is the list null or equivalently, empty?
if (numbers.null?()) { 
    ;; list-style list is empty
} else {
    ;; list-style list is not empty
}
```

**References:**

- [Lisp-style lists](./stdlib#lisp-style-lists)
- [Non-modifying notation using .](./expressions#non-modifying-notation)
- [`cons`](./stdlib#cons)
- [`null`](./stdlib#null)
- [`null?`](./built-ins#null%3F)

### How to iterate through lisp-style list

This example is confusing. Needs reworking of the entire code.

A tuple can hold up to 255 values. If more space is needed, a lisp-style list can be used by nesting tuples within tuples, effectively bypassing the limit.

```func
forall X -> (tuple, ()) push_back (tuple tail, X head) asm "CONS";
forall X -> (tuple, X) pop_back (tuple t) asm "UNCONS";

() main () {
    ;; some example list
    tuple l = null();
    l~push_back(1);
    l~push_back(2);
    l~push_back(3);

    ;; iterating through elements
    ;; note that this iteration is in reversed order
    while (~ l.null?()) {
        var x = l~pop_back();

        ;; do something with x
    }
}
```

**References:**

- [`Lisp-style lists`](./stdlib/#lisp-style-lists)
- [`null()`](./stdlib/#null)

## Contracts 

### How to determine a state of the contract is empty

Consider a smart contract with a `counter` that tracks the number of transactions. This variable does not exist in the contract state during the first transaction because it is empty.
It is important to handle this scenario by checking if the state is empty and initializing the `counter` accordingly.

```func
;; `get_data()` will return the data cell from contract state
cell contract_data = get_data();
slice cs = contract_data.begin_parse();

if (cs.slice_empty?()) {
    ;; Contract data is empty, so we create counter and save it
    int counter = 1;
    ;; Create cell, add counter and save in contract state
    set_data(begin_cell().store_uint(counter, 32).end_cell());
}
else {
    ;; Contract data is not empty, so we get our counter, increase it and save
    ;; we should specify correct length of our counter in bits
    int counter = cs~load_uint(32) + 1;
    set_data(begin_cell().store_uint(counter, 32).end_cell());
}
```

**Note:**
The contract state can be determined as empty by verifying whether the [cell is empty](/languages/func/cookbook#how-to-determine-if-a-cell-is-empty).

**References:**

- [`get_data()`](/languages/func/stdlib#get_data)
- [`begin_parse()`](/languages/func/stdlib/#begin_parse)
- [`slice_empty?()`](/languages/func/stdlib/#slice_empty)
- [`set_data()`](/languages/func/stdlib#set_data)

### How to update the smart contract logic

Below is an example of a simple `CounterV1` smart contract that allows the counter to be incremented and includes logic for updating the contract.

```func
() recv_internal (slice in_msg_body) {
    int op = in_msg_body~load_uint(32);

    if (op == op::increase) {
        int increase_by = in_msg_body~load_uint(32);
        ctx_counter += increase_by;
        save_data();
        return ();
    }

    if (op == op::upgrade) {
        cell code = in_msg_body~load_ref();
        set_code(code);
        return ();
    }
}
```

After interacting with the contract, you may realize that the functionality for decrementing the counter is missing. To fix this, copy the code from `CounterV1` and add a new `decrease` function next to the existing `increase` function. Your updated code will look like this:

```func
() recv_internal (slice in_msg_body) {
    int op = in_msg_body~load_uint(32);

    if (op == op::increase) {
        int increase_by = in_msg_body~load_uint(32);
        ctx_counter += increase_by;
        save_data();
        return ();
    }

    if (op == op::decrease) {
        int decrease_by = in_msg_body~load_uint(32);
        ctx_counter -= decrease_by;
        save_data();
        return ();
    }

    if (op == op::upgrade) {
        cell code = in_msg_body~load_ref();
        set_code(code);
        return ();
    }
}
```

Once the `CounterV2` smart contract is ready, you need to compile it off-chain into a `cell` and send an upgrade message to the `CounterV1` contract:

```javascript
await contractV1.sendUpgrade(provider.sender(), {
    code: await compile('ContractV2'),
    value: toNano('0.05'),
});
```

**References:**

{/* Needs a note: Is it possible to redeploy code to an existing address, or does it have to be deployed as a new contract? */}

- [`set_code()`](./stdlib#set_code)


## Messages

### How to build an internal message cell

When a smart contract needs to send an internal message, it must first construct the message as a `cell`. This includes specifying technical flags, the recipient's address, and additional data.

```func
;; We use literal `a` to get valid address inside slice from string containing address
slice addr = "EQArzP5prfRJtDM5WrMNWyr9yUTAi0c9o6PfR4hkWy9UQXHx"a;
int amount = 1000000000;
;; we use `op` for identifying operations
int op = 0;

cell msg = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(addr)
    .store_coins(amount)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; default message headers (see sending messages page)
    .store_uint(op, 32)
.end_cell();

send_raw_message(msg, 3); ;; mode 3 - pay fees separately and ignore errors
```

**Note:**

- In this example, we use the literal `a` to obtain an address. More details on string literals can be found in the [documentation](/languages/func/literals#string-literals).
- You can find more details in the [documentation](/foundations/whitepapers/tblkch#3-1-7-message-layout). A direct link to the [layout](/foundations/whitepapers/tblkch#3-1-7-message-layout) is also available.

**References:**

- [`begin_cell()`](/languages/func/stdlib#begin_cell)
- [`store_uint()`](/languages/func/stdlib#store_uint)
- [`store_slice()`](/languages/func/stdlib#store_slice)
- [`store_coins()`](/languages/func/stdlib#store_coins)
- [`end_cell()`](/languages/func/stdlib/#end_cell)
- [`send_raw_message()`](/languages/func/stdlib/#send_raw_message)

### How to contain a body as a ref in an internal message cell

The message body can contain `int`, `slices`, or `cells` following flags and other technical data. If a `cell` is used, a bit must be set to `1` before calling `store_ref()`, indicating that the `cell` will be included.

Alternatively, if there is sufficient space, the message body can be stored in the same `cell` as the header. In this case, the bit should be set to `0`.

```func
;; We use literal `a` to get valid address inside slice from string containing address
slice addr = "EQArzP5prfRJtDM5WrMNWyr9yUTAi0c9o6PfR4hkWy9UQXHx"a;
int amount = 1000000000;
int op = 0;
cell message_body = begin_cell() ;; Creating a cell with message
    .store_uint(op, 32)
    .store_slice("")
.end_cell();

cell msg = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(addr)
    .store_coins(amount)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1) ;; default message headers (see sending messages page)
    .store_uint(1, 1) ;; set bit to 1 to indicate that the cell will go on
    .store_ref(message_body)
.end_cell();

send_raw_message(msg, 3); ;; mode 3 - pay fees separately and ignore errors
```

**Note:**

- In this example, we use the literal `a` to obtain an address. More details on string literals can be found in the [documentation](/languages/func/literals#string-literals).
- The example uses [`mode 3`](/foundations/messages/overview), which ensures the contract deducts the specified amount while covering the transaction fee from the contract balance and ignoring errors.
  - `mode 64` returns all received tokens, subtracting the commission.
  - `mode 128` transfers the entire balance.
- The [message](/languages/func/cookbook#how-to-build-an-internal-message-cell) is constructed with the body added separately.

**References:**

- [`begin_cell()`](/languages/func/stdlib#begin_cell)
- [`store_uint()`](/languages/func/stdlib#store_uint)
- [`store_slice()`](/languages/func/stdlib#store_slice)
- [`store_coins()`](/languages/func/stdlib#store_coins)
- [`end_cell()`](/languages/func/stdlib/#end_cell)
- [`send_raw_message()`](/languages/func/stdlib/#send_raw_message)

### How to contain a body as a slice in an internal message cell

A message body can be sent as either a `cell` or a `slice`. In this example, the body is sent inside a `slice`.

```func
;; We use literal `a` to get valid address inside slice from string containing address
slice addr = "EQArzP5prfRJtDM5WrMNWyr9yUTAi0c9o6PfR4hkWy9UQXHx"a;
int amount = 1000000000;
int op = 0;
slice message_body = "";

cell msg = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(addr)
    .store_coins(amount)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; default message headers (see sending messages page)
    .store_uint(op, 32)
    .store_slice(message_body)
.end_cell();

send_raw_message(msg, 3); ;; mode 3 - pay fees separately and ignore errors
```

**Note:**

- The literal `a` is used to obtain an address. See the [documentation](/languages/func/literals#string-literals) for details on string literals.
- The example uses `mode 3`, `mode 64`, and `mode 128`, as described above.
- The [message](/languages/func/cookbook#how-to-build-an-internal-message-cell) is constructed with the body included as a slice.

### How to send a simple message

To send a simple message with a comment, prepend the message body with `32 bits` set to `0`, indicating that it is a `comment`.

```func
cell msg = begin_cell()
    .store_uint(0x18, 6) ;; flags
    .store_slice("EQBIhPuWmjT7fP-VomuTWseE8JNWv2q7QYfsVQ1IZwnMk8wL"a) ;; destination address
    .store_coins(100) ;; amount of nanoTons to send
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; default message headers (see sending messages page)
    .store_uint(0, 32) ;; zero opcode - means simple transfer message with comment
    .store_slice("Hello from FunC!") ;; comment
.end_cell();
send_raw_message(msg, 3); ;; mode 3 - pay fees separately, ignore errors
```

**Reference:** [`Message layout`](/foundations/messages/overview)

### How to send a message with an incoming account

A proxy contract can facilitate secure message exchange if interaction between a user and the main contract is needed.

```func
() recv_internal (slice in_msg_body) {
    {-
        This is a simple example of a proxy-contract.
        It will expect in_msg_body to contain message mode, body and destination address to be sent to.
    -}

    int mode = in_msg_body~load_uint(8); ;; first byte will contain msg mode
    slice addr = in_msg_body~load_msg_addr(); ;; then we parse the destination address
    slice body = in_msg_body; ;; everything that is left in in_msg_body will be our new message's body

    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(addr)
        .store_coins(100) ;; just for example
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; default message headers (see sending messages page)
        .store_slice(body)
    .end_cell();
    send_raw_message(msg, mode);
}
```

**References:**

- [`Message layout`](/foundations/messages/overview)
- [`load_msg_addr()`](/languages/func/stdlib/#load_msg_addr)

### How to send a message with the entire balance

To transfer the entire balance of a smart contract, use send `mode 128`. This is particularly useful for proxy contracts that receive payments and forward them to the main contract.

```func
cell msg = begin_cell()
    .store_uint(0x18, 6) ;; flags
    .store_slice("EQBIhPuWmjT7fP-VomuTWseE8JNWv2q7QYfsVQ1IZwnMk8wL"a) ;; destination address
    .store_coins(0) ;; we don't care about this value right now
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; default message headers (see sending messages page)
    .store_uint(0, 32) ;; zero opcode - means simple transfer message with comment
    .store_slice("Hello from FunC!") ;; comment
.end_cell();
send_raw_message(msg, 128); ;; mode = 128 is used for messages that are to carry all the remaining balance of the current smart contract
```

**References:**

- [`Message layout`](/foundations/messages/overview)
- [`Message modes`](/languages/func/stdlib/#send_raw_message)

### How to send a message with a long text comment

A `cell` can store up to 127 characters (`<1023 bits`).
A sequence of linked cells ("snake cells") must be used if more space is required.

```func
{-
    If we want to send a message with really long comment, we should split the comment to several slices.
    Each slice should have <1023 bits of data (127 chars).
    Each slice should have a reference to the next one, forming a snake-like structure.
-}

cell body = begin_cell()
    .store_uint(0, 32) ;; zero opcode - simple message with comment
    .store_slice("long, long, long message...")
    .store_ref(begin_cell()
        .store_slice(" you can store string of almost any length here.")
        .store_ref(begin_cell()
            .store_slice(" just don't forget about the 127 chars limit for each slice")
        .end_cell())
    .end_cell())
.end_cell();

cell msg = begin_cell()
    .store_uint(0x18, 6) ;; flags
    ;; We use literal `a` to get valid address inside slice from string containing address
    .store_slice("EQBIhPuWmjT7fP-VomuTWseE8JNWv2q7QYfsVQ1IZwnMk8wL"a) ;; destination address
    .store_coins(100) ;; amount of nanoTons to send
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1) ;; default message headers (see sending messages page)
    .store_uint(1, 1) ;; we want to store body as a ref
    .store_ref(body)
.end_cell();
send_raw_message(msg, 3); ;; mode 3 - pay fees separately, ignore errors
```

**Reference:** [`Internal messages`](/foundations/messages/overview)

### How to send a deploy message (with `StateInit` only, with `StateInit` and body)

```func
() deploy_with_stateinit(cell message_header, cell state_init) impure {
  var msg = begin_cell()
    .store_slice(begin_parse(message_header))
    .store_uint(2 + 1, 2) ;; init:(Maybe (Either StateInit ^StateInit))
    .store_uint(0, 1) ;; body:(Either X ^X)
    .store_ref(state_init)
    .end_cell();

  ;; mode 64 - carry the remaining value in the new message
  send_raw_message(msg, 64);
}

() deploy_with_stateinit_body(cell message_header, cell state_init, cell body) impure {
  var msg = begin_cell()
    .store_slice(begin_parse(message_header))
    .store_uint(2 + 1, 2) ;; init:(Maybe (Either StateInit ^StateInit))
    .store_uint(1, 1) ;; body:(Either X ^X)
    .store_ref(state_init)
    .store_ref(body)
    .end_cell();

  ;; mode 64 - carry the remaining value in the new message
  send_raw_message(msg, 64);
}
```


## Functions 

### How to write custom functions using asm keyword

Many features we use in FunC come from pre-prepared methods inside `stdlib.fc`. 
However, we have many more capabilities, and learning to write custom functions unlocks new possibilities.

For example, while `tpush`, which adds an element to a `tuple`, exists, there is no built-in `tpop` function. In such cases, we must implement it ourselves.

```func
;; ~ means it is modifying method
forall X -> (tuple, X) ~tpop (tuple t) asm "TPOP";
```

We must determine its length if we want to iterate over a `tuple`. We can achieve this by writing a new function using the `TLEN` asm instruction.

```func
int tuple_length (tuple t) asm "TLEN";
```

Examples of functions from `stdlib.fc`:

```func
slice begin_parse(cell c) asm "CTOS";
builder begin_cell() asm "NEWC";
cell end_cell(builder b) asm "ENDC";
```

**References:**

- [`modifying method`](./statements#modifying-methods)
- [`stdlib`](./stdlib)
- [`TVM instructions`](/tvm/instructions)

### How to define a custom modifying method

Modifying methods allow data to be updated within the same variable, similar to references in other programming languages.

```func
(slice, (int)) load_digit (slice s) {
    int x = s~load_uint(8); ;; load 8 bits (one char) from slice
    x -= 48; ;; char '0' has code of 48, so we substract it to get the digit as a number
    return (s, (x)); ;; return our modified slice and loaded digit
}

() main () {
    slice s = "258";
    int c1 = s~load_digit();
    int c2 = s~load_digit();
    int c3 = s~load_digit();
    ;; here s is equal to "", and c1 = 2, c2 = 5, c3 = 8
}
```

**Reference:** [`Modifying methods`](/languages/func/statements#modifying-methods)


## Integer utilities

### How to get current time

```func
int current_time = now();

if (current_time > 1672080143) {
    ;; do some stuff
}
```

### How to generate a random number

<Aside
  type="caution"
>
  This method is not cryptographically secure.
  For more details, see [Random number generation](/techniques/random) section.
</Aside>

```func
randomize_lt(); ;; do this once

int a = rand(10);
int b = rand(1000000);
int c = random();
```

### Modulo operations

As an example, lets say we need to perform the following calculation for all 256 numbers:

`(xp + zp) * (xp - zp)`.

Since these operations are commonly used in cryptography, we utilize the modulo operator for montgomery curves.

**Note:**
Variable names like `xp+zp` are valid as long as there are no spaces between the operators.

```func
(int) modulo_operations (int xp, int zp) {
   ;; 2^255 - 19 is a prime number for montgomery curves, meaning all operations should be done against its prime
   int prime = 57896044618658097711785492504343953926634992332820282019728792003956564819949;

   ;; muldivmod handles the next two lines itself
   ;; int xp+zp = (xp + zp) % prime;
   ;; int xp-zp = (xp - zp + prime) % prime;
   (_, int xp+zp*xp-zp) = muldivmod(xp + zp, xp - zp, prime);
   return xp+zp*xp-zp;
}
```

**Reference:** [`muldivmod`](/tvm/instructions#A98C)

### How to raise number to the power of n

```func
;; Unoptimized variant
int pow (int a, int n) {
    int i = 0;
    int value = a;
    while (i < n - 1) {
        a *= value;
        i += 1;
    }
    return a;
}

;; Optimized variant
(int) binpow (int n, int e) {
    if (e == 0) {
        return 1;
    }
    if (e == 1) {
        return n;
    }
    int p = binpow(n, e / 2);
    p *= p;
    if ((e % 2) == 1) {
        p *= n;
    }
    return p;
}

() main () {
    int num = binpow(2, 3);
    ~dump(num); ;; 8
}
```

### How to convert a slice storing ASCII code into an int 

```func
slice string_number = "26052021";
int number = 0;

while (~ string_number.slice_empty?()) {
    int char = string_number~load_uint(8);
    number = (number * 10) + (char - 48); ;; we use ASCII table
}

~dump(number);
```

### How to convert an int into a slice storing the ASCII code

```func
int n = 261119911;
builder string = begin_cell();
tuple chars = null();
do {
    int r = n~divmod(10);
    chars = cons(r + 48, chars);
} until (n == 0);
do {
    int char = chars~list_next();
    string~store_uint(char, 8);
} until (null?(chars));

slice result = string.end_cell().begin_parse();
~dump(result);
```

## Exceptions 

### How to throw errors

```func
int number = 198;

throw_if(35, number > 50); ;; the error will be triggered only if the number is greater than 50

throw_unless(39, number == 198); ;; the error will be triggered only if the number is NOT EQUAL to 198

throw(36); ;; the error will be triggered anyway
```

[Standard TVM exception codes](/tvm/exit-codes)

## Addresses

### Generate an internal address

When deploying a new contract, we need to generate its internal address because it is initially unknown. Suppose we already have `state_init`, which contains the code and data of the new contract.

This function creates an internal address corresponding to the `MsgAddressInt` TLB.

```func
(slice) generate_internal_address (int workchain_id, cell state_init) {
    ;; addr_std$10 anycast:(Maybe Anycast) workchain_id:int8 address:bits256  = MsgAddressInt;

    return begin_cell()
        .store_uint(2, 2) ;; addr_std$10
        .store_uint(0, 1) ;; anycast nothing
        .store_int(workchain_id, 8) ;; workchain_id: -1
        .store_uint(cell_hash(state_init), 256)
    .end_cell().begin_parse();
}

() main () {
    slice deploy_address = generate_internal_address(workchain(), state_init);
    ;; then we can deploy new contract
}
```

**Note:** In this example, we use `workchain()` to retrieve the WorkChain ID. You can learn more about the WorkChain ID in [docs](/ton/addresses/overview#workchain-id).

**Reference:** [`cell_hash()`](./stdlib/#cell_hash)

### Generate an external address

We use the TL-B scheme from [block.tlb](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/block/block.tlb#L101C1-L101C12) to determine the address format to generate an external address.

```func
(int) ubitsize (int a) asm "UBITSIZE";

slice generate_external_address (int address) {
    ;; addr_extern$01 len:(## 9) external_address:(bits len) = MsgAddressExt;

    int address_length = ubitsize(address);

    return begin_cell()
        .store_uint(1, 2) ;; addr_extern$01
        .store_uint(address_length, 9)
        .store_uint(address, address_length)
    .end_cell().begin_parse();
}
```

Since we need to find the exact number of bits occupied by the address, we must [declare an asm function](#how-to-write-custom-functions-using-asm-keyword) with the `UBITSIZE` opcode. This function will return the minimum number of bits required to store a given number.

**Reference:** [TVM instructions](/tvm/instructions#B603)

### How to calculate a contract address (using `StateInit`)

```func
() calc_address(cell state_init) {
  var future_address = begin_cell()
    .store_uint(2, 2) ;; addr_std$10
    .store_uint(0, 1) ;; anycast:(Maybe Anycast)
    .store_uint(0, 8) ;; workchain_id:int8
    .store_uint(cell_hash(state_init), 256) ;; address:bits256
    .end_cell();
}
```
