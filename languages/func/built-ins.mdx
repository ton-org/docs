---
title: "FunC reserved words and built-ins"
sidebarTitle: "Reserved words and built-ins"
noindex: "true"
---

import { Aside } from '/snippets/aside.jsx';

## Reserved keywords

FunC reserves the following symbols and words. These cannot be used as identifiers.

### Symbols

`+`   `-`   `*`   `/`

`%`   `?`   `:`   `,`

`;`   `(`   `)`   `[`

`]`   `{`   `}`   `=`

`_`   `<`   `>`   `&`

`|`   `^`   `~`   `==`

`!=`   `<=`   `>=`   `<=>`

`<<`   `>>`   `~>>`   `^>>`

`~/`   `^/`   `~%`   `^%`

`/%`   `+=`   `-=`   `*=`

`/=`   `~/=`   `^/=`   `%=`

`~%=`   `^%=`   `<<=`   `>>=`

`~>>=`   `^>>=`   `&=`   `|=`

`^=`   `->`

### Words

`return`   `var`   `repeat`   `do`

`while`   `until`   `try`   `catch`

`if`   `ifnot`   `then`   `else`

`elseif`   `elseifnot`   `int`   `cell`

`slice`   `builder`   `cont`   `tuple`

`type`   `forall`   `extern`   `global`

`asm`   `impure`   `inline`   `inline_ref`

`auto_apply`   `method_id`   `operator`   `infix`

`infixl`   `infixr`   `const`   `#pragma`

`#include`

## Built-ins

This section covers extra language constructs that are not part of the core but are still important for functionality. Although they could be implemented in [stdlib.fc](/languages/func/stdlib), keeping them as built-in features allows the FunC optimizer to work more efficiently.

In addition, FunC does not allow the built-in names in this section to be used as identifiers. However, there is an exception: [built-ins with non-symbolic names](#built-ins-with-non-symbolic-names) _can_ be used as identifiers for local variables.

### Built-ins with symbolic names

`_+_`   `_-_`   `-_`   `_*_`

`_/_`   `_~/_`   `_^/_`   `_%_`

`_~%_`   `_^%_`   `_/%_`   `_<<_`

`_>>_`   `_~>>_`   `_^>>_`   `_&_`

`_|_`   `_^_`   `~_`   `^_+=_`

`^_-=_`   `^_*=_`   `^_/=_`   `^_~/=_`

`^_^/=_`   `^_%=_`   `^_~%=_`   `^_^%=_`

`^_<<=_`   `^_>>=_`   `^_~>>=_`   `^_^>>=_`

`^_&=_`   `^_|=_`   `^_^=_`   `_==_`

`_!=_`   `_<_`   `_>_`   `_<=_`

`_>=_`   `_<=>_`

### Built-ins with non-symbolic names

[`divmod`](#divmod)   `~divmod`   `moddiv`   `~moddiv`

[`muldiv`](#muldiv)   `muldivr`   `muldivc`   `muldivmod`

[`true`](#true)   [`false`](#false)   `nil`   `Nil`

[`null?`](#null%3F)   [`throw`](#throw)   [`throw_if`](#throw-if)   [`throw_unless`](#throw-unless)

[`throw_arg`](#throw-arg)   [`throw_arg_if`](#throw-arg-if)   [`throw_arg_unless`](#throw-arg-unless)   `load_int`

`load_uint`   `preload_int`   `preload_uint`   `store_int`

`store_uint`   `~store_int`   `~store_uint`   `load_bits`

`preload_bits`   `int_at`   `cell_at`   `slice_at`

`tuple_at`   [`at`](#at)   [`touch`](#touch-and-touch)   [`~touch`](#touch-and-touch)

`touch2`   `~touch2`   [`~dump`](#dump)   [`~strdump`](#strdump)

`run_method0`   `run_method1`   `run_method2`   `run_method3`

#### `throw`

Emits an unconditional exception. `throw` takes only one argument—the error code—since it always triggers an exception.

#### `throw_if`

Emits an exception only if the provided condition is true. It receives two arguments: the error code, which defines the exception type, and the condition.

#### `throw_unless`

Emits an exception only if the provided condition is false. It receives two arguments: the error code, which defines the exception type, and the condition.

#### `throw_arg`

Parameterized and unconditional version of `throw`.

The first argument is a parameter of any type, and the second argument is the error code.

#### `throw_arg_if`

Parameterized version of `throw_if`.

The first argument is a parameter of any type, the second argument defines the error code, and the third argument is the condition.

#### `throw_arg_unless`

Parameterized version of `throw_unless`.

The first argument is a parameter of any type, the second argument defines the error code, and the third argument is the condition.

#### `~dump`

`~dump` outputs a variable to the debug log.

#### `~strdump`

`~strdump` outputs a string to the debug log.

#### `divmod`

`divmod` takes two numbers as input and returns the quotient and remainder of their division.

#### `muldiv`

`muldiv` performs a multiply-then-divide operation. It uses a 513-bit intermediate result to prevent overflow if the final result fits within 257 bits.

#### `true`

`true` is an alias for `-1`.

#### `false`

`false` is an alias for `0`.

#### `null?`

`null?` checks if the given argument is `null`.

In FunC, the value `null` belongs to the TVM type `Null`, which represents the absence of a value for certain atomic types. See [null values](/languages/func/types#null-values) for details.

#### `touch` and `~touch`

`touch` pushes a variable to the top of the stack. `~touch` is identical to `touch`, but it is adapted for use in [modifying syntax](/languages/func/functions#modifying-methods).

#### `at`

Function `at` returns the value of a tuple element at the specified position.
