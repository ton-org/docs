---
title: "FunC reserved words and built-ins"
sidebarTitle: "Reserved words and built-ins"
noindex: "true"
---

import { Aside } from '/snippets/aside.jsx';

## Reserved keywords

FunC reserves the following symbols and words. These cannot be used as identifiers.

### Symbols

`+`   `-`   `*`   `/`

`%`   `?`   `:`   `,`

`;`   `(`   `)`   `[`

`]`   `{`   `}`   `=`

`_`   `<`   `>`   `&`

`|`   `^`   `~`   `==`

`!=`   `<=`   `>=`   `<=>`

`<<`   `>>`   `~>>`   `^>>`

`~/`   `^/`   `~%`   `^%`

`/%`   `+=`   `-=`   `*=`

`/=`   `~/=`   `^/=`   `%=`

`~%=`   `^%=`   `<<=`   `>>=`

`~>>=`   `^>>=`   `&=`   `|=`

`^=`   `->`

### Words

`return`   `var`   `repeat`   `do`

`while`   `until`   `try`   `catch`

`if`   `ifnot`   `then`   `else`

`elseif`   `elseifnot`   `int`   `cell`

`slice`   `builder`   `cont`   `tuple`

`type`   `forall`   `extern`   `global`

`asm`   `impure`   `inline`   `inline_ref`

`auto_apply`   `method_id`   `operator`   `infix`

`infixl`   `infixr`   `const`   `#pragma`

`#include`

## Built-ins

This section covers extra language constructs that are not part of the core but are still important for functionality. Although they could be implemented in [stdlib.fc](/languages/func/stdlib), keeping them as built-in features allows the FunC optimizer to work more efficiently.

In addition, FunC does not allow the built-in names in this section to be used as identifiers. However, there is an exception: [built-ins with non-symbolic names](#built-ins-with-non-symbolic-names) _can_ be used as identifiers for local variables.

### Built-ins with symbolic names

`_+_`   `_-_`   `-_`   `_*_`

`_/_`   `_~/_`   `_^/_`   `_%_`

`_~%_`   `_^%_`   `_/%_`   `_<<_`

`_>>_`   `_~>>_`   `_^>>_`   `_&_`

`_|_`   `_^_`   `~_`   `^_+=_`

`^_-=_`   `^_*=_`   `^_/=_`   `^_~/=_`

`^_^/=_`   `^_%=_`   `^_~%=_`   `^_^%=_`

`^_<<=_`   `^_>>=_`   `^_~>>=_`   `^_^>>=_`

`^_&=_`   `^_|=_`   `^_^=_`   `_==_`

`_!=_`   `_<_`   `_>_`   `_<=_`

`_>=_`   `_<=>_`

Each one of the above names is a function wrapping the corresponding operator.

For example, `_+_` can be understood as wrapping the [`+` operator](/languages/func/operators#addition%2C-%2B):

```func
int _+_(int a, int b) { return a + b; }
```

These functions are useful when operators need to be passed as arguments to functions, or assigned to variables.

For example, in the following snippet, function `apply` receives as argument a function `f` of type `(int, int) -> int`
and applies it on the arguments `2` and `3`:

```func
int apply(((int, int) -> int) f) {
    return f(2, 3);
}
```

Then, it is possible to invoke `apply` by passing `_+_`:

```func
apply(_+_);   ;; Returns 5
```

Attempting to pass the operator `+` directly does not compile:

```func
apply(+);   ;; DOES NOT COMPILE
```

### Built-ins with non-symbolic names

[`divmod`](#divmod)   [`~divmod`](#divmod-2)   [`moddiv`](#moddiv)   [`~moddiv`](#moddiv-2)

[`muldiv`](#muldiv)   [`muldivr`](#muldivr)   [`muldivc`](#muldivc)   [`muldivmod`](#muldivmod)

[`true`](#true)   [`false`](#false)   [`nil`](#nil)   [`Nil`](#nil-2)

[`null?`](#null%3F)   [`throw`](#throw)   [`throw_if`](#throw-if)   [`throw_unless`](#throw-unless)

[`throw_arg`](#throw-arg)   [`throw_arg_if`](#throw-arg-if)   [`throw_arg_unless`](#throw-arg-unless)   [`load_int`](#load-int)

[`load_uint`](#load-uint)   [`preload_int`](#preload-int)   [`preload_uint`](#preload-uint)   [`store_int`](#store-int)

[`store_uint`](#store-uint)   [`~store_int`](#store-int-2)   [`~store_uint`](#store-uint-2)   [`load_bits`](#load-bits)

[`preload_bits`](#preload-bits)   [`int_at`](#int-at)   [`cell_at`](#cell-at)   [`slice_at`](#slice-at)

[`tuple_at`](#tuple-at)   [`at`](#at)   [`touch`](#touch)   [`~touch`](#touch-2)

[`touch2`](#touch2)   [`~touch2`](#touch2-2)   [`~dump`](#dump)   [`~strdump`](#strdump)

[`run_method0`](#run-method0)   [`run_method1`](#run-method1)   [`run_method2`](#run-method2)   [`run_method3`](#run-method3)

#### `divmod`

```func
(int, int) divmod(int dividend, int divisor)
```

`divmod` takes two integers as input and returns the quotient and remainder of their division `dividend / divisor`.

#### `~divmod`

Same as [`divmod`](#divmod), but allows using [modifying notation](/languages/func/expressions#modifying-notation).

Example:

```func
int a = 10;
int b = 2;

;; "mod" stores the modulo 10 % 2
;; and "a" gets updated with the quotient of 10 / 2
int mod = a~divmod(b);

;; Here, a has value 5
;; mod has value 0
;; b has value 2
```

#### `moddiv`

```func
(int, int) moddiv(int dividend, int divisor)
```

`moddiv` takes two integers as input and returns the remainder and quotient of their division `dividend / divisor`.

#### `~moddiv`

Same as [`moddiv`](#moddiv), but allows using [modifying notation](/languages/func/expressions#modifying-notation).

Example:

```func
int a = 10;
int b = 2;

;; "div" stores the quotient of 10 / 2
;; and "a" gets updated with the modulo 10 % 2
int div = a~moddiv(b);

;; Here, a has value 0
;; div has value 5
;; b has value 2
```

#### `muldiv`

```func
int muldiv(int factor1, int factor2, int divisor)
```

`muldiv` performs a multiply-then-divide operation `(factor1 * factor2) / divisor`, where `/` is the [division operator](/languages/func/operators#division%2C-%2F).
It uses a 513-bit intermediate result to prevent overflow if the final result fits within 257 bits.

#### `muldivr`

```func
int muldivr(int factor1, int factor2, int divisor)
```

`muldivr` performs a multiply-then-divide operation `(factor1 * factor2) ~/ divisor`, where `~/` is the [rounding division operator](/languages/func/operators#rounding-division%2C-%2F).
It uses a 513-bit intermediate result to prevent overflow if the final result fits within 257 bits.

#### `muldivc`

```func
int muldivc(int factor1, int factor2, int divisor)
```

`muldivc` performs a multiply-then-divide operation `(factor1 * factor2) ^/ divisor`, where `^/` is the [ceiling division operator](/languages/func/operators#ceiling-division%2C-%5E%2F).
It uses a 513-bit intermediate result to prevent overflow if the final result fits within 257 bits.

#### `muldivmod`

```func
(int, int) muldivmod(int factor1, int factor2, int divisor)
```

`muldivmod` performs a multiply-then-divide operation `(factor1 * factor2) / divisor`, where `/` is the [division operator](/languages/func/operators#division%2C-%2F),
and returns the quotient and remainder of such division. It uses a 513-bit intermediate result to prevent overflow if the final result fits within 257 bits.

#### `true`

`true` is an alias for `-1`.

#### `false`

`false` is an alias for `0`.

#### `nil`

`nil` is an alias for the `null` value.

#### `Nil`

`Nil` is an alias for the empty tuple `[]`.

#### `null?`

```func
forall X -> int null?(X val)
```

`null?` checks if the given argument is `null`. Returns `0` if the argument is not `null`, and `-1` otherwise.

For more info, see [null values](/languages/func/types#null-values).

#### `throw`

```func
() throw(int error)
```

Triggers an exception, which interrupts the execution flow.
`throw` takes only one argument, the error code. See [TVM error codes](/tvm/exit-codes) for details about error codes.

#### `throw_if`

```func
() throw_if(int error, int condition)
```

Triggers an exception only if the provided condition is true, i.e., if the condition is `-1`.
It receives two arguments: the error code, which defines the exception type, and the condition.
See [TVM error codes](/tvm/exit-codes) for details about error codes.

#### `throw_unless`

```func
() throw_unless(int error, int condition)
```

Triggers an exception only if the provided condition is false, i.e., if the condition is `0`.
It receives two arguments: the error code, which defines the exception type, and the condition.
See [TVM error codes](/tvm/exit-codes) for details about error codes.

#### `throw_arg`

```func
forall X -> () throw_arg(X arg, int error)
```

Triggers an exception, which interrupts the execution flow.

The first argument can be of any type, and it is used to pass extra information about the error. This extra information can be
processed in [`try..catch` statements](/languages/func/statements#try-catch-statement).
Refer to the `try..catch` statement page for an example on how to use the first argument.
The second argument is the error code. See [TVM error codes](/tvm/exit-codes) for details about error codes.

#### `throw_arg_if`

```func
forall X -> () throw_arg_if(X arg, int error, int condition)
```

Triggers an exception only if the provided condition is true, i.e., if the condition is `-1`.

Similarly to [`throw_arg`](#throw-arg), the first argument can be of any type, and it is used to pass extra information about the error. This extra information can be
processed in [`try..catch` statements](/languages/func/statements#try-catch-statement), in the same way as with [`throw_arg`](#throw-arg).
The second argument is the error code. See [TVM error codes](/tvm/exit-codes) for details about error codes.
The third argument is the condition to check.

#### `throw_arg_unless`

```func
forall X -> () throw_arg_unless(X arg, int error, int condition)
```

Triggers an exception only if the provided condition is false, i.e., if the condition is `0`.

Similarly to [`throw_arg`](#throw-arg), the first argument can be of any type, and it is used to pass extra information about the error. This extra information can be
processed in [`try..catch` statements](/languages/func/statements#try-catch-statement), in the same way as with [`throw_arg`](#throw-arg).
The second argument is the error code. See [TVM error codes](/tvm/exit-codes) for details about error codes.
The third argument is the condition to check.

#### `load_int`

```func
(slice, int) load_int(slice s, int len)
```

Reads a signed `len`-bit integer from slice `s`. Returns the modified slice and the obtained integer.

#### `load_uint`

```func
(slice, int) load_uint(slice s, int len)
```

Reads an unsigned `len`-bit integer from slice `s`. Returns the modified slice and the obtained unsigned integer.

#### `preload_int`

```func
int preload_int(slice s, int len)
```

Reads a signed `len`-bit integer from slice `s`. Returns the obtained integer. This method does not modify slice `s`.

#### `preload_uint`

```func
int preload_uint(slice s, int len)
```

Reads an unsigned `len`-bit integer from slice `s`. Returns the obtained unsigned integer. This method does not modify slice `s`.

#### `store_int`

```func
builder store_int(builder b, int x, int len)
```

Stores a signed `len`-bit integer `x` in builder `b`. Returns the modified builder.

#### `store_uint`

```func
builder store_uint(builder b, int x, int len)
```

Stores an unsigned `len`-bit integer `x` in builder `b`. Returns the modified builder.

#### `~store_int`

```func
(builder, ()) ~store_int(builder b, int x, int len)
```

Same as [`store_int`](#store-int), but adapted to use [modifying notation](/languages/func/expressions#modifying-notation).

#### `~store_uint`

```func
(builder, ()) ~store_uint(builder b, int x, int len)
```

Same as [`store_uint`](#store-uint), but adapted to use [modifying notation](/languages/func/expressions#modifying-notation).

#### `load_bits`

```func
(slice, slice) load_bits(slice s, int len)
```

Loads the first `len` bits from slice `s`. It returns the modified slice and a slice containing the loaded bits.

#### `preload_bits`

```func
slice preload_bits(slice s, int len)
```

Loads the first `len` bits from slice `s`. It returns a slice containing the loaded bits. This method does not modify slice `s`.

#### `int_at`

```func
int int_at(tuple t, int index)
```

Returns the element at index `index` in tuple `t`, casted as an integer.

<Aside
  type="danger"
>
  It is responsibility of the programmer to check that the returned element is actually an integer.
</Aside>

#### `cell_at`

```func
cell cell_at(tuple t, int index)
```

Returns the element at index `index` in tuple `t`, casted as a cell.

<Aside
  type="danger"
>
  It is responsibility of the programmer to check that the returned element is actually a cell.
</Aside>

#### `slice_at`

```func
slice slice_at(tuple t, int index)
```

Returns the element at index `index` in tuple `t`, casted as a slice.

<Aside
  type="danger"
>
  It is responsibility of the programmer to check that the returned element is actually a slice.
</Aside>

#### `tuple_at`

```func
tuple tuple_at(tuple t, int index)
```

Returns the element at index `index` in tuple `t`, casted as a tuple.

<Aside
  type="danger"
>
  It is responsibility of the programmer to check that the returned element is actually a tuple.
</Aside>

#### `at`

```func
forall X -> X at(tuple t, int index)
```

Returns the element at index `index` in tuple `t`. The returned element can be of any type.

#### `touch`

```func
forall X -> X touch(X v)
```

Moves `v` to the top of the stack. It returns the argument `v`.

#### `~touch`

```func
forall X -> (X, ()) ~touch(X v)
```

`~touch` is identical to [`touch`](#touch), but adapted to use [modifying notation](/languages/func/expressions#modifying-notation).

#### `touch2`

```func
forall X, Y -> (X, Y) touch2((X, Y) t)
```

Moves the components of the tensor `t` to the top of the stack; first component with type `X` and then component with type `Y`. It returns the argument tensor `t`.

#### `~touch2`

```func
forall X, Y -> ((X, Y), ()) ~touch2((X, Y) t)
```

`~touch2` is identical to [`touch2`](#touch2), but adapted to use [modifying notation](/languages/func/expressions#modifying-notation).

#### `~dump`

```func
forall X -> (X, ()) ~dump(X value)
```

Outputs value `value` to the debug log. It returns the argument `value` and the unit value `()`.
[Modifying notation](/languages/func/expressions#modifying-notation) can be used on this function.

In case `value` is a slice containing ASCII characters, it is preferable to use [`~strdump`](#strdump) if the intention is
to print the ASCII string in the debug log. Otherwise, `~dump` will print the slice's contents as bits.

#### `~strdump`

```func
forall X -> (X, ()) ~strdump(X s)
```

Outputs to the debug log the ASCII string encoded in slice `s`. It returns the argument `s` and the unit value `()`.
[Modifying notation](/languages/func/expressions#modifying-notation) can be used on this function.

If the argument `s` is not a slice containing ASCII characters, the debug log will show an error.

#### `run_method0`

```func
() run_method0 (int method_id)
```

Executes the 0 argument function with [ID](/languages/func/functions#method-id-specifier) `method_id`. The function with ID `method_id` must have a signature of the form:

```func
() some_function()
```

which receives 0 arguments and returns nothing.

The `run_method0` is useful for dynamically executing methods at run-time.
For example, receiving the method ID to execute in the incoming internal message.

<Aside>
  Recall that method ids can be explicitly set when declaring functions using the [`method_id` specifier](/languages/func/functions#method-id-specifier):

  ```func
  () test() method_id(1234)
  ```

  So that later, it can be invoked as:

  ```func
  run_method0(1234);   ;; executes function test
  ```
</Aside>

<Aside
  type="danger"
>
  The FunC compiler does not check that the function to execute in `run_method0` has the correct number of arguments and
  that it returns `()`. This is responsibility of the programmer.
</Aside>

#### `run_method1`

```func
forall X -> () run_method1 (int method_id, X arg1)
```

Executes the 1 argument function with [ID](/languages/func/functions#method-id-specifier) `method_id`, and passes `arg1` as argument to the function.
The function with ID `method_id` must have a signature of the form:

```func
() some_function(T a1)
```

which receives 1 argument and returns nothing. Type `T` must coincide with the type of the argument `arg1` provided in `run_method1`.

For example, under the assumption that `1234` is the ID of function `test`, invoking:

```func
;; The argument "a" is a slice containing the ASCII character 'a'
run_method1(1234, "a");
```

requires that `test` has the signature:

```func
() test(slice s)
```

As with [`run_method0`](#run-method0), function `run_method1` is useful for dynamically executing 1 argument methods at run-time.

<Aside
  type="danger"
>
  The FunC compiler does not check that the function to execute in `run_method1` has the correct number of arguments,
  that it returns `()`, and that the types of arguments in `run_method1` and the function to execute coincide. This is responsibility of the programmer.
</Aside>

#### `run_method2`

```func
forall X, Y -> () run_method2 (int method_id, X arg1, Y arg2)
```

Executes the 2 argument function with [ID](/languages/func/functions#method-id-specifier) `method_id`. The function with ID `method_id` must have a signature of the form:

```func
() some_function(T1 a1, T2 a2)
```

which receives 2 arguments and returns nothing. Type `T1` must coincide with the type of the argument `arg1` provided in `run_method2`,
and similarly for type `T2`.

The same observations and warnings apply as with [`run_method1`](#run-method1).

#### `run_method3`

```func
forall X, Y, Z -> () run_method3 (int method_id, X arg1, Y arg2, Z arg3)
```

Executes the 3 argument function with [ID](/languages/func/functions#method-id-specifier) `method_id`. The function with ID `method_id` must have a signature of the form:

```func
() some_function(T1 a1, T2 a2, T3 a3)
```

which receives 3 arguments and returns nothing. Type `T1` must coincide with the type of the argument `arg1` provided in `run_method3`,
and similarly for types `T2` and `T3`.

The same observations and warnings apply as with [`run_method1`](#run-method1).
