---
title: "FunC reserved words and built-ins"
sidebarTitle: "Reserved words and built-ins"
noindex: "true"
---

import { Aside } from '/snippets/aside.jsx';

## Reserved keywords

FunC reserves the following symbols and words. These cannot be used as identifiers.

### Symbols

`+`   `-`   `*`   `/`

`%`   `?`   `:`   `,`

`;`   `(`   `)`   `[`

`]`   `{`   `}`   `=`

`_`   `<`   `>`   `&`

`|`   `^`   `~`   `==`

`!=`   `<=`   `>=`   `<=>`

`<<`   `>>`   `~>>`   `^>>`

`~/`   `^/`   `~%`   `^%`

`/%`   `+=`   `-=`   `*=`

`/=`   `~/=`   `^/=`   `%=`

`~%=`   `^%=`   `<<=`   `>>=`

`~>>=`   `^>>=`   `&=`   `|=`

`^=`   `->`

### Words

`return`   `var`   `repeat`   `do`

`while`   `until`   `try`   `catch`

`if`   `ifnot`   `then`   `else`

`elseif`   `elseifnot`   `int`   `cell`

`slice`   `builder`   `cont`   `tuple`

`type`   `forall`   `extern`   `global`

`asm`   `impure`   `inline`   `inline_ref`

`auto_apply`   `method_id`   `operator`   `infix`

`infixl`   `infixr`   `const`   `#pragma`

`#include`

## Built-ins

This section covers extra language constructs that are not part of the core but are still important for functionality. Although they could be implemented in [stdlib.fc](/languages/func/stdlib), keeping them as built-in features allows the FunC optimizer to work more efficiently.

In addition, FunC does not allow the built-in names in this section to be used as identifiers. However, there is an exception: [built-ins with non-symbolic names](#built-ins-with-non-symbolic-names) _can_ be used as identifiers for local variables.

### Built-ins with symbolic names

`_+_`   `_-_`   `-_`   `_*_`

`_/_`   `_~/_`   `_^/_`   `_%_`

`_~%_`   `_^%_`   `_/%_`   `_<<_`

`_>>_`   `_~>>_`   `_^>>_`   `_&_`

`_|_`   `_^_`   `~_`   `^_+=_`

`^_-=_`   `^_*=_`   `^_/=_`   `^_~/=_`

`^_^/=_`   `^_%=_`   `^_~%=_`   `^_^%=_`

`^_<<=_`   `^_>>=_`   `^_~>>=_`   `^_^>>=_`

`^_&=_`   `^_|=_`   `^_^=_`   `_==_`

`_!=_`   `_<_`   `_>_`   `_<=_`

`_>=_`   `_<=>_`

Each one of the above names is a function wrapping the corresponding operator.

For example, `_+_` can be understood as wrapping the [`+` operator](/languages/func/operators#addition%2C-%2B):

```func
int _+_(int a, int b) { return a + b; }
```

These functions are useful when operators need to be passed as arguments to functions, or assigned to variables.

For example, in the following snippet, function `apply` receives as argument a function `f` of type `(int, int) -> int`
and applies it on the arguments `2` and `3`:

```func
int apply(((int, int) -> int) f) {
    return f(2, 3);
}
```

Then, it is possible to invoke `apply` by passing `_+_`:

```func
apply(_+_);   ;; Returns 5
```

Attempting to pass the operator `+` directly does not compile:

```func
apply(+);   ;; DOES NOT COMPILE
```

### Built-ins with non-symbolic names

[`divmod`](#divmod)   [`~divmod`](#divmod-2)   [`moddiv`](#moddiv)   [`~moddiv`](#moddiv-2)

[`muldiv`](#muldiv)   [`muldivr`](#muldivr)   [`muldivc`](#muldivc)   [`muldivmod`](#muldivmod)

[`true`](#true)   [`false`](#false)   [`nil`](#nil)   [`Nil`](#nil-2)

[`null?`](#null%3F)   [`throw`](#throw)   [`throw_if`](#throw-if)   [`throw_unless`](#throw-unless)

[`throw_arg`](#throw-arg)   [`throw_arg_if`](#throw-arg-if)   [`throw_arg_unless`](#throw-arg-unless)   [`load_int`](#load-int)

[`load_uint`](#load-uint)   [`preload_int`](#preload-int)   [`preload_uint`](#preload-uint)   [`store_int`](#store-int)

[`store_uint`](#store-uint)   [`~store_int`](#store-int-2)   [`~store_uint`](#store-uint-2)   [`load_bits`](#load-bits)

[`preload_bits`](#preload-bits)   [`int_at`](#int-at)   [`cell_at`](#cell-at)   [`slice_at`](#slice-at)

[`tuple_at`](#tuple-at)   [`at`](#at)   [`touch`](#touch-and-touch)   [`~touch`](#touch-and-touch)

[`touch2`](#touch2)   [`~touch2`](#touch2-2)   [`~dump`](#dump)   [`~strdump`](#strdump)

`run_method0`   `run_method1`   `run_method2`   `run_method3`

#### `divmod`

```func
(int, int) divmod(int dividend, int divisor)
```

`divmod` takes two integers as input and returns the quotient and remainder of their division `dividend / divisor`.

#### `~divmod`

Same as [`divmod`](#divmod), but allows using [modifying notation](/languages/func/expressions#modifying-notation).

Example:

```func
int a = 10;
int b = 2;

;; "mod" stores the modulo 10 % 2
;; and "a" gets updated with the quotient of 10 / 2
int mod = a~divmod(b);

;; Here, a has value 5
;; mod has value 0
;; b has value 2
```

#### `moddiv`

```func
(int, int) moddiv(int dividend, int divisor)
```

`moddiv` takes two integers as input and returns the remainder and quotient of their division `dividend / divisor`.

#### `~moddiv`

Same as [`moddiv`](#moddiv), but allows using [modifying notation](/languages/func/expressions#modifying-notation).

Example:

```func
int a = 10;
int b = 2;

;; "div" stores the quotient of 10 / 2
;; and "a" gets updated with the modulo 10 % 2
int div = a~moddiv(b);

;; Here, a has value 0
;; div has value 5
;; b has value 2
```

#### `muldiv`

```func
int muldiv(int factor1, int factor2, int divisor)
```

`muldiv` performs a multiply-then-divide operation `(factor1 * factor2) / divisor`, where `/` is the [division operator](/languages/func/operators#division%2C-%2F).
It uses a 513-bit intermediate result to prevent overflow if the final result fits within 257 bits.

#### `muldivr`

```func
int muldivr(int factor1, int factor2, int divisor)
```

`muldivr` performs a multiply-then-divide operation `(factor1 * factor2) ~/ divisor`, where `~/` is the [rounding division operator](/languages/func/operators#rounding-division%2C-%2F).
It uses a 513-bit intermediate result to prevent overflow if the final result fits within 257 bits.

#### `muldivc`

```func
int muldivc(int factor1, int factor2, int divisor)
```

`muldivc` performs a multiply-then-divide operation `(factor1 * factor2) ^/ divisor`, where `^/` is the [ceiling division operator](/languages/func/operators#ceiling-division%2C-%5E%2F).
It uses a 513-bit intermediate result to prevent overflow if the final result fits within 257 bits.

#### `muldivmod`

```func
(int, int) muldivmod(int factor1, int factor2, int divisor)
```

`muldiv` performs a multiply-then-divide operation `(factor1 * factor2) / divisor`, where `/` is the [division operator](/languages/func/operators#division%2C-%2F),
and returns the quotient and remainder of such division. It uses a 513-bit intermediate result to prevent overflow if the final result fits within 257 bits.

#### `true`

`true` is an alias for `-1`.

#### `false`

`false` is an alias for `0`.

#### `nil`

`nil` is an alias for the `null` value.

#### `Nil`

`Nil` is an alias for the empty tuple `[]`.

#### `null?`

```func
forall X -> int null?(X val)
```

`null?` checks if the given argument is `null`. Returns `0` if the argument is not `null`, and `-1` otherwise.

For more info, see [null values](/languages/func/types#null-values).

#### `throw`

```func
() throw(int error)
```

Triggers an exception, which interrupts the execution flow.
`throw` takes only one argument, the error code. See [TVM error codes](/tvm/exit-codes) for details about error codes.

#### `throw_if`

```func
() throw_if(int error, int condition)
```

Triggers an exception only if the provided condition is true, i.e., if the condition is `-1`.
It receives two arguments: the error code, which defines the exception type, and the condition.
See [TVM error codes](/tvm/exit-codes) for details about error codes.

#### `throw_unless`

```func
() throw_unless(int error, int condition)
```

Triggers an exception only if the provided condition is false, i.e., if the condition is `0`.
It receives two arguments: the error code, which defines the exception type, and the condition.
See [TVM error codes](/tvm/exit-codes) for details about error codes.

#### `throw_arg`

```func
forall X -> () throw_arg(X arg, int error)
```

Triggers an exception, which interrupts the execution flow.

The first argument can be of any type, and it is used to pass extra information about the error. This extra information can be
processed in [`try..catch` statements](/languages/func/statements#try-catch-statement).
Refer to the `try..catch` statement page for an example on how to use the first argument.
The second argument is the error code. See [TVM error codes](/tvm/exit-codes) for details about error codes.

#### `throw_arg_if`

```func
forall X -> () throw_arg_if(X arg, int error, int condition)
```

Triggers an exception only if the provided condition is true, i.e., if the condition is `-1`.

Similarly to [`throw_arg`](#throw-arg), the first argument can be of any type, and it is used to pass extra information about the error. This extra information can be
processed in [`try..catch` statements](/languages/func/statements#try-catch-statement), in the same way as with [`throw_arg`](#throw-arg).
The second argument is the error code. See [TVM error codes](/tvm/exit-codes) for details about error codes.
The third argument is the condition to check.

#### `throw_arg_unless`

```func
forall X -> () throw_arg_if(X arg, int error, int condition)
```

Triggers an exception only if the provided condition is false, i.e., if the condition is `0`.

Similarly to [`throw_arg`](#throw-arg), the first argument can be of any type, and it is used to pass extra information about the error. This extra information can be
processed in [`try..catch` statements](/languages/func/statements#try-catch-statement), in the same way as with [`throw_arg`](#throw-arg).
The second argument is the error code. See [TVM error codes](/tvm/exit-codes) for details about error codes.
The third argument is the condition to check.

#### `load_int`

```func
(slice, int) load_int(slice s, int len)
```

Reads a signed `len`-bit integer from slice `s`. Returns the modified slice and the obtained integer.

#### `load_uint`

```func
(slice, int) load_uint(slice s, int len)
```

Reads an unsigned `len`-bit integer from slice `s`. Returns the modified slice and the obtained unsigned integer.

#### `preload_int`

```func
int preload_int(slice s, int len)
```

Reads a signed `len`-bit integer from slice `s`. Returns the obtained integer. This method does not modify slice `s`.

#### `preload_uint`

```func
int preload_uint(slice s, int len)
```

Reads an unsigned `len`-bit integer from slice `s`. Returns the obtained unsigned integer. This method does not modify slice `s`.

#### `store_int`

```func
builder store_int(builder b, int x, int len)
```

Stores a signed `len`-bit integer `x` in builder `b`. Returns the modified builder.

#### `store_uint`

```func
builder store_uint(builder b, int x, int len)
```

Stores an unsigned `len`-bit integer `x` in builder `b`. Returns the modified builder.

#### `~store_int`

```func
(builder, ()) ~store_int(builder b, int x, int len)
```

Same as [`store_int`](#store-int), but adapted to use [modifying notation](/languages/func/expressions#modifying-notation).

#### `~store_uint`

```func
(builder, ()) ~store_uint(builder b, int x, int len)
```

Same as [`store_uint`](#store-uint), but adapted to use [modifying notation](/languages/func/expressions#modifying-notation).

#### `load_bits`

```func
(slice, slice) load_bits(slice s, int len)
```

Loads the first `len` bits from slice `s`. It returns the modified slice and a slice containing the loaded bits.

#### `preload_bits`

```func
slice preload_bits(slice s, int len)
```

Loads the first `len` bits from slice `s`. It returns a slice containing the loaded bits. This method does not modify slice `s`.

#### `int_at`

```func
int int_at(tuple t, int index)
```

Returns the element at index `index` in tuple `t`, casted as an integer.

<Aside
  type="danger"
>
  It is responsibility of the programmer to check that the returned element is actually an integer.
</Aside>

#### `cell_at`

```func
cell cell_at(tuple t, int index)
```

Returns the element at index `index` in tuple `t`, casted as a cell.

<Aside
  type="danger"
>
  It is responsibility of the programmer to check that the returned element is actually a cell.
</Aside>

#### `slice_at`

```func
slice slice_at(tuple t, int index)
```

Returns the element at index `index` in tuple `t`, casted as a slice.

<Aside
  type="danger"
>
  It is responsibility of the programmer to check that the returned element is actually a slice.
</Aside>

#### `tuple_at`

```func
tuple tuple_at(tuple t, int index)
```

Returns the element at index `index` in tuple `t`, casted as a tuple.

<Aside
  type="danger"
>
  It is responsibility of the programmer to check that the returned element is actually a tuple.
</Aside>

#### `at`

```func
forall X -> X at(tuple t, int index)
```

Returns the element at index `index` in tuple `t`. The returned element can be of any type.

#### `touch`

```func
forall X -> X touch(X v)
```

Moves variable `v` to the top of the stack.

#### `~touch`

```func
forall X -> (X, ()) touch(X v)
```

`~touch` is identical to [`touch`](#touch), but adapted to use [modifying notation](/languages/func/expressions#modifying-notation).

#### `touch2`

```func
forall X, Y -> (X, Y) touch2((X, Y) t)
```

Moves the components of the tensor `t` to the top of the stack; first component `X` and then component `Y`.

#### `~touch2`

```func
forall X, Y -> ((X, Y), ()) ~touch2((X, Y) t)
```

`~touch2` is identical to [`touch2`](#touch2), but adapted to use [modifying notation](/languages/func/expressions#modifying-notation).

#### `~dump`

```func
forall X -> (X, ()) ~dump(X value)
```

Outputs value `value` to the debug log.

#### `~strdump`

```func
forall X -> (X, ()) ~dump(X value)
```

Outputs to the debug log the `value` interpreted as a slice containing an ASCII string.
