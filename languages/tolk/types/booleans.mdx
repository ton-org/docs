---
title: "Booleans"
---

import { Aside } from '/snippets/aside.jsx';

Tolk has a `bool` type with two values: `true` or `false`.

However, TVM does not have booleans as a distinct type. Instead, `true` is represented as a single bit 1, and `false` as a single bit 0.

<Aside
  type="caution"
>
  In the decimal system, the values of `true` and `false` are -1 and 0, respectively, because all integers on TVM are signed 257-bit ones.
</Aside>

```tolk
fun isGreater10(v: int): bool {
    return v > 10
}
```

Several operators, such as `==` or `&&` produce values of type `bool`. Many standard library functions also return `bool` values:

```tolk
var valid = isSignatureValid(...);    // bool
var end = someSlice.isEmpty();        // bool
```

## Logical operators accept both `int` and `bool`

- Operator `!x` supports both `bool` and `int`.
- The condition of `if` and similar statements accepts both `bool` and `int`, where it treats the latter as `true` if the value is not equal to 0, and as `false` otherwise.
- Logical operators `&&` and `||` accept both `bool` and `int`. For example, `a && b` evaluates to `true` when both operands are `true` or both operands are non-zero integers.

Arithmetic operators are restricted to integers.

```tolk
valid && end;  // ok
valid & end;   // ok, bitwise & | ^ also work if both are bools
if (!end)      // ok

valid + end;   // error
8 & valid;     // error, int & bool not allowed
```

## Logical and bitwise operators

Tolk has both bitwise `& ^ |` and logical `&& ||` operators that can be used for booleans and integers.

The main difference is that logical operators short-circuit: the right operand is evaluated only if required.

|      Expression      |                    Behavior                    |
| :------------------: | :--------------------------------------------: |
|   `condition & f()`  |             `f()` is called always             |
|  `condition && f()`  |  `f()` is called only if `condition` is `true` |
|  `condition \| f()`  |             `f()` is called always             |
| `condition \|\| f()` | `f()` is called only if `condition` is `false` |

The compiler performs better instruction optimizations on booleans, saving more gas per comparison.

Bitwise operators may sometimes be used instead of logical operators to avoid generating conditional branches at runtime. For example, `(a > 0) && (a < 10)`, when replaced with bitwise `&`, consumes less gas.

## Casting to `int` via `as` operator

No runtime transformations take place: at the TVM level, the `bool` type is always represented as an integer with a decimal value of either -1 or 0.

```tolk
// -1 or 0 in decimal or a single bit 1 or 0 in binary
var i = boolValue as int;
```

## Serialization

A boolean is [serialized](/languages/tolk/types/overall-serialization) as a single bit.
