---
title: "Auto packing to/from cells"
---

A short demo of auto serialization:

```tolk
struct Point {
    x: int8
    y: int8
}

fun demo() {
    var value: Point = { x: 10, y: 20 };

    // makes a cell containing "0A14"
    var c = value.toCell();
    // back to { x: 10, y: 20 }
    var p = Point.fromCell(c);
}
```

## Key features of auto-serialization

- Supports all types: unions, tensors, nullables, generics, atomics, ...
- Allows to specify serialization prefixes (particularly, opcodes)
- Allows to manage cell references and when to load them
- Granular control over error codes
- Unpacks data from a cell or a slice, mutate it or not
- Packs data to a cell or a builder
- Warns if data potentially exceeds 1023 bits
- More efficient than manual serialization

## List of supported types and how they are serialized

Follow [Overall: serialization](/languages/tolk/types/overall-serialization).

Some examples:

```tolk
struct A {
    f1: int8       // just int8
    f2: int8?      // maybe int8
    f3: address    // internal address
    f4: B          // embed fields of struct B
    f5: B?         // maybe B
    f6: coins      // used for money amounts

    r1: cell          // always-existing untyped ref
    r2: Cell<B>       // typed ref
    r3: Cell<int32>?  // optional ref that stores int32

    u1: int32 | int64   // Either
    u2: B | C           // also Either
    u3: B | C | D       // manual or autogenerated prefixes
    u4: bits4 | bits8?  // Maybe<bits4 | bits8>

    // even this works
    e: Point | Cell<Point>

    // rest of slice
    rest: RemainingBitsAndRefs
}
```

## Serialization prefixes and opcodes

Structures provide special syntax for declare "prefixes".
32-bit ones are typically called **opcodes** and used for messages (incoming and outgoing):

```tolk
struct (0x7362d09c) TransferNotification {
    queryId: uint64
    // ...
}
```

But prefixes are not restricted to be 32-bit: `0x000F` is a 16-bit prefix, `0b010` is 3-bit (binary).

Example of structures combined to a union, with comments:

```tolk
struct (0b001) AssetSimple {
    workchain: int8
    ptr: bits32
}

struct (0b1000) AssetBooking {
    orderId: uint64
}

type Asset = AssetSimple | AssetBooking // | ...

struct ProvideAssetMessage {
    // ...
    asset: Asset
}

fun demo() {
    // msg.asset is parsed as '001' + int8 + bits32 OR ...
    val msg = ProvideAssetMessage.fromSlice(s);

    // now, msg.asset is just a union
    match (msg.asset) {
        AssetSimple => {   // smart cast
            msg.asset.workchain;
            msg.asset.ptr;
        }
        // ... other variants
    }
    // or test with `is` operator
    if (msg.asset is AssetBooking) {
        // ...
    }
}
```

When serializing, everything also works as expected:

```tolk
val out: ProvideAssetMessage = {
    // will be serialized as: '001' + '00000011' + bits32
    asset: AssetSimple {
        workchain: 3,
        ptr: SOME_32_BITS
    }
}
```

Note that if a struct has a prefix, it does not matter whether it's inside any union or not.

```tolk
struct (0x00FF) MyData {
    // ...
}

fun demo() {
    MyData.fromSlice(s);  // expected to be '00FF...' (hex)
    data.toCell();        // '00FF...'
}
```

That's why, structs for outgoing messages (with 32-bit opcodes), being serialized, include opcodes in binary data.

## What can NOT be serialized

- `int` can't be serialized, it does not define binary width; use `int32`, `uint64`, etc.
- `slice`, for the same reason; use `address` or `bitsN`
- tuples, not implemented
- `A | B` if A has manual serialization prefix, B not (because it seems like a bug in code)
- `primitives | ... | structs` if structs have serialization prefixes (because it's not definite what prefixes to use for primitives)

Example of invalid:

```tolk
struct (0xFF) A {}
struct B {}   // forgot prefix

fun invalidDemo(obj: A | B) {
    // (it's better to fire an error than to generate '0'+'FF'+dataA OR '1'+dataB)
    obj.toCell();   // error: A has prefix, B not
}
```

## Error messages if serialization unavailable

If someone, by mistake, uses unsupported types, Tolk compiler will fire a meaningful error. Example:

```tolk
struct ExtraData {
    owner: address
    lastTime: int     // mistake is here
}

struct Storage {
    // ...
    more: Cell<ExtraData>
}

fun errDemo() {
    Storage.fromSlice("");
}
```

fires an error:

```
auto-serialization via fromSlice() is not available for type `Storage`
because field `Storage.more` of type `Cell<ExtraData>` can't be serialized
because type `ExtraData` can't be serialized
because field `ExtraData.lastTime` of type `int` can't be serialized
because type `int` is not serializable, it doesn't define binary width
hint: replace `int` with `int32` / `uint64` / `coins` / etc.
```

## Controlling cell references. Typed cells

Fields of a struct are serialized one be one.
The compiler does not reorder fields, create implicit references, etc.
Hence, when data should be placed in a ref, it's done explicitly.
Similarly, a developer controls, when exactly contents of that ref is loaded.

There are two types of references: typed and untyped.

```tolk
struct NftCollectionStorage {
    ownerAddress: address
    nextItemIndex: uint64
    content: cell                        // untyped
    nftItemCode: cell                    // untyped
    royaltyParams: Cell<RoyaltyParams>   // typed
}

struct RoyaltyParams {
    numerator: uint16
    denominator: uint16
    royaltyAddress: address
}
```

A call `NftCollectionStorage.fromSlice` (or fromCell) is processed as follows:

1. read address
1. read uint64
1. read three refs; do not unpack them: just load pointers to cells

Note, that `royaltyParams` is `Cell<T>`, not `T` itself. To access fields (`numerator` and others), manually unpack that ref:

```tolk
// error: field does not exist in type `Cell<RoyaltyParams>`
st.royaltyParams.numerator

// that's the way
val rp = st.royaltyParams.load();   // Cell<T> -> T
rp.numerator

// alternatively
val rp = RoyaltyParams.fromCell(st.royaltyParams);
```

And vice versa: when composing such a struct, a cell should be assigned there, not an object:

```tolk
val st: NftCollectionStorage = {
    ...
    // error
    royaltyParams: RoyaltyParams{ ... }
    // correct
    royaltyParams: RoyaltyParams{ ... }.toCell()
}
```

A method `T.toCell()` returns `Cell<T>`:

```tolk
val c = p.toCell();  // Point to Cell<Point>
val p2 = c.load();   // Cell<Point> to Point
```

So, typed cells are a powerful mechanism to express the contents of referenced cells.
Note that `Cell<address>` or even `Cell<int32 | int64>` is also okay, `T` is not restricted to structures.

When it comes to untyped cells — just `cell` — they also denote references, but don't denote their inner contents, don't have the `.load()` method.

It's just _some cell_, like code/data of a contract or an untyped nft content.

## Remaining data after reading

What happens if after `fromSlice` remaining data is left?

```tolk
// input is "0102FF"
Point.fromSlice(input);
```

Byte "01" for x, byte "02" for y, and the remaining "FF" — is it correct?

**By default, this is incorrect**. By default, functions `fromCell` and `fromSlice` ensure the slice end after reading.
In this case, exception 9 ("cell underflow") is thrown.

This behavior can be turned off with an option:

```tolk
Point.fromSlice(s, {
    assertEndAfterReading: false
})
```

## Custom serializers for custom types

Using type aliases, it's possible to override serialization behavior in case it can not be expresses in existing types:

```tolk
type MyString = slice

fun MyString.packToBuilder(self, mutate b: builder) {
    // custom logic
}

fun MyString.unpackFromSlice(mutate s: slice) {
    // custom logic
}
```

For examples, proceed to [Serialization of type aliases](/languages/tolk/types/overall-serialization#type-aliases).

## UnpackOptions and PackOptions

These structs control behavior of `fromCell`, `toCell`, and similar functions:

```tolk
MyMsg.fromSlice(s, {
    throwIfOpcodeDoesNotMatch: 0xFFFF
})
```

Serialization functions have the second optional parameter, actually:

```tolk
fun T.fromSlice(rawSlice: slice, options: UnpackOptions = {}): T;
```

When omitted, default options are used, which can be overridden as shown above.

For deserialization (`fromCell` and similar), there are now two available options:

| Field of UnpackOptions      | Description                                                                                                                                                                                                                                                                                                 |
| --------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `assertEndAfterReading`     | after finished reading all fields from a cell/slice, call `slice.assertEnd` to ensure no remaining data left; it's the default behavior, it ensures that you've fully described data you're reading with a struct; for struct `Point`, input `0102` is ok, `0102FF` will throw `excno` 9; **default: true** |
| `throwIfOpcodeDoesNotMatch` | this excNo is thrown if opcode doesn't match, e.g. for `struct (0x01) A` given input "88..."; similarly, for a union type, this is thrown when none of the opcodes match; **default: 63**                                                                                                                   |

For serialization (`toCell` and similar), there is now one option:

| Field of PackOptions  | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| --------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `skipBitsNValidation` | when a struct has a field of type `bits128` and similar (it's a slice under the hood), by default, compiler inserts runtime checks (get bits/refs count + compare with 128 + compare with 0); these checks ensure that serialized binary data will be correct, but they cost gas; however, if you guarantee that a slice is valid (for example, it comes from trusted sources), set this option to true to disable runtime checks; _note: `int32` and other are always validated for overflow without any extra gas, so this flag controls only rarely used `bitsN` types;_ **default: false** |

## Full list of serialization functions

Each of them can be controlled by `PackOptions` described above.

1. `T.toCell()` — convert anything to a cell. Example:

```tolk
contract.setData(storage.toCell());
```

Internally, a builder is created, all fields are serialized one by one, and a builder is flushed (beginCell() + serialize fields + endCell()).

2. `builder.storeAny<T>(v)` — similar to `builder.storeUint()` and others, but allows storing structures. Example:

```tolk
var b = beginCell()
       .storeUint(32)
       .storeAny(msgBody)  // T=MyMsg here
       .endCell();
```

## Full list of deserialization functions

Each of them can be controlled by `UnpackOptions` described above.

1. `T.fromCell(c)` — parse anything from a cell. Example:

```tolk
var st = MyStorage.fromCell(contract.getData());
```

Internally, a cell is unpacked to a slice, and that slice is parsed (c.beginParse() + read from slice).

2. `T.fromSlice(s)` — parse anything from a slice. Example:

```tolk
var msg = CounterIncrement.fromSlice(cs);
```

All fields are read from a slice immediately. If a slice is corrupted, an exception is thrown (most likely, `excode` 9 "cell underflow"). Note, that a passed slice is NOT mutated; its internal pointer is NOT shifted. To mutate it, like `cs.loadInt()`, consider calling `cs.loadAny<Increment>()`.

3. `slice.loadAny<T>` — parse anything from a slice, shifting its internal pointer. Similar to `slice.loadUint()` and others, but allows loading structures. Example:

```tolk
var st: MyStorage = cs.loadAny();     // or cs.loadAny<MyStorage>()
cs.loadAny<int32>();                  // = cs.loadInt(32)
```

Similar to `MyStorage.fromSlice(cs)`, but called as a method and mutates the slice. Note: `options.assertEndAfterReading` is ignored by this function, because it's actually intended to read data from the middle.

4. `slice.skipAny<T>` — skip anything in a slice, shifting its internal pointer. Similar to `slice.skipBits()` and others, but allows skipping structures. Example:

```tolk
struct TwoInts { a: int32; b: int32; }
cs.skipAny<TwoInts>();    // skips 64 bits
cs.skipAny<int32>();      // = cs.skipBits(32)
```

## Special type RemainingBitsAndRefs

It's a built-in type to get "all the rest" slice tail on reading. Example:

```tolk
struct JettonMessage {
     // ... some fields
     forwardPayload: RemainingBitsAndRefs
}
```

Then, after `JettonMessage.fromCell`, forwardPayload contains _everything left after reading fields above_. Essentially, it's an alias to a slice which is handled specially while unpacking:

```tolk
type RemainingBitsAndRefs = slice
```

## What if data exceeds 1023 bits

Tolk compiler calculates maximum size of every serializable type and warns if it potentially exceeds 1023 bits.
The developer should perform one of the actions:

1. either to suppress the error by placing an annotation above a struct; it means "okay, I understand"
1. or reorganize a struct by splitting into multiple cells

Why "potentially exceeds"? Because for many types, their size can vary:

- `int8?` is either one or nine bits
- `coins` is variadic: from 4 bits (small values) up to 124 bits
- etc.

So, given a struct:

```tolk
struct MoneyInfo {
    fixed: bits800
    wallet1: coins
    wallet2: coins
}
```

And trying to serialize it, the compiler prints an error:

```
struct `MoneyInfo` can exceed 1023 bits in serialization (estimated size: 808..1048 bits)
... (and some instructions)
```

Actually, two choices are available:

1. if `coins` values are expected to be relatively small, and this struct will 100% fit in reality; then, suppress the error using an annotation:

```tolk
@overflow1023_policy("suppress")
struct MoneyInfo {
    ...
}
```

2. or `coins` are expected to be billions of billions, so data really can exceed; in this case, extract some fields into a separate cell; for example, store 800 bits as a ref; or extract other 2 fields and ref them:

```tolk
// either extract the first field
struct MoneyInfo {
    fixed: Cell<bits800>
    wallet1: coins
    wallet2: coins
}

// or extract other 2 fields
struct WalletsBalances {
    wallet1: coins
    wallet2: coins
}
struct MoneyInfo {
    fixed: bits800
    balances: Cell<WalletsBalances>
}
```

A general advice: leave more frequently used fields directly and place less-frequent fields to another ref.
All in all, the compiler indicates on potential cell overflow, and it's a developer's choice how to overcome this.

Probably, in the future, there will be more policies (besides "suppress") — for example, to auto-repack fields. For now, it's absolutely straightforward.

## Integration with message sending

Auto-serialization is natively integrated with sending messages to other contracts.
The compiler automatically serializes body, detects whether it fits into a message cell, etc.

```tolk
val reply = createMessage({
    bounce: BounceMode.RichBounce,
    value: ton("0.05"),
    dest: senderAddress,
    body: RequestedInfo {     // auto-serialized
        ...
    }
});
reply.send(SEND_MODE_REGULAR);
```

Continue reading here: [Universal createMessage](/languages/tolk/features/message-sending).

## Not "fromCell" but "lazy fromCell"

Tolk has a special keyword `lazy` that is combined with auto-deserialization. The compiler will load not a whole struct, but only fields requested.

```tolk
struct Storage {
    isSignatureAllowed: bool
    seqno: uint32
    subwalletId: uint32
    publicKey: uint256
    extensions: dict
}

get fun getPublicKey() {
    val st = lazy Storage.fromCell(contract.getData());
    // <-- here "skip 65 bits, preload uint256" is inserted
    return st.publicKey
}
```

Continue reading here: [lazy loading, partial loading](/languages/tolk/features/lazy-loading).
