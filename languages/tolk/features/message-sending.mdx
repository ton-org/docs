---
title: "Sending messages"
---

Tolk has a high-level function `createMessage`. In practice, it's immediately followed by `send`:

```tolk
val reply = createMessage({
    bounce: BounceMode.NoBounce,
    value: ton("0.05"),
    dest: senderAddress,
    body: RequestedInfo { ... }
});
reply.send(SEND_MODE_REGULAR);
```

## Key features of `createMessage`

1. Supports extra currencies
1. Supports [`StateInit`](/foundations/messages/deploy) with automatic address computation
1. Supports workchains
1. Supports sharding (formerly `splitDepth`)
1. Integrated with auto-serialization of `body`
1. Automatically detects **body ref or not**
1. More efficient than handwritten code

## The concept is based on union types

There is a variety of interacting between contracts.

- sometimes, you "send to an address"
- ... but sometimes, you "build the address (builder) manually"
- sometimes, you compose `StateInit` from code+data
- ... but sometimes, you already have `StateInit` as a ready cell
- sometimes, you send a message to basechain
- ... but sometimes, you use a `MY_WORKCHAIN` constant everywhere
- sometimes, you just attach tons (msg value)
- ... but sometimes, you also need extra currencies
- etc.

**How to describe such a vast variety of options? The solution is union types!**

Let's start exploring this idea by looking at how extra currencies are supported.

## Extra currencies: union

In most cases, just attach msg value as tons:

```tolk
value: someTonAmount
```

But when extra currencies are needed, attach tons AND a dict:

```tolk
value: (someTonAmount, extraDict)
```

How does it work? Because the field `value` is a union:

```tolk
// how it is declared in stdlib
type ExtraCurrenciesDict = dict

struct CreateMessageOptions<TBody> {
    ...
    /// message value: attached tons (or tons + extra currencies)
    value: coins | (coins, ExtraCurrenciesDict)
```

That's it! Just attach tons OR tons with extra, and the compiler takes care of composing this into a cell.

## Destination: union

The same idea of union types spreads onto **destination** of a message.

```tolk
dest: someAddress,
dest: (workchain, hash)
```

It's either an address, OR (workchain + hash), OR ...:

```tolk
struct CreateMessageOptions<TBody> {
    ...
    /// destination is either a provided address, or is auto-calculated by stateInit
    dest: address |             // either just send a message to some address
          builder |             // ... or a manually constructed builder with a valid address
          (int8, uint256) |     // ... or to workchain + hash (also known as accountID)
          AutoDeployAddress;    // ... or "send to stateInit" aka deploy (address auto-calculated)
```

**That's indeed the TypeScript way** — but it works at compile-time!

## `StateInit` and workchains

Let's start from an example. A contract "jetton minter" deploys a "jetton wallet". Wallet's code and initial data are known:

```tolk
val walletInitialState: ContractState = {
    code: ...,   // probably, kept in minter's storage
    data: ...,   // zero balance, etc. (initial wallet's storage)
};
```

A minter needs to send a message to a wallet. But since it's unknown whether the wallet already exists on-chain, a message needs wallet's code+data attached: if a wallet doesn't exist, it's immediately initialized with that code. So, where a message should be sent to? What is **destination**? The answer is: **destination is the wallet's StateInit**. In TON, the address of a contract is — by definition — a hash of its initial state:

```tolk
// address auto-calculated, code+data auto-attached
dest: {
    stateInit: walletInitialState
}
```

To serve more complex tasks, configure additional fields:

```tolk
dest: {
    workchain: ...,     // by default, 0 (basechain)
    stateInit: ...,     // either code+data OR a ready cell
    toShard:   ...,     // by default, null (no sharding)
}
```

That's the essence of `AutoDeployAddress`. Here is how it's declared in stdlib:

```tolk
// declared in stdlib
struct AutoDeployAddress {
    workchain: int8 = BASECHAIN;
    stateInit: ContractState | cell;
    toShard: AddressShardingOptions? = null;
}
```

## Sharding: deploying "close to" another contract

The `createMessage` interface also supports initializing contracts in specific shards. Take, for example, sharded jettons — a jetton wallet should be deployed to the same shard as the owner's wallet.

In other words, the intention is:

- a jetton wallet must be **close to** the owner's wallet
- this _closeness_ is determined by a shard depth (syn. _fixed prefix length_, syn. _split depth_)

Let's illustrate it with numbers for `shard depth` = 8:

| Title                | Addr hash (256 bits) | Comment                              |
| -------------------- | -------------------- | ------------------------------------ |
| closeTo (owner addr) | `01010101...xxx`     | owner's wallet                       |
| shardPrefix          | `01010101`           | first 8 bits of closeTo              |
| stateInitHash        | `yyyyyyyy...yyy`     | calculated by code+data              |
| result (JW addr)     | `01010101...yyy`     | jetton wallet in same shard as owner |

That's how to do it:

```tolk
dest: {
    stateInit: walletInitialState,
    toShard: {
        closeTo: ownerAddress,
        fixedPrefixLength: 8
    }
}
```

Technically, **shard depth** must be a part of `StateInit` (besides code+data) — for correct initialization inside the blockchain. The compiler automatically embeds it.

But semantically, **shard depth** alone makes no sense. That's why **shard depth + closeTo** is a single entity:

```tolk
// how it is declared in stdlib
struct AutoDeployAddress {
    ...
    toShard: AddressShardingOptions? = null;
}

struct AddressShardingOptions {
    fixedPrefixLength: uint5;    // shard depth, formerly splitDepth
    closeTo: address;
}
```

## Body ref or not: compile-time calculation

In TON Blockchain, according to the specification, a message is a cell (flags, dest address, stateInit, etc.), and its _body_ can be either inlined into the same cell or can be placed into its own cell (and be a ref).

Fortunately, a developer shouldn't keep this in mind. Just pass `body`, and the compiler does all calculations:

```tolk
createMessage({
    ...
    body: RequestedInfo { ... }    // no `toCell`! just pass an object
});
```

The rules are the following:

1. if `body` is small, it's embedded directly into a message cell
1. if `body` is large or unpredictable, it's wrapped into a ref

Why not make a ref always? Because creating cells is expensive. Avoiding cells for small bodies is crucial for gas consumption.

Interestingly, whether the body is **small** is determined **at compile time** — no runtime checks are needed. How? Thanks to generics:

```tolk
fun createMessage<TBody>(options: CreateMessageOptions<TBody>): OutMessage;

struct CreateMessageOptions<TBody> {
    ...
    body: TBody;
}
```

Hence, when called as `body: RequestedInfo {...}`, then `TBody = RequestedInfo`, and the compiler estimates its size:

- it's **small** if its maximum size is less than 500 bits and 2 refs — then **no ref**
- it's **large** if >= 500 bits or >= 2 refs — then "ref"
- it's **unpredictable** if contains `builder` or `slice` inside — then **ref**

**Even if body is large/unpredictable, it can be force-inlined** by wrapping into a special type:

```tolk
// potentialy 620 bits (if all coins are billions of billions)
// by default, compiler will make a ref
struct ProbablyLarge {
    a: (coins, coins, coins, coins, coins)
}

val contents: ProbablyLarge = { ... };  // but you are sure: coins are small
createMessage({                         // so, you take the risks
    body: UnsafeBodyNoRef {             // and force "no ref"
        forceInline: contents,
    }

// here TBody = UnsafeBodyNoRef<ProbablyLarge>
```

If `body` is already a cell, it will be left as a ref, without any surprise:

```tolk
createMessage({
    body: someCell,       // ok, just a cell, keep it as a ref

// here TBody = cell
```

That's why, don't pass `body: someObj.toCell()`, pass just `body: someObj`, let the compiler take care of everything.

## Body is not restricted to structures

In practice, `createMessage` is used to send a message (sic!) to another contract — in the exact format as the receiver expects.

```tolk
struct (0xd53276db) Excesses {
    queryId: uint64;
}

val excessesMsg = createMessage({
   // ...
   body: Excesses {
       queryId: input.queryId,
   }
});
excessesMsg.send(SEND_MODE_IGNORE_ERRORS);
```

This works perfectly, as expected. But an interesting fact — this also works:

```tolk
// just an example, that even this would work
val excessesMsg = createMessage({
   ...
   body: (0xd53276db as int32, input.queryId)
});
excessesMsg.send(SEND_MODE_IGNORE_ERRORS);
```

Even this is okay, it is inferred as `createMessage<(int32, uint64)>(...)` and encoded correctly.

The example above just illustrates the power of the type system, no more.

## Body can be empty

Don't need any `body` at all? Just leave it out:

```tolk
createMessage({
    bounce: BounceMode.NoBounce,
    dest: somewhere,
    value: remainingBalance
});
```

A curious reader might ask, "what's the type of `body` here? How is it expressed in the type system?" The answer is: `void`.

Actually, `CreateMessageOptions` is declared like this:

```tolk
// declared in stdlib
struct CreateMessageOptions<TBody = void> {
    ...
    body: TBody;
}
```

Hence, if `body` is omitted, it leads to the default `TBody = never`. And by convention, fields having `never` type are not required in a literal. It's not that obvious, but it is definitely beautiful.

## Don't confuse `StateInit` and code+data, they are different

It's incorrect to say that **`StateInit` is code+data**, because in TON, a full `StateInit` cell contents is richer (consider `block.tlb`):

- it also contains fixed\_prefix\_length (formerly split\_depth),
- it also contains ticktock info
- it also contains a library cell
- code and data are actually optional

For instance, when sending a message to another shard, fixed\_prefix\_length is automatically set by the compiler (from `toShard.fixedPrefixLength`).

That's why a structure **code+data** is named `ContractState`, NOT `StateInit`:

```tolk
// in stdlib
struct ContractState {
    code: cell;
    data: cell;
}
```

And that's why a field `stateInit: ContractState | cell` is named **stateInit**, emphasizing that `StateInit` can be initialized automatically from `ContractState` (or can be a well-formed **rich** cell).

## Q: Why not send, but createMessage?

In other words: why the pattern `val msg = createMessage(...); msg.send(mode)`, why not `send(... + mode)`?

Typically, yes — a message is immediately send after composing it. But there are also advanced use cases:

- not just send, but send and estimate fees,
- or estimate fees without sending,
- or get a message hash,
- or save a message cell to storage for later sending,
- or even push it to an action phase.

So, composing a message cell and THEN doing some action with it is a more flexible pattern.

Moreover, following this pattern requires to give **a name** to a variable. Advice is not to name it "m" or "msg," but to give a descriptive name like "excessesMsg" or "transferMsg":

```tolk
val excessesMsg = createMessage({
    ...
});
excessesMsg.send(mode);
// also possible
excessesMsg.sendAndEstimateFee(mode);
```

This strategy makes the code **easier to read** later. While scanning the code, a reader sees: this is about excesses, this one is about burn notification, etc. As opposed to a potential `send(...)` function, hard to identify what _meaning_ is intended by the exact call.

## Q: Why not provide a separate deploy function?

In other words: why `stateInit` is a **destination**? Why not make a `deploy()` function that accepts code+data, and drop stateInit from a regular createMessage?

The answer lies in terminology. Yes, **attaching stateInit** is often referred to as **deployment**, but it's an inaccurate term. **TON Blockchain doesn't have a dedicated deployment mechanism.** A message is sent to some _void_  — and if this _void_ doesn't exist, but a way to initialize it (code+data) is provided — it's initialized immediately and accepts the message.

To emphasize the deployment, give it _a name_:

```tolk
val deployMsg = createMessage({
    ...
});
deployMsg.send(mode);
```

## Universal createExternalLogMessage

The philosophy is similar to `createMessage`. But **external outs** don't have **bounce**, no attached tons, etc. So, options for creating are different.

**Currently, external messages are used only for emitting logs (for viewing them in indexers).** But theoretically, they can be extended to **send messages to the offchain**.

Example:

```tolk
val emitMsg = createExternalLogMessage({
    dest: createAddressNone(),
    body: DepositEvent { ... }
});
emitMsg.send(SEND_MODE_REGULAR);
```

**Available options for external-out messages** are only `dest` and `body`, actually:

```tolk
struct CreateExternalLogMessageOptions<TBody = void> {
    /// destination is either an external address or a pattern to calculate it
    dest: any_address |     // either some valid external/none address (not internal!)
          builder |         // ... or a manually constructed builder with a valid external address
          ExtOutLogBucket;  // ... or encode topic/eventID in destination

    /// body is any serializable object (or just miss this field for empty body)
    body: TBody;
}
```

So, as for `createMessage` — just pass `someObject`, do NOT call `toCell()`, let the compiler decide whether it fits into the same cell or not. `UnsafeBodyNoRef` is also applicable.

**Emitting external logs, example 1**:

```tolk
struct DepositData {
    amount: coins;
    ...
}

val emitMsg = createExternalLogMessage({
    dest: ExtOutLogBucket { topic: 123 },   // 123 for indexers
    body: DepositData { ... }
});
emitMsg.send(SEND_MODE_REGULAR);
```

**Emitting external logs, example 2**:

```tolk
struct (0x12345678) DepositEvent {
    amount: coins;
    ...
}

createExternalLogMessage({
    dest: createAddressNone(),
    body: DepositEvent { ... }   // 0x12345678 for indexers
});
```

`ExtOutLogBucket` is a variant of a custom external address for emitting logs **to the outer world.** It includes some **topic** (arbitrary number), that determines the format of the message body. In the example above, a **deposit event** is emitted (reserving topic `deposit` = 123) — and external indexers will index emitted logs by destination address without parsing body.
