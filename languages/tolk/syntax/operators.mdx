---
title: "Operators"
---

Tolk provides standard operators for integers and booleans.

## Operator priority

From highest to lowest.

### Parenthesis `(` `)`
Groups expressions: `(1 + 2) * 3`; or creates [tensors](/languages/tolk/types/tensors): `pair = (1, 2)`.

### Square brackets `[` `]`
Creates typed [tuples](/languages/tolk/types/tuples): `[1, 2]`.

### Operator `lazy`

With [lazy loading](/languages/tolk/features/lazy-loading) the compiler loads only the accessed fields and skips the rest.

### Non-null assertion operator `!`
Skips the [nullability](/languages/tolk/types/nullable) check: `someVar!`.

### Unary operators `!` `~` `-` `+`
[Logical negation](/languages/tolk/types/booleans) `!x`, bitwise not `~x`, unary `-x` and `+x`.

### Operators `as` `is` `!is`
[Unsafe `as` cast](/languages/tolk/types/type-checks-and-casts) and checks for [union types](/languages/tolk/types/unions): `someVar is int`.

### Multiplicative `*` `/` `%` `^/` `~/`
Integer multiplication, division, modulo, ceiling-division, and rounding-division. All [integers](/languages/tolk/types/numbers) have 257-bit precision.

### Additive `+` `-`
Standard integer addition and subtraction.

### Shifts `<<` `>>` `^>>` `~>>`
Bitwise shifts, extended by ceiling-right and rounding-right.

### Comparison `==` `<` `>` `<=` `>=` `!=` `<=>`
Comparison operators. `<=>` is known as the spaceship or sign operator. Operators `==` and `!=` also work for several non-numeric types. For example, [addresses](/languages/tolk/types/address).

### Bitwise `&` `|` `^`
Standard bitwise operators, applicable to both integers and booleans.

### Logical `&&` `||`
[Short-circuit](/languages/tolk/types/booleans#logical-vs-bitwise-operators): the right operand is evaluated only when necessary.

### Assignment `=` `+=` `-=` and other
Assignment and augmented assignments.

### Ternary `... ? ... : ...`
Ternary expressions are available in [conditions](/languages/tolk/syntax/conditions-loops).

## Missing operators

Tolk does not support `i++` and `i--`. Use `i += 1` and `i -= 1` instead.

## Warnings on unexpected precedence

A common pitfall:

```tolk
if (flags & 0xFF != 0) {
    // ...
}
```

This does not check the lowest byte. It is parsed as `flags & (0xFF != 0)`, because `!= ` has higher precedence, as in C++.

To prevent such cases, the compiler reports an error:

```ansi
error: & has lower precedence than !=, probably this code won't work as you expected.
       Use parenthesis: either (... & ...) to evaluate it first, or (... != ...) to suppress this error.

   2 |     if (flags & 0xFF != 0) {
     |         ^^^^^^^^^^^^^^^^^
```
