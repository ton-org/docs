---
title: "Operators"
---

Tolk provides standard operators for integers and booleans.

## Operator priority

From highest to lowest:

### Parenthesis `(` `)`
Groups expressions: `(1 + 2) * 3`; or creates [tensors](/languages/tolk/types/tensors): `pair = (1, 2)`.

### Square brackets `[` `]`
Creates typed [tuples](/languages/tolk/types/tuples): `[1, 2]`.

### Operator `lazy`

See [lazy loading](/languages/tolk/features/lazy-loading).

### Non-null assertion operator `!`
Skips the nullability check: `someVar!`. See [nullable types](/languages/tolk/types/nullable).

### Unary operators `!` `~` `-` `+`
Logical negation `!x` (see [booleans](/languages/tolk/types/booleans)), bitwise not `~x`, unary `-x` and `+x`.

### Operators `as` `is` `!is`
[Unsafe `as` cast](/languages/tolk/types/type-checks-and-casts) and check a [union type](/languages/tolk/types/unions): `someVar is int`.

### Multiplicative `*` `/` `%` `^/` `~/`
Integer multiplication, division, modulo, ceiling-division, and rounding-division.
Note that all [integers](/languages/tolk/types/numbers) have 257-bit precision.

### Additive `+` `-`
Standard integer addition and subtraction.

### Shifts `<<` `>>` `^>>` `~>>`
Bitwise shifts, extended by ceiling-right and rounding-right.

### Comparison `==` `<` `>` `<=` `>=` `!=` `<=>`
Comparison operators. The last one is known as the "spaceship" or "sign" operator.
Operators `==` and `!=` work also for several non-numeric types (particularly, [addresses](/languages/tolk/types/address)).

### Bitwise `&` `|` `^`
Standard bitwise operators, applicable to both integers and booleans.

### Logical `&&` `||`
[Short-circuit](/languages/tolk/types/booleans#logical-vs-bitwise-operators): the right operand is evaluated only when necessary.

### Assignment `=` `+=` `-=` and other
Assignment and augmented assignments.

### Ternary `... ? ... : ...`
See [conditions and loops](/languages/tolk/syntax/conditions-loops).

## Missing operators

Tolk does not have `i++` and `i--`. Use `i += 1` and `i -= 1` instead.

## Warnings on potentially unexpected precedence

A common pitfall across many languages:

```tolk
if (flags & 0xFF != 0) {
    // ...
}
```

This does not check the lowest byte: it's parsed as `flags & (0xFF != 0)`,
because `!=` has higher priority (the same in C++ and other languages).

To prevent such problematic cases, the compiler triggers an error:

```ansi
error: & has lower precedence than !=, probably this code won't work as you expected.
       Use parenthesis: either (... & ...) to evaluate it first, or (... != ...) to suppress this error.

   2 |     if (flags & 0xFF != 0) {
     |         ^^^^^^^^^^^^^^^^^
```
