---
title: "Imports and name resolution"
---

import { Aside } from '/snippets/aside.jsx';

In practice, contract sources are split into multiple files.
A project containing multiple contracts shares the same codebase (messages, storage definitions, and related logic).
To use symbols in another file, that file must be imported.
Upon import, all its symbols become available.

## Import a file to access its symbols

For example, error codes are placed in `errors.tolk`:

```tolk
const ERR_ZERO_BALANCE = 123
// ...
```

To use it from `parse.tolk`, an explicit import is required:

```tolk
import "errors"

fun validate(balance: coins) {
    assert (balance > 0) throw ERR_ZERO_BALANCE;
}
```

<Aside
  type="tip"
  title={"An IDE inserts imports automatically"}
>
  Fortunately, when selecting items from auto‑completion, imports are inserted automatically.
  It works in both JetBrains and VSCode-based IDEs.
</Aside>

## All top‑level symbols must have unique names

Notice that no `export const ...` or `export fun ...` declarations needed.
All constants, functions, etc. are visible.
No module‑private symbols exist.

It means that **all symbols must have unique names**.

Having `fun log()` in multiple files results in a "duplicate declaration" error if both files are imported.

## Techniques to avoid name collisions

1. Use long, descriptive names for top-level symbols, especially in multi‑contract projects
   - Good: `ReturnExcessesBack`, `WalletStorage`
   - Bad: `Excesses`, `Storage`
1. Group integer constants to enums
1. Prefer methods to global-scope functions

## Prefer methods to functions

Methods do not collide because they are attached to distinct types:

```tolk
fun Struct1.validate(self) { /* ... */ }
fun Struct2.validate(self) { /* ... */ }
```

Methods are generally more convenient: `obj.someMethod()` looks nicer than `someFunction(obj)`:

```tolk
struct AuctionConfig {
    // ...
}

// NOT
// fun isAuctionConfigInvalid(config: AuctionConfig)
// BUT
fun AuctionConfig.isInvalid(self) {
    // ...
}
```

Same for static methods: `Auction.createFrom(...)` seems better than `createAuctionFrom(...)`.
A method without `self` is a static one:

```tolk
fun Auction.createFrom(config: cell, minBid: coins) {
    // ...
}
```

Static methods may also be used to represent various utility functions.
For example, standard functions `blockchain.now()` and others are essentially static methods of an empty struct.

```tolk
struct blockchain

fun blockchain.now(): int /* ... */;
fun blockchain.logicalTime(): int /* ... */;
```

In large projects, this technique may be used to emulate namespaces.

## Symbols that may be repeated across the project

When developing multiple contracts, each contract has its own file (compilation target).
They do not import one another; therefore,

- `onInternalMessage` and `onExternalMessage`
- `get fun`
- and other declarations in a contract file don't conflict with each other

```tolk
// file: a-contract.tolk
import "storage"
import "errors"

fun onInternalMessage(in: InMessage) {
    // ...
}

get fun name() {
    return "a"
}
```

```tolk
// file: b-contract.tolk
import "storage"
import "errors"

fun onInternalMessage(in: InMessage) {
    // ...
}

get fun name() {
    return "b"
}
```

Get methods conceptually belong to the scope of a specific contract.

Typically, in a multi-contract project, each contract file contains only

- its entrypoints,
- probably, a union with allowed messages,
- and little else; the remaining codebase is shared.

For instance, struct `SomeMessage`, outgoing for contract A, is incoming for contract B.
When deploying one contract from another, a storage struct must be known. And similar.

As a guideline, group messages / errors / utils / etc. in shared files,
and use only minimal declarations inside each `contract.tolk`.
