---
title: "FunC-to-Tolk converter"
sidebarTitle: "Converter"
---

import { Aside } from '/snippets/aside.jsx';

**The converter** may look like magic: any FunC project can be immediately transformed into Tolk with a single command:

```bash
npx @ton/convert-func-to-tolk contracts
```

[GitHub repo](https://github.com/ton-blockchain/convert-func-to-tolk).

## Key idea: transform and gradually modernize

1. Take a FunC project and apply the converter<br />
   \=> get a contract that "looks and feels" like FunC.

1. Refactor it with modern features, step by step, keeping green tests<br />
   \=> resulting in an idiomatic Tolk project for further development.

## Step 1: convert and make it compile

This is a **syntax-level converter** that assists in migrating contracts to Tolk.
It rewrites FunC code with 1:1 semantics, — emitting a Tolk version of a contract that remains very close to the FunC original.

Example input: [jetton-minter.fc](https://github.com/ton-blockchain/convert-func-to-tolk/blob/master/tests/inout/jetton-minter.fc).<br />
Example output: [jetton-minter.tolk](https://github.com/ton-blockchain/convert-func-to-tolk/blob/master/tests/inout/jetton-minter.fc.tolk).

The converted contract won't use modern Tolk features like structures, auto-serialization, or clean message composition.
But after some manual fixes, it compiles, runs, and passes tests.

<Aside
  type="caution"
  title={"A contract does not compile after conversion?"}
>
  Please, refer to a [GitHub repo](https://github.com/ton-blockchain/convert-func-to-tolk) — it contains common problems and provides ways to fix them.
</Aside>

**From there, the codebase can be gradually modernized** — step by step, while keeping it functional at every stage.

## Step 2: gradually refactor

- use the modern `onInternalMessage`, see [handling messages](/languages/tolk/features/message-handling)
- extract a `Storage` struct, with toCell/fromCell like in [examples](/languages/tolk/features/contract-storage)
- refactor incoming messages into [structs](/languages/tolk/syntax/structures-fields#serialization-prefixes-and-opcodes) with 32-bit opcodes — incrementally, one message at a time
- define a union of possible messages and [lazy](/languages/tolk/features/lazy-loading) match it
- extract outgoing messages into structs and [send](/languages/tolk/features/message-sending) them

<Aside
  type="tip"
  title={"Key idea: keep the tests running at every stage"}
>
  This is what makes the approach safe — confidently refactor and modernize the codebase without breaking anything.
</Aside>

## Where to find examples?

Examples: [Tolk vs FunC benchmarks](https://github.com/ton-blockchain/tolk-bench).
This repository contains several contracts migrated from FunC — preserving original logic and passing the same tests.

Explore the Git history to see how each contract was gradually rewritten, step by step.
