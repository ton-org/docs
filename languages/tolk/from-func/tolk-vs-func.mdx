---
title: "Tolk vs FunC"
---

import { Aside } from '/snippets/aside.jsx';

**FunC** is the first high-level language for writing smart contracts in TON.
For years, it was the only option.
Lots of production code was written in FunC, and it will always be alive on-chain and in developers' hearts.

**Tolk** replaces FunC with modern syntax, a robust type system, and built-in serialization — while generating efficient assembly code.
Released in 2025, now it is considered the primary language for the TON ecosystem.

## How to migrate from FunC to Tolk

1. Scan the list below to get the overall picture.
1. Explore the [tolk-bench repo](https://github.com/ton-blockchain/tolk-bench) as a source of reference contracts.
1. Use the [FunC-to-Tolk converter](/languages/tolk/from-func/converter) to migrate existing projects.

## Gas benchmarks

The [tolk-bench repository](https://github.com/ton-blockchain/tolk-bench) compares FunC and Tolk on several TEPs.

For every metric measured, **gas consumption reduced 30–50%**. Primarily it's a result of the language design.

## What Tolk and FunC have in common

Both languages **target into Fift assembler**.
Tolk is not "a wrapper" that transpiles to FunC — it has its own semantic and optimization kernel.

Both languages **work on TVM** after being compiled to bytecode.
TVM is a stack machine, imposing architectural and runtime restrictions.

Both languages **have IDE plugins**, although support for Tolk is way better:
JetBrains IDEs, VS Code, Cursor, Windsurf, etc.

Both languages **are available in blueprint** and other client-side tooling.
Command-line mode is also supported.

But all _language aspects_ are completely different — a huge list below.

## List of "Tolk vs FunC" differences

Tolk and FunC are completely different.
It's even inaccurate to compare them — the difference lies in the design, not in syntax.
Nevertheless, let's try to summarize the details.

### Tolk reminds TypeScript and Rust

- FunC: resembles C ("FunC" stands for "functional C")
- Tolk: resembles TypeScript, Rust, and Kotlin

```tolk
fun sum(a: int, b: int): int {
    return a + b;
}
```

See: [basic syntax](/languages/tolk/basic-syntax).

### Tolk has structures

- FunC: return long unnamed tensors such as `(int, slice, int, int)`
- Tolk: declare a struct, it's the same efficient

```tolk
struct Demo {
    previousValue: int256
    ownerAddress: address
    effectsCount: uint32
    totalAmount: coins
}
```

See: [structures](/languages/tolk/syntax/structures-fields).

### Automatic serialization

- FunC: manual bit-level work with builders and slices
- Tolk: declare a struct and call `fromCell` and `toCell`

```tolk
struct Point {
    x: int8
    y: int8
}

fun demo() {
    var value: Point = { x: 10, y: 20 };

    // makes a cell containing "0A14" (hex)
    var c = value.toCell();
    // back to { x: 10, y: 20 }
    var p = Point.fromCell(c);
}
```

Pay attention to the use of `int8`, `uint64`, `coins` — all of them are TVM integers (see [numbers](/languages/tolk/types/numbers)).

See: [automatic serialization](/languages/tolk/features/auto-serialization).

### Lazy loading

- FunC: for optimization, manual juggling with preloads and skips
- Tolk: the `lazy` keyword loads only requested fields skipping the rest

```tolk
get fun publicKey() {
    val st = lazy Storage.load();
    // <-- here "skip 65 bits, preload uint256" is inserted
    return st.publicKey
}
```

See: [lazy loading](/languages/tolk/features/lazy-loading).

### The `bool` type

- FunC: only integers, 'true' is `-1`, 'false' is `0`; `ifnot`
- Tolk: type `bool` and logical operators `&& || !` are supported

```tolk
if (trustInput || validate(input)) {
    // ...
}
```

See: [booleans](/languages/tolk/types/booleans).

### The `address` type

- FunC: only slices (binary data); parse and compare bits
- Tolk: type `address` with convenient methods and operator `==`

```tolk
if (in.senderAddress == storage.ownerAddress) {
    val workchain = storage.ownerAddress.getWorkchain();
    // ...
}
```

See: [address](/languages/tolk/types/address).

### Null safety

- FunC: any variable can hold `null`, which may lead to runtime errors
- Tolk: provides nullable types `T?`, null safety, and smart casts

```tolk
fun checkWithOptional(a: int, b: int?): bool {
    if (b == null) {
        return checkSingle(a);
    }
    return b >= 0 && checkDouble(a, b);
}
```

See: [nullability](/languages/tolk/types/nullable).

### Everything else in the type system

- FunC: several types exposing TVM primitives
- Tolk: a wide range of types, including unions, generics, and enums

```tolk
struct Container<T> {
    element: T?
}

struct Nothing

type Wrapper<T> = Nothing | Container<T>
```

See: [type system overview](/languages/tolk/types/list-of-types).

### Methods for any types

- FunC: global-scope functions only
- Tolk: both functions and methods — for structures and even primitives

```tolk
// no `self` — static method
fun Point.createZero(): Point {
    return { x: 0, y: 0 }
}

// has `self` — instance method
fun Point.sumCoords(self) {
    return self.x + self.y
}

// even for primitives: cells, integers, tuples, etc.
fun tuple.isEmpty(self) {
    return self.size() == 0
}
```

See: [functions and methods](/languages/tolk/syntax/functions-methods).

### No `impure` keyword

- FunC: once `impure` is forgotten, a call may be dropped
- Tolk: the compiler does not remove user function calls

```tolk
fun validate(input: SomeStruct) {
    // ...
}
```

### No `~tilde` methods

- FunC: `x~f()` and `x.f()` are different (mutating and not)
- Tolk: only the dot — a single, consistent way to call methods

```tolk
val delta = someSlice.loadUint(32);   // mutates someSlice
val owner = someSlice.loadAddress();
```

See: [mutability](/languages/tolk/syntax/mutability).

### Native maps over TVM dictionaries

- FunC: `m~idict_set_builder(1,32,begin_cell().store_uint(10,32))`
- Tolk: `m.set(1, 10)`

```tolk
var m: map<int8, int32> = createEmptyMap();
m.set(1, 10);
m.addIfNotExists(2, -20);
m.delete(2);   // now: [ 1 => 10 ]
```

See: [maps](/languages/tolk/types/maps).

### Modern message handling

- FunC: `() recv_internal(4 params)` and parse a message cell
- Tolk: `fun onInternalMessage(in)` and use `in.senderAddress`, etc.

```tolk
fun onInternalMessage(in: InMessage) {
    // internal non-bounced messages arrive here
    in.senderAddress;
    in.originalForwardFee;
    // and other fields
}

fun onBouncedMessage(in: InMessageBounced) {
    // bounced messages arrive here
}
```

See: [message handling](/languages/tolk/features/message-handling).

### No `if (op == OP_TRANSFER)` for opcodes

- FunC: `if-else` to route an incoming message based on `opcode`
- Tolk: use union types and pattern matching

```tolk
type MyMessage =
    | CounterIncBy
    | CounterReset
    // ...

fun onInternalMessage(in: InMessage) {
    val msg = lazy MyMessage.fromSlice(in.body);
    match (msg) {
        CounterIncBy => {
            // ...
        }
        CounterReset => {
            // ...
        }
        // ...
    }
}
```

See: [pattern matching](/languages/tolk/syntax/pattern-matching).

### No "ignore empty messages" pattern

- FunC: `recv_internal()` starts with `if (slice_empty?(...))`
- Tolk: just use `else` in match

```tolk
fun onInternalMessage(in: InMessage) {
    val msg = lazy MyMessage.fromSlice(in.body);
    match (msg) {
        CounterReset => { /* ... */ }
        // ... handle all variants of the union

        else => {
            // for example: ignore empty messages
            if (in.body.isEmpty()) {
                return
            }
            throw 0xFFFF
        }
    }
}
```

See: [lazy matching](/languages/tolk/features/lazy-loading#lazy-matching).

### Native message composition

- FunC: `store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)` etc.
- Tolk: `createMessage` that auto-detects body ref or not

```tolk
val reply = createMessage({
    bounce: BounceMode.NoBounce,
    value: ton("0.05"),
    dest: senderAddress,
    body: RequestedInfo { ... }
});
reply.send(SEND_MODE_REGULAR);
```

See: [message sending](/languages/tolk/features/message-sending).

### Native deployment and `StateInit`

- FunC: manually pack contract's code and data according to TL-B
- Tolk: `createMessage` auto-computes destination

```tolk
val deployMsg = createMessage({
    // address auto-calculated, code+data auto-attached
    dest: {
        stateInit: {
            code: contractCodeCell,
            data: emptyStorage.toCell(),
        },
        // optionally control workchains and sharding
    }
});
```

See: [message sending](/languages/tolk/features/message-sending).

### op::increase is not a valid identifier

- FunC: allows any symbols in identifiers, even `var 2+2 = ...` is ok
- Tolk: alphanumeric identifiers, `2+2` is `4`, as expected

```tolk
const OP_INCREASE = 0x12345678
```

See: [variables](/languages/tolk/syntax/variables).

### Small functions are inlined automatically

- FunC: prefer larger functions for reduced gas consumption
- Tolk: the compiler auto-inlines functions with zero overhead

```tolk
fun int.zero() {
    return 0
}

fun int.inc(mutate self, byValue: int = 1): self {
    self += byValue;
    return self;
}

fun main() {
    return int.zero().inc().inc()
}
```

is reduced to "return 2" in assembler:

```fift
main() PROC:<{
    2 PUSHINT
}>
```

Note: `inline` modifier in FunC works at the Fift level, it's sub-optimal due to extra stack permutations.
In Tolk, inlining works at the compiler level and is combined with constant folding.

See: [compiler optimizations](/languages/tolk/features/compiler-optimizations).

### Consecutive `builder.storeUint` are merged

- FunC: manually combine constant stores into `b.storeUint(0x18,6)`
- Tolk: merges `b.storeUint(...).storeUint(...)` if constant

```tolk
b.storeUint(0, 1)
 .storeUint(1, 1)
 .storeUint(1, 1)
 .storeUint(0, 1)
 .storeUint(0, 2)
```

is translated to just

```fift
b{011000} STSLICECONST
```

See: [compiler optimizations](/languages/tolk/features/compiler-optimizations).

### Standard library redesigned

Functions from `stdlib.fc` now use longer, descriptive naming:

|         FunC         |                Tolk               |
| :------------------: | :-------------------------------: |
|      `cur_lt()`      |     `blockchain.logicalTime()`    |
|       `car(l)`       |          `listGetHead(l)`         |
| `raw_reserve(coins)` | `reserveToncoinsOnBalance(coins)` |
|      `~dump(x)`      |          `debug.print(x)`         |

Many global-scope functions became methods for primitives:

|            FunC            |         Tolk        |
| :------------------------: | :-----------------: |
|      `s.slice_hash()`      |      `s.hash()`     |
|  `equal_slices_bits(a, b)` |   `a.bitsEqual(b)`  |
|       `t.tuple_len()`      |      `t.size()`     |
| `t~tpush(triple(x, y, z))` | `t.push([x, y, z])` |

String postfixes like `"..."c` became built-in functions:

|   FunC   |            Tolk           |
| :------: | :-----------------------: |
| `"..."c` |    `stringCrc32("...")`   |
| `"..."H` |   `stringSha256("...")`   |
| `"..."h` |  `stringSha256_32("...")` |
| `"..."a` |      `address("...")`     |
| `"..."s` | `stringHexToSlice("...")` |
| `"..."u` |  `stringToBase256("...")` |

See: [differences in a standard library](/languages/tolk/from-func/stdlib-fc).

### ... and of course — assembler functions

Regardless of being a high-level language, Tolk provides all low-level capabilities.
The code can still be written in a "FunC-style" with manual builders and slices,
exotic TVM instructions can still be used.

```tolk
@pure
fun incThenNegate(v: int): int
    asm "INC" "NEGATE"
```

See: [assembler functions](/languages/tolk/features/asm-functions).
