---
title: "Reserve coins"
---

_Reserving coins_ is one of the four actions that a smart contract can perform during the [action phase](/foundations/phases#action-phase). In TVM it is implemented via the [`RAWRESERVE`](/tvm/instructions#fb02-rawreserve)
instruction that takes from the stack an `amount` of nanotoncoins to reserve and an integer `mode` specifying a way of the reservation.
The reservation action is queued to the _output action list_ of a smart contract, which contains other actions such as _message sends_.

Roughly speaking,  the `RAWRESERVE` instruction is equivalent to creating an outbound message carrying the specified `amount` of nanotoncoin to oneself.
But unlike a regular message send, the reservation action does not create a new message and does not incur any action costs.
Its primary goal is to reduce the amount of toncoins that can be spent by subsequent actions.

The `mode` parameter is a bitmask that specifies how the reservation amount is calculated. The resulting mode value can have the following base modes:

| Mode value | Convenient name    | Description                                             |
| ---------: | :----------------- | ------------------------------------------------------- |
|        $0$ | `ReserveExact`     | Reserves exactly the specified `amount` of nanotoncoin. |
|        $1$ | `ReserveAllExcept` | Reserves all but the specified `amount` of nanotoncoin. |
|        $2$ | `ReserveAtMost`    | Reserves at most the specified `amount` of nanotoncoin. |

Additionally, the resulting `mode` can have the following optional flags added:

| Flag value | Convenient name             | Description                                                                                                                           |
| ---------: | :-------------------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
|       $+4$ | `ReserveAddOriginalBalance` | Increases the `amount` by the original balance (i.e. without incoming message value) of the current account before the compute phase. |
|       $+8$ | `ReserveInvertSign`         | Negates the `amount` value before performing the reservation.                                                                         |
|      $+16$ | `ReserveBounceIfActionFail` | Bounces the transaction if the reservation fails.                                                                                     |

Below we describe how the reservation action is implemented. If you just want to see examples when the reservation is used in practice and how to solve related tasks, go to the [reserve patterns](/patterns/reserve) page.

## Implementation

The current implementation of the reservation is complex. In this section, we will discuss the reservation flow and what errors can occur during it.

But first, let's fix a notation:

- `amount` - the amount of toncoins passed to the `RAWRESERVE` instruction.
- `mode` - the integer mode passed to the `RAWRESERVE` instruction.
- `original_balance`:
  - if after the storage phase, account's balance is less than the value of incoming message with bounce flag set to `false`, then `original_balance` is set to $0$;
  - otherwise, `original_balance` equals account's balance before the compute phase minus incoming message value.
- `remaining_balance` - account's balance before the reservation action.
- `reserve` - the final amount to be reserved.

### Flow

Bellow we outline the reservation flow step by step in order to give a full picture of how the reservation is implemented and how different modes interact with each other.

1. Check that `mode` has flag $16$:
   - if so, then in case of any failure the transaction will be bounced;
   - if not, then in case of any failure the reservation action will be just skipped.
1. Set `reserve` to `amount`.
1. Check that `mode` has flag $4$:
   1. If so, then check that `mode` has flag $8$:
      - if so, then set `reserve` to `original_balance - reserve`;
      - otherwise, increase `reserve` by `original_balance`.
   1. Otherwise, if `mode` has flag $8$, throw the error "invalid reserve mode".
1. Check that `mode` has flag $2$:
   - if so, then set `reserve` to `min(reserve, remaining_balance)`.
1. Check that `mode` has flag $1$:
   - if so, then set `reserve` to `remaining_balance - reserve`.
1. Set `remaining_balance` to `remaining_balance - reserve`.

If there were no errors during the flow, then the reservation action was successful, and the subsequent action can spent only at most the new `remaining_balance`.

For example, suppose that:

- `amount` = $0.1$ Ton;
- `mode` = $1 + 4 + 8$ (`ReserveAllExcept` + `ReserveAddOriginalBalance` + `ReserveInvertSign`);
- `original_balance` = $2$ Ton;
- `remaining_balance` = $3$ Ton.

Thus, at the end we will have `reserve` = $1.1$ Ton and `remaining_balance` = $1.9$ Ton.

### Errors

Except problems with unpacking the reserve action cell and some problem related to extra-currency, the following errors can occur during the reservation flow:

- If `mode` has flag $8$ but not flag $4$, then the error "invalid reserve mode" is thrown.
- If after step 3, `reserve` is negative, then the error $-1$ is thrown.
- Passing a negative `amount` also results in the error $-1$.
- If after step 4, `reserve` is greater than `remaining_balance`, then the error "not enough grams ($37$)" is thrown.

If the action had flag $16$, then in case of any of the above errors the whole transaction is bounced.
