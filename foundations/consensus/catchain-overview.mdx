---
title: "Catchain overview"
sidebarTitle: "Catchain overview"
---

import {Aside} from "/snippets/aside";

Catchain is a communication protocol between validators. It does not execute the consensus algorithm itself but prepares data required for the decision-making of a higher-level component: [BCP - Block Consensus Protocol](/foundations/consensus/bcp-overview)

## Проблема

В полностью ас любой участник сети может проверить, действительно ли такое сообщение существовало и получить его.инхронной системе при отправке сообщений нет никаких гарантий, что сообщение дойдёт. А если дойдёт, то не известно, в каком порядке. Даже если А отправляет 2 сообщения для Б, нет никаких гарантий порядка, в котором эти сообщения дойдут, если конечно они вообще дойдут. Более того, считается, что некоторые из акторов сети могут совершать Византийские ошибки. Требуется не допускать ситуации, при которой византийские узлы мешают функциональности системы.

## Вводные данны

Будем считать, что все участники сети известны в том смысле, что каждому участнику сети известен ADNL адрес любого другого участника сети и его публичный ключ. Таким образом, участники могут безопасно обмениваться сообщениями, шифруя или подписывая их своими приватными ключами. И подпись любого участника может быть проверена любым другим участником.

## Задачи протокола

Catchain помогает частично решить эту проблему. Он описывает
- как выбирать узлы "соседи"
- Описывает формат сообщений, у которых есть зависимости (другие сообщения)
- Описывает, как получать зависимости
- Как выявлять и наказывать те узлы в сети, которые мешают правильной работе сети

Основной задачей протокола является предоставление возможности отправки сообщений, которые явно зависят от других сообщений, отправленных, возможно, другим актором, возможно, собой. Более того, эти зависимости задаются таким образом, что узел, получивший сообщение, может скачать зависимости и проверить их валидность.

## Как выбирать узлы соседи

Catchain предполагает выбор пяти узлов - соседей, случайным образом, а так же их периодическое обновление (через случайный интервал от 60 до 120 секунд в текущей конфигурации). Важно понимать, что отношение "соседства" не является симметричным, то есть если B сосед A, это не значит что А сосед B и наоборот.

## Идентификация сообщений

Таким образом, сообщение в catchain можно уникально идентифицировать по паре значений — (отправитель; номер сообщения отправителя)

<Aside type="note">
  Строго говоря, один и тот же набор участников может участвовать в различных catchain раундах, поэтому к id сообщения добавляется id раунда, чтобы отличать сообщения из предыдущих раундов. Однако для упрощения обзорной статьи возможность создания различных раундов опускается.
</Aside>

Таким образом получается, что каждый актор должен сам индексировать свои сообщения и повышать счётчик. В силу того, что узлы могут быть Византийскими, требуется проверять, что узлы верно ведут свой счётчик.

### Проверка на разные блоки с одинаковым id

Если некий актор выпускает два различных по содержанию сообщения с id = (A; i), где i - номер сообщения, то такая ситуация называется форком. В таком случае, любой актор, заметивший это может сконструировать доказательство того, что такие 2 сообщения существовали. Учитывая, что публичные ключи всех участников известны, можно сконструировать доказательство, состоящее из id блока и двух подписей к нему. Это доказательство плохого поведения транслируется всем соседям в сети, а затем их соседям и так далее. Любой из честных участников сети, получивший доказательство, начинает игнорировать любые сообщения от узла A, а так же все сообщения, которые зависят от сообщений узла А.

<Aside title="tip">
  По оригинальной задумке, в случае применения Catchain для реализации консенсуса на блокчейне TON, доказательство форка может быть отправлено в смарт-контракт [Elector](/foundations/system#elector), однако данная идея так и не была реализована.
</Aside>

### Проверка на последовательные id

Считается, что любое сообщение (X; i), кроме, конечно, (X;0), зависит от (X;i-1). Если узел выпустить сообщение (X; i), а затем выпустить (X; i + j, j > 1), то честный узел, получивший данное сообщение, не сможет получить сообщение (X; i + j - 1), а значит не сможет обработать (X; i + j). Таким образом, пропуск id сообщений становится бессмысленным, т.к. сообщения, следующие за пропущенным, игнорируются всеми правильными узлами.


## Процесс получения зависимостей

Каждые 0.1 - 0.2 секунды узел выбирает трёх случайных соседей и запускает с ними синхронизацию. Синхронизация может выполняться двумя способами

- Отправка (в сжатом виде) информации об уже полученных сообщениях. Если у соседа есть блоки сообщения свежее, он их предоставляет.
- Таргетированная подкачка конкретных сообщений. Обычно применяется, если после общей синхронизации первым способом, остались какие-то пропущенные единичные зависимости.

## Шифрование

Стоит отметить, что все описанные выше действия происходят в так называемом [приватном оверлее ADNL](ссылка). Общий сессионный ключ не считается, вместо этого для каждой пары узлов считается собственный ключ, которым и шифруются тела сообщений. На практике это означает что стороннему наблюдателю в TON Blockchain нельзя читать сообщения валидаторов, которые они посылают друг-другу.
