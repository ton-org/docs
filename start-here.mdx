---
title: "Start here"
---

import { Aside } from "/snippets/aside.jsx";

This documentation is divided into several sections, with lower-level details appearing later in the list. For example, an existing standard contract may already solve the problem, so there may be no need to implement a new one.

|                        |                                                                                              |
| ---------------------- | -------------------------------------------------------------------------------------------- |
| Ecosystem              | Tools and libraries for developing on TON, and how to use them.                              |
| Payment processing     | Implementation guides for an exchange.                                                       |
| Standard contracts     | Working with most popular standardized contracts.                                            |
| Contract development   | Guides on developing smart-contracts.                                                        |
| Languages              | Reference documentation for TON-specific programming languages.                              |
| TON Virtual Machine    | Description of the low-level language that runs smart-contracts, and details of the runtime. |
| Blockchain foundations | Comprehensive description of the blockchain.                                                 |
| Contribute             | Documentation on writing this documentation.                                                 |

## The minimum

<Aside type="tip">
  This is a condensed description of TON. The rest of the documentation may assume that all of this is already known to the reader.
</Aside>

_TON_ is a [blockchain](https://en.wikipedia.org/wiki/Blockchain). It provides a distributed platform for hosting applications. Roughly speaking, it works as if it were a single server executing all the code. Such applications are called _smart-contracts_.

The platform runs on a set of servers, called _validators_, owned by individuals or organizations with a large stake in TON and [greatly interested](/ecosystem/staking/overview) in keeping the platform safe, fair, and operational.

_Toncoin_ is TON's primary [cryptocurrency](https://en.wikipedia.org/wiki/Cryptocurrency). It is used to pay for the execution of smart contracts, the storage of their data, and network traffic. Such payments are called [fees](/foundations/fees).

There are two copies of TON blockchain: mainnet and testnet.

_Mainnet_ is the "real" network. It's where actual payments in Toncoin are made. Applications use mainnet by default, and some don't even have an option to use other networks.

The other network is _testnet_, and it is used by TON developers to check that their applications work correctly before deploying them to mainnet. It uses "test coins" that barely have any value.

Each network is split into _workchains_ that can freely interact with each other, but their implementations may differ significantly.

At the moment, there are two workchains: _basechain_ (`0`) for regular use, and a very similar _masterchain_ (`-1`) for TON's internal [bookkeeping](/foundations/system). The masterchain follows mostly the same rules, except that using it is more expensive to limit the amount of traffic that interferes with TON's internals.

To be freely scalable, each workchain is split into _shards_. The number of shards is [determined dynamically](/foundations/shards) based on the current network load. Internally, every shard is implemented as a separate blockchain. Except for increased latency when messages are sent between distant shards, the effect on the user-facing code is minimal.

Physically, the blockchain runs on a network of servers, called [nodes](/ecosystem/node/overview). They interact via the _ADNL_ protocol. The physical layer mostly doesn't affect user-facing applications, as they usually use [servers](/ecosystem/api/overview) that proxy JSON HTTP requests into the ADNL network. The official version of such a proxy server is provided by the _liteserver_ software. There are public instances of liteserver, so developers are not required to host one on their own servers.

ADNL works over [TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol), so it's impossible to connect to ADNL from a web page. Browsers [intentionally](https://security.stackexchange.com/q/100827) do not provide an API to send arbitrary TCP traffic. Servers do not have this limitation, as they do not use a browser and can interact with the blockchain over either ADNL or HTTP.

![Statuses overview](/resources/images/states.png)

It's easiest to visualize the blockchain as a set of [accounts](/foundations/addresses/overview). Each account has an address and a status.

Over its lifetime, an account changes its [status](/foundations/status) among four values:

- `nonexist`: There wasn't a single operation with the account, or it was removed. It has neither a balance, nor code.
- `uninit`: If some Toncoin is transferred to an account, it now exists, but there is still no smart contract code on it. It now has a balance.
- `active`: After a deploy message (see below) with code and initial data is sent to an account, it becomes active and can process other messages. It now has a balance, code, and internal state.
- `frozen`: If an account is overdue on its storage fees, it will be frozen until the fees are paid. If the balance becomes too small, the account goes completely bankrupt, is removed, and ceases to exist.

The _code_ on an active account is a smart contract. The term _"contract"_ is often used for an account that holds the code.

[Internal address](/foundations/addresses/overview#internal-addresses) of an account is a 256-bit number and is usually [formatted](/foundations/addresses/formats) like this: `EQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPrHF`.

There are also [external addresses](/foundations/addresses/overview#external-addresses) for things outside the blockchain. In any situation where an external address is involved, a special "none" address may be provided.

![Blockchain overview](/resources/images/blockchain.png)

Addresses specify where [messages](/foundations/messages/overview) should be delivered. There are three types of messages:

- [internal](/foundations/messages/internal) messages are sent between accounts;
- [incoming external](/foundations/messages/external-in) messages are sent from code outside the blockchain to a contract;
- [outgoing external](/foundations/messages/external-out) messages are broadcast to the external network and can be read by anyone.

Every internal message should have some Toncoin attached to it so that it can pay for the cost of handling it. External messages cannot have Toncoin attached to them because they spend some of their time outside the blockchain, and only the blockchain can prove the transfer of Toncoin is correct.

Incoming external messages come from an external address, and outgoing external messages go to an external address.

The _state_ of the account changes only when it handles messages. Messages also change the account's balance. To have a state and a balance, and to handle messages, the account must be `active`.

Formally, a message is only an intent: it has a destination, possibly some Toncoin, and data. After the message is handled and all the necessary changes are made to the blockchain, the message is packed, along with a description of those changes, into a single packet of data, [transaction](/foundations/messages/ordinary-tx).

A message might also be a [deploy message](/foundations/messages/deploy) if it has contract code and its initial state (`StateInit`) attached. When such a message is sent, the hash of the code and initial state must match the destination address. If they do, the code and state are stored in the account at that address, and the account becomes active. Both the code and state stored in the account may change in the future, but its address will remain the same as when it was originally deployed.

Internal and incoming external messages execute the account's code. The code is interpreted by [TON Virtual Machine](/tvm/overview) (TVM). It is written in _bitcode_, a binary format specific to TVM. In the future, TVM might support multiple binary languages, _codepages_, but at the moment there is only codepage 0 (`CP0`).

Most development is done in the [Tolk](/languages/tolk/overview), a high-level programming language. Its compiler is included in the [Blueprint](/contract-dev/blueprint/overview) development environment and will be available to all projects created from the template.

Originally, [Fift](/languages/fift/overview), a Forth-like assembly language, and [FunC](/languages/func/overview), a C-like intermediate-level language, were used for contract development.

When execution [starts](/tvm/initialization), the message and current account state are provided to the code. By the end of execution, the destination account might change its state or code, or send internal or outgoing external messages.

The execution follows a procedure whose steps are called [phases](/foundations/phases). [Fees](/foundations/fees) are deducted during this process. Fees might be deducted from the account's balance or from the message, depending on the [mode](/foundations/messages/modes) of the message.

Execution cost is first measured in _gas_ units, then converted to Toncoin. This unit is separate so that if code execution becomes computationally cheaper (or more expensive), validators can vote to change the [price of gas](/foundations/config#param-20-and-21:-gas-prices) in Toncoin.

If something goes wrong, a non-zero [exit code](/tvm/exit-codes) might be returned, no changes to state or code are saved, and no further messages are sent.

![Trace overview](/resources/images/trace.png)

The only reason any code can be executed is when some account has received a message. Internal messages can only be sent by another contract executing some code, and that contract must have received a message from somewhere too. In the end, every message can be considered part of some _trace_: a tree of messages between accounts that starts with an incoming external message, continues with internal messages, and possibly ends with some outgoing external messages.

If an external service needs to extract data from the blockchain, it can call a [get method](/tvm/get-method): a handler of incoming external messages in the code of some account. It's called a "method" because it acts like one: the message provides its parameters, and its execution returns a value. Get methods cannot make any changes to the blockchain.

The other source is a [wallet](/standard/wallets/how-it-works). A wallet is an account with a specific kind of smart contract deployed on it, which can handle _transfer_ incoming external messages: requests to send an internal message to another account. There are several [implementations](/standard/wallets/comparison) of wallets, with varying extra functionality and protection. [`V5R1`](/standard/wallets/v5) is the latest official general-purpose wallet. The text below describes only the functionality common to most wallets.

A transfer message consists of a destination address and, optionally, an internal message, both serialized and signed with a private key. The wallet stores a public key and uses it to check that a transfer message was signed with the corresponding private key. If the check succeeds, it sends that internal message to the destination address. This ensures only the user (or a service) who knows the private key can use the wallet.

Private and public [keys](https://en.wikipedia.org/wiki/Public-key_cryptography) are generated in a program or service outside the blockchain and determine the address of the wallet account. Their text representation is called a [mnemonic](/standard/wallets/mnemonics).

Before the code of the wallet can be deployed on an account with an incoming external message, some other account has to transfer Toncoin to the wallet account. External messages cannot have any Toncoin attached to them, and otherwise there wouldn't be enough funds to pay fees to handle the message that deploys a wallet. This transfer to a new wallet account usually comes from an exchange or another user. In testnet, there is [a bot](/ecosystem/wallet-apps/web#add-funds-into-the-wallet) that sends test coins to an account for free.

Usually, a transfer message is sent without an internal message and only instructs the wallet to transfer some Toncoin to a destination address. This is the reason this type of smart contract is called a wallet.

An internal message might be a request to some other contract or even a deploy message that deploys code on other accounts. In this way, a wallet acts as a proxy between a user (or an external service) and the rest of the blockchain.

End users usually use [wallet apps](/ecosystem/wallet-apps/web) to create and use wallets. An exchange will usually create a wallet for a user as well.

The other [important types](/standard/tokens/overview) of contracts are

- [Jetton](/standard/tokens/jettons/overview) tokens roughly correspond to coins and allow developers to mint their own currency;
- [NFT](/standard/tokens/nft/overview) tokens are similar to tickets: unique items that can be sold;
- [SBT](/standard/tokens/nft/sbt) tokens are like medals: unique items that can be given to someone but can never be sold or transferred.

To interact with wallets, Jettons, and other contracts, data has to be sent through an ADNL or HTTP API into the network. There are several ways to connect:

- directly call the API, or
- use [an SDK](/ecosystem/sdks) that simplifies working with an API by wrapping its methods in a more user-friendly interface; the most popular TypeScript SDK for this is `@ton/ton`.

When an application has to use a wallet to prove the user's identity, it needs access to the wallet's private key. Giving arbitrary applications access to the private key is insecure, as they could perform arbitrary actions with the wallet. To address this, there is the [TON Connect](/ecosystem/ton-connect/overview) set of SDKs that provide interfaces

- for an application to perform an action through the wallet app;
- for a wallet app to handle these requests.

For example, Telegram apps use TON Connect to access a wallet that is integrated into Telegram.

All data on TON is stored as trees of [cells](/foundations/serialization/cells): the state of contracts, their code, and messages. Each cell stores up to 1023 bits of data and can have up to 4 _refs_ to other cells. Each cell has a hash computed from its bits and refs. Because the hash of a cell that directly or indirectly references itself would require knowing the same hash, creating cyclic data structures is impossible.

Standard serialization of such a data structure into a single binary string is the [bag of cells](/foundations/serialization/boc) (_BoC_). Compilers of smart-contract programming languages produce a BoC with code. When there is a need to store cells in a file or send them over the network, they are usually serialized into a BoC.

To tell other developers how a certain type of data is stored in cells, a [TL-B](/languages/tl-b/overview) schema language is used. Its purpose is similar to that of [protocol buffers](https://en.wikipedia.org/wiki/Protocol_Buffers) or [binary templates](https://en.wikipedia.org/wiki/010_Editor#Binary_Templates), but it provides more features for structuring data at the bit level.

There are libraries for assembling data structures out of cells. For TypeScript, the most popular one is [`@ton/core`](https://github.com/ton-org/ton-core).

The TL-B schemas for binary representations of messages, transactions, initial contract state, and most other data structures used by the blockchain can be found in the [`block.tlb`](https://github.com/ton-blockchain/ton/blob/master/crypto/block/block.tlb) file in the [TON monorepo](https://github.com/ton-blockchain/ton). TypeScript functions for serializing and deserializing them are provided by the [`@ton/core`](https://github.com/ton-org/ton-core) and [`@ton/ton`](https://github.com/ton-org/ton) libraries.

In general, a library that converts data structures between cells and the format native to a programming language, or allows calling contract methods as native functions of the language, is called a _wrapper_ or _binding_. For example, functions that deserialize Jetton-related cell data into TypeScript objects can be found in the [`assets-sdk`](https://github.com/ton-community/assets-sdk/blob/5285cd75a97acbb15999e7dfb3b8e4ec9e98b4ed/src/jetton/types/JettonBurnMessage.ts) library. Some high-level programming languages [can generate](/languages/tact) bindings from the contract's source code. The "rule of thumb" is that production-grade code should not include low-level manipulation of binary data, and should instead rely on a library with bindings. This reduces the chance of mistakes and ensures the code has more users. With widely reused code, there are more opportunities to detect mistakes, and they are more likely to be fixed quickly.

So, to interact with the blockchain, a couple of libraries are usually used: one that handles the connection to the blockchain and another that works with the specific type of data sent over that connection.

Not all computation has to be done _on-chain_, i.e., executed inside TVM and paid for with Toncoin. Computing and storing data on the blockchain is significantly more expensive than doing so on a regular CPU. Instead, much of the work can be done in _off-chain_ code, in a regular programming language, before or after sending a request to the blockchain. The recommended development practice is to write a TypeScript library that calls contracts implemented in Tolk.

An [explorer](/ecosystem/explorers/overview) is a type of web app that displays information about the current state of accounts (including wallets, Jettons, and NFTs) and the history of transactions.

Many popular contract types have been standardized in [TON Enhancement Proposals](https://github.com/ton-blockchain/TEPs) (_TEP_), mostly describing expected contract interfaces with TL-B schemas. This allows tooling to be reused between similar contracts. For example, explorers detect TEP-standardized contracts and display their binary messages in a user-friendly format.
