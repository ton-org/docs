---
title: "Start here"
---

This documentation is split into several sections, with lower-level details further down the list. For example, it's likely that an already existing standard contract might solve the problem, and there won't be a need to implement it.

- Ecosystem: Tools and libraries for developing on TON, and how to use them.
- Payment processing: Implementation guides for an exchange.
- Standard contracts: Working with most popular standardized contracts.
- Contract development: Guides on developing smart-contracts.
- Languages: Reference documentation for TON-specific programming languages.
- TON Virtual Machine: Description of the low-level language that runs smart-contracts, and details of the runtime.
- Blockchain foundations: Comprehensive description of the blockchain.
- Contribute: Documentation on writing this documentation.

## The minimum

<Aside type="tip">
  This is a condensed description of TON. The rest of the documentation might assume all of this is already known to the reader.
</Aside>

_TON_ is a [blockchain](https://en.wikipedia.org/wiki/Blockchain). It provides a distributed platform for hosting applications. Roughly, it works as if it was a single server executing all the code. Such applications are called _smart-contracts_.

Platform is running on a set of servers, _validators_, owned by individuals or organizations having a large stake in TON, and [greatly interested](/ecosystem/staking/overview) to keep the platform safe, fair, and operational.

_Toncoin_ is TON's primary [cryptocurrency](https://en.wikipedia.org/wiki/Cryptocurrency). It's used to pay for execution of smart-contracts, storage of their data, and network traffic. Such payments are called [fees](/foundations/fees).

There are two official copies of TON blockchain: mainnet and testnet.

_Mainnet_ is the "real" network. It's where actual payments in Toncoin are made. Applications use mainnet by default, and some don't even have an option to use other networks.

The other network is _testnet_, and it's used by TON developers to check that their applications work correctly before deploying them to mainnet. It uses "test coins" for payments that barely have any value.

To have several blockchains that are not binary-compatible, or backward-compatible in case of migrations, every network is split into _workchains_. Workchains can freely interact with each other, but their implementations might significantly differ.

At the moment, there are two workchains: _basechain_ (`0`) for regular use, and a very similar _masterchain_ (`-1`) for TON's internal [bookkeeping](/foundations/system). Masterchain has mostly the same rules, except using it is more expensive to limit amount of traffic that interferes with TON's internals.

To be freely scalable, each workchain is split into _shards_. Number of shards is [determined dynamically](/foundations/shards), based on current network load. Internally every shard is implemented as a separate blockchain. Except for increased latency when messages are sent between distant shards, the effect on the user-facing code is minimal.

Physically blockchain is run on a network of servers, [_nodes_](/ecosystem/node/overview). They interact via the _ADNL_ protocol. Physical layer mostly doesn't affect user-facing applications, as they usually use [servers](/ecosystem/api/overview) that proxy JSON HTTP requests into ADNL network. The official version of such a proxy server is run by _liteserver_ software. There are public instances of liteserver, so developers are not required to host one on their server.

ADNL works over [TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol), so it's impossible to connect to ADNL from a web page. Browsers [intentionally](https://security.stackexchange.com/q/100827) do not have an API to send arbitrary TCP traffic. Servers do not have this problem, as they don't use a browser, and can interact with the blockchain both over ADNL or HTTP.

![Statuses overview](/resources/images/states.png)

It's easiest to visualize the blockchain as a set of [_accounts_](/foundations/addresses/overview). Each account has an address and status.

Over lifetime account changes its [_status_](/foundations/status) between four values:

- `nonexist`: There wasn't a single operation with an account, or it was removed. It has neither balance, nor code.
- `uninit`: If some Toncoin is transferred to an account, it now exists, but there's still no smart contract code on it. Now it has balance.
- `active`: After a deploy message (see below) with code and initial data is sent to an account, it becomes active, and can process other messages. Now it has balance, code, and internal state.
- `frozen`: If account is overdue on its storage fees, it will become frozen until they're either paid, or it goes completely bankrupt, is removed, and ceases to exist.

The _code_ on an active account is a (copy of a) smart contract. The term _"contract"_ is often used for the account that holds the code.

[_Internal address_](/foundations/addresses/overview#internal-addresses) is a 256-bit number of an account, and is usually [formatted](/foundations/addresses/formats) like this: `EQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPrHF`.

There are also [_external addresses_](/foundations/addresses/overview#external-addresses) for things outside of blockchain. In any situation where an external address is involved, a special "none" address might be provided.

![Blockchain overview](/resources/images/blockchain.png)

Addresses are used to tell where [_messages_](/foundations/messages/overview) should go. There are three types of messages:

- [_internal_](/foundations/messages/internal) messages are sent between accounts;
- [_incoming external_](/foundations/messages/external-in) messages are sent from code outside the blockchain to a contract;
- [_outgoing external_](/foundations/messages/external-out) messages are broadcasted to the outside network, and can be read by anyone.

Every internal message should have some Toncoin attached to it, so that it can pay for the cost of handling it. External messages cannot have Toncoin attached to them, because they spend some of the time outside the blockchain, and only blockchain can prove correct transfer of Toncoin.

Incoming external messages come from an external address, and outgoing external messages are sent to an external address.

_State_ of the account only changes when it handles messages. Also messages change the balance on the account. To have a state and a balance, and to handle messages, account must be `active`.

Formally, a message is only an intent: it has a destination, probably some Toncoin and data. After the message was handled, and all the necessary changes were made to blockchain, message is packed along with description of those changes into a single packet of data, [_transaction_](/foundations/messages/ordinary-tx).

A message might also be a [_deploy message_](/foundations/messages/deploy) if it has contract code and its initial state (`StateInit`) attached. When such message is sent, a hash of code and initial state should match a destination address. If they do, code and state are stored into an account at that address, and the account becomes active. Both code and state stored in the account might change in the future, but its address will stay the same as computed when it was deployed.

Internal and incoming external messages execute code of the account. Code is interpreted by [_TON Virtual Machine_](/tvm/overview) (TVM). It's written in _bitcode_, a binary format specific to TVM. In future, TVM might support multiple binary languages, _codepages_, but at the moment there is only codepage 0 (`CP0`).

Most of development is done in [_Tolk_](/languages/tolk/overview) high-level programming language. Its compiler is included in [_Blueprint_](/contract-dev/blueprint/overview) development environment, and will be available to all the projects created from the template.

Originally, [_Fift_](/languages/fift/overview), a Forth-like assembly language, and [_FunC_](/languages/func/overview), a C-like intermediate-level language, were used for contract development.

When execution [starts](/tvm/initialization), the message and current account state are provided to the code. By the end of execution, destination account might change its state or code, or send some internal or outgoing external messages.

The execution follows a procedure, its steps are called [_phases_](/foundations/phases). [_Fees_](/foundations/fees) are deducted during this process. Fee might be deducted from account's balance and/or from the message, depending on the [_mode_](/foundations/messages/modes) of the message.

Execution cost is first measured in _gas_ units, then converted to Toncoin. This unit is separate, so that if code execution becomes computationally cheaper (or more expensive), validators could vote to change the [price of gas](/foundations/config#param-20-and-21:-gas-prices) in Toncoin.

If something went wrong, a non-zero [_exit code_](/tvm/exit-codes) might be returned, no changes to state or code are saved, and no further messages are sent.

![Trace overview](/resources/images/trace.png)

The only reason any code can be executed is when some account have got the message. Internal message can only be sent by another contract executing some code, and that contract had to get a message from somewhere too. In the end, every message can be considered a part of some _trace_: a tree of messages between accounts that starts with an incoming external message, continues with internal messages, and possibly ends with some outgoing external messages.

If some external service needs to extract data from blockchain, they can call a [_get method_](/tvm/get-method): a handler of incoming external messages in the code of some account. It's called a "method" because it acts like one: the message provides its parameters, and its execution returns a value. Get methods cannot do any changes to the blockchain.

The other source is a [_wallet_](/standard/wallets/how-it-works). Wallet is an account with a specific kind of smart contract deployed on it, that can handle _transfer_ incoming external messages: requests to send an internal message to another account. There are several [implementations](/standard/wallets/comparison) of wallets, with varying extra functionality and protection. [`V5R1`](/standard/wallets/v5) is the latest official general-purpose wallet. Further text describes only the functionality common to most wallets.

A transfer message consists of a destination address and, optionally, an internal message, both serialized and signed with some private key. Wallet stores a public key, and uses it to check that a transfer message was signed with a corresponding private key. If the check succeeds, it sends that internal message to a destination address. This ensures only the user (or a service) who knows the private key can use the wallet.

Private and public [keys](https://en.wikipedia.org/wiki/Public-key_cryptography) are generated in a program or service outside of blockchain, and determine the address of the wallet account. Their text representation is called a [_mnemonic_](/standard/wallets/mnemonics).

Before the code of the wallet can be deployed on an account with an incoming external message, some other account has to transfer Toncoin to the wallet account. External messages cannot have any Toncoin attached to them, and otherwise there won't be enough funds to pay fees to handle the message that deploys a wallet. This transfer to a new wallet account usually comes from an exchange or another user. In testnet, there is a bot that sends test coins to an account for free.

Usually transfer message is sent without an internal message, and only tells to transfer some Toncoin to a destination address. This is the reason this type of smart contract is called a wallet.

Internal message might be a request to some other contract, or even be a deploy message that deploys code on other accounts. In this way, wallet acts as a proxy between a user (or an external service) and the rest of the blockchain.

End users usually use [_wallet apps_](/ecosystem/wallet-apps/web) to create and use wallets. An exchange would usually create a wallet for a user too.

The other [important types](/standard/tokens/overview) of contracts are

- [Jetton](/standard/tokens/jettons/overview) tokens, that roughly correspond to coins, and allow users to mint their own currency;
- [NFT](/standard/tokens/nft/overview), that are similar to tickets: unique items that can be sold;
- [SBT](/standard/tokens/nft/sbt), that are like medals: unique items that can be given to someone, but can never be sold or transferred.

To interact with wallets, Jettons and other contracts, data has to be sent through ADNL or HTTP API into the network. There are several ways to connect:

- directly call the API, or
- use [an SDK](/ecosystem/sdks) that simplifies working with an API by wrapping its methods into a more user-friendly interface; the most popular TypeScript SDK for this is `@ton/ton`.

When the application has to use a wallet to prove user's identity, it has to somehow get access to the private key of the wallet. Giving arbitrary applications access to the private key is insecure, as it can do arbitrary actions with the wallet then. To handle this, there is a [TON Connect](/ecosystem/ton-connect/overview) set of SDKs that provide interfaces

- for an application to do an action through the wallet app;
- for a wallet app to handle these requests.

For example, Telegram apps use TON Connect to get access to a wallet that is integrated into Telegram.

All data on TON stored as trees of [_cells_](/foundations/serialization/cells): state of contracts, their code, and messages. Each cell stores up to 1023 bits of data, and can have up to 4 _refs_ to other cells. Each cell has a hash computed from its bits and refs. Because hash of a cell that directly or indirectly has itself as a ref would require knowing the same hash, it's impossible to create cyclic data structures.

Standard serialization of such data structure into a single binary string is [bag of cells](/foundations/serialization/boc) (_BoC_). Compilers of smart-contract programming languages produce a BoC with code. When there is a need to store cells into a file, or send them over the network, it's usually serialized into a BoC.

To tell other developers how a certain type of data is stored in cells, a [_TL-B_](/languages/tl-b/overview) schema language is used. It's similar in its purpose to [protocol buffers](https://en.wikipedia.org/wiki/Protocol_Buffers) or [binary templates](https://en.wikipedia.org/wiki/010_Editor#Binary_Templates), but has more features for structuring data at the bit level.

There are libraries for assembling data structures out of cells. For TypeScript, the most popular is [`@ton/core`](https://github.com/ton-org/ton-core).

TL-B schema for binary representations for messages, transactions, initial contract state, and most other data structures used by blockchain can be found in [`block.tlb`](https://github.com/ton-blockchain/ton/blob/master/crypto/block/block.tlb) file in the [TON monorepo](https://github.com/ton-blockchain/ton). TypeScript functions for serializing and deserializing them are provided by [`@ton/core`](https://github.com/ton-org/ton-core) and [`@ton/ton`](https://github.com/ton-org/ton) libraries.

In general, the kind of library that converts data structures between cells and the format that is native to a programming language is called a _wrapper_ or _binding_. For example, functions that deserialize Jetton-related cell data to TypeScript objects can be found in [`assets-sdk`](https://github.com/ton-community/assets-sdk/blob/5285cd75a97acbb15999e7dfb3b8e4ec9e98b4ed/src/jetton/types/JettonBurnMessage.ts) library. Some high-level programming languages [can generate](/languages/tact) bindings out of source code of the contract. The "rule of thumb" is that production-grade code should not include low-level manipulation of binary data, and instead rely on a library with bindings instead. This reduces the chance of mistakes, and makes sure there are more users of this code. For a highly reused code, there are more opportunities to detect a mistake, and they're more likely to be fixed faster.

So, usually, to interact with blockchain, a couple of libraries should be used: one that handles the connection to the blockchain, and another to work with the specific type of data that is sent over the connection.

Not all of the computation has to be done _on-chain_, i.e. executed inside of TVM and paid with Toncoin. Computing and storing data on the blockchain is significantly more expensive than doing it on a regular CPU. Instead, a lot of it can be done in an _off-chain_ code, in a regular programming language, before or after it sends the request to the actual blockchain. The recommended development practice is to write a TypeScript library that calls contracts implemented in Tolk.

[_Explorer_](/ecosystem/explorers/overview) is a kind of web app that displays information about the current state of accounts (including wallets, Jettons, and NFTs) and history of transactions.

A lot of popular contract types were standardized in [TON Enhancement Proposals](https://github.com/ton-blockchain/TEPs) (_TEP_), mostly describing expected contracts' interfaces with TL-B schemas. This allows to reuse the tooling between similar contracts. For example, explorers detect TEP-standardized contracts, and display their binary messages in a user-friendly format.
