---
title: "Start here"
---

This is an absolute minimum of knowledge you'll need to make sense of the rest of this documentation.

_TON_ is a [blockchain](https://en.wikipedia.org/wiki/Blockchain). It provides a distributed platform for hosting applications. Roughly, it works as if it was a single server executing all the code. Such applications are called _smart-contracts_.

Platform is running on a set of servers, _validators_, owned by individuals or organizations having a large stake in TON, and greatly interested to keep the platform safe, fair, and operational.

_Toncoin_ is TON's primary [cryptocurrency](https://en.wikipedia.org/wiki/Cryptocurrency). It's used to pay for execution of smart-contracts, storage of their data, and network traffic. Such payments are called fees.

There are two official copies of TON blockchain: mainnet and testnet.

_Mainnet_ is the "real" network. It's where actual payments in Toncoin are made. Applications use mainnet by default, and some don't even have an option to use other networks.

The other network is _testnet_, and it's used by TON developers to check their applications work correctly before deploying them to mainnet. It uses "test coins" for payments that barely have any value.

To have several blockchains that are not binary-compatible, or backward-compatible in case of migrations, every network is split into _workchains_. Workchains can freely interact with each other, but their implementations might significantly differ.

At the moment, there are two workchains: _basechain_ (`0`) for regular use, and a very similar _masterchain_ (`-1`) for TON's internal bookkeeping. Masterchain has mostly the same rules, except using it is made more expensive to limit amount of traffic that interferes with TON's internals.

To be freely scalable, each workchain is split into _shards_. Number of shards is determined dynamically, based on current network load. Internally every shard is implemented as a separate blockchain. Except for increased latency when messages are sent between distant shards, the effect on the user-facing code is minimal.

Physically blockchain is run on a network of servers, _nodes_. They interact via the _ADNL_ protocol. Physical layer mostly doesn't affect user-facing applications, as they usually use servers that proxy JSON HTTP requests into ADNL network. The official version of such a proxy server is run by _LiteServer_ software. There are public instances of LiteServer, so developers are not required to host one on their server.

ADNL uses TCP sockets to connect, so it's impossible to connect to ADNL from a web page. Browsers intentionally do not have an API to send arbitrary TCP traffic. Servers do not have this problem, as they don't use a browser, and can interact with the blockchain either through ADNL or HTTP.

![Statuses overview](/resources/images/states.png)

It's easiest to visualize the blockchain as a set of _accounts_. Each account has an address and status.

Over lifetime account changes its _status_ between four values:

- `nonexist`: There wasn't a single operation with an account, or it was removed. It has neither balance, nor code.
- `uninit`: If some toncoin is transferred to an account, it now exists, but there's still no smart contract code on it. Now it has balance.
- `active`: After a deploy message (see below) with code and initial data is sent to an account, it becomes active, and can process other messages. Now it has balance, code, and internal state.
- `frozen`: If account is overdue on its storage fees, it will become frozen until they're either paid, or it goes completely bankrupt, is removed, and ceases to exist.

The _code_ on an active account is a (copy of a) smart contract. The term _"contract"_ is often used for the account that holds the code.

_Internal address_ is a 256-bit number of an account, and is usually formatted like this: `EQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPrHF`.

There are also _external addresses_ for things outside of blockchain. In any situation where an external address is involved, a special "none" address might be provided.

![Blockchain overview](/resources/images/blockchain.png)

Addresses are used to tell where _messages_ should go. There are three types of messages:

- _internal_ messages are sent between accounts;
- _incoming external_ messages are sent from code outside the blockchain to a contract;
- _outgoing external_ messages are broadcasted to the outside network, and can be read by anyone.

Every internal message should have some Toncoin attached to it, so that it can pay for
the cost of handling it. External messages cannot have Toncoin attached to them, because
they spend some of the time outside the blockchain, and only blockchain can prove correct
transfer of Toncoin.

Incoming external messages come from an external address, and outgoing external messages are sent to an external address.

_State_ of the account only changes when it handles messages. Also messages change the balance
on the account. To have a state and a balance, and to handle messages, account must be active.

Formally, a message is only an intent: it has a destination, probably some Toncoin and data. After the message was handled, and all the necessary changes were made to blockchain, message is packed along with description of those changes into a single packet of data, _transaction_.

A message might also be a _deploy message_ if it has contract code and its initial state (`StateInit`) attached. When such message is sent, a hash of code and initial state should match a destination address. If they do, code and state are stored into an account at that address, and the account becomes active. Both code and state stored in the account might change in the future, but its address will stay the same as computed when it was deployed.

Internal and incoming external messages execute code of the account. Code is interpreted by _TON Virtual Machine_ (TVM). It's written in _bitcode_, a binary format specific to TVM. In future, TVM might support multiple binary languages, _codepages_, but at the moment there is only codepage 0 (`CP0`).

Most of development is done in _Tolk_ high-level programming language. Its compiler is included in _Blueprint_ development environment, and will be available to all the projects created from the template.

Originally, _Fift_, a Forth-like assembly language, and _FunC_, C-like intermediate-level language were used for contract development.

When execution starts, the message and current account state are provided to the code. By the end of execution, destination account might change its state or code, or send some internal or outgoing external messages.

The execution follows a procedure, its steps are called _phases_. _Fees_ are deducted during this process. Fee might be deducted from account's balance and/or from the message, depending on the _mode_ of the message.

Execution cost is first measured in _gas_ units, then converted to Toncoin. This unit is separate, so that if code execution becomes computationally cheaper (or more expensive), validators could vote to change the price of gas in Toncoin.

If something went wrong, a non-zero _exit code_ might be returned, no changes to state or code are saved, and no further messages are sent.

![Trace overview](/resources/images/trace.png)

The only reason any code can be executed is when some account have got the message. Internal message can only be sent by another contract executing some code, and that contract had to get a message from somewhere too. In the end, every message can be considered a part of some _trace_: a tree of messages between accounts that starts with an incoming external message, continues with internal messages, and possibly ends with some outgoing external messages.

If some external service needs to extract data from blockchain, they can call a _get method_: a handler of incoming external messages in the code of some account. It's called a "method" because it acts like one: the message provides its parameters, and its execution returns a value. Get methods cannot do any changes to the blockchain.

The other source is a _wallet_. Wallet is an account with a specific kind of smart contract deployed on it that can handle _transfer_ incoming external messages: requests to send an internal message to another account. There are several [implementations]() of wallets, with varying [extra functionality]() and protection. `V5R1` is the latest official general-purpose wallet. Further text describes only the functionality common to most wallets.

A transfer message consists of a destination address and, optionally, an internal message, both serialized and signed with some private key. Wallet stores a public key, and uses it to check that a transfer message was signed with a corresponding private key. If the check succeeds, it sends that internal message to a destination address. This ensures only the user (or a service) who knows the private key can use the wallet.

Private and public keys are generated in a program or service outside of blockchain, and determine the address of the wallet account. Their text representation is called a _mnemonic_.

Before the code of the wallet can be deployed on an account with an incoming external message, some other account has to transfer Toncoin to the wallet account. External messages cannot have any Toncoin attached to them, and otherwise there won't be enough funds to pay fees to handle the message that deploys a wallet. This transfer to a new wallet account usually comes from an exchange or another user. In testnet, there is a bot that sends test coins to an account for free.

Usually transfer message is sent without an internal message, and only tells to transfer some Toncoin to a destination address. This is the reason this type of smart contract is called a wallet.

Internal message might be a request to some other contract, or even be a deploy message that deploys code on other accounts. In this way, wallet acts as a proxy between a user (or an external service) and the rest of the blockchain.

End users usually use _wallet apps_ to create and use wallets. An exchange would usually create a wallet for a user too.

The other important types of contracts are

- _Jetton_ tokens, that roughly correspond to coins, and allow users to mint their own currency;
- _NFTs_, that are similar to tickets: unique items that can be sold;
- _SBTs_, that are like medals: unique items that can be given to someone, but can never be sold or transferred.

To interact with wallets, Jettons and other contracts, data has to be sent through ADNL or HTTP API into the network. There are several ways to connect:

- directly call the API, or
- use an SDK that simplifies working with an API by wrapping its methods into a more user-friendly interface; the most popular TypeScript SDK for this is `@ton/ton`.

When the application has to use a wallet to prove user's identity, it has to somehow get access to the private key of the wallet. Giving arbitrary applications access to the private key is insecure, as it can do arbitrary actions with the wallet then. To handle this, there is a _TON Connect_ set of SDKs that provide interfaces

- for an application to do an action through the wallet app;
- for a wallet app to handle these requests.

For example, Telegram apps use TON Connect to get access to a wallet that is integrated into Telegram.

All data on TON: data stored by contracts, their code, and messages are stored as trees of _cells_. Each cells stores up to 1023 bits of data, and can have up to 4 _refs_ to other cells. Each cell has a hash computed from its bits and refs. Because hash of a cell that directly or indirectly has itself as a ref would require knowing the same hash, it's impossible to create cyclic data structures.

Standard serialization of such data structure into a single binary string is bag of cells (_BoC_). Compilers of smart-contract programming languages produce a BoC with code. When there is a need to store cells into a file, or send them over the network, it's usually serialized into a BoC.

To tell other developers how a certain type of data is stored in cells, a _TL-B_ schema language is used. It's similar in its purpose to [protocol buffers](https://en.wikipedia.org/wiki/Protocol_Buffers) or [binary templates](https://en.wikipedia.org/wiki/010_Editor#Binary_Templates), but has more features for structuring data at the bit level.

There are libraries for assembling data structures out of cells. For TypeScript, the most popular is `@ton/core`.

TL-B schema for binary representations for messages, transactions, initial contract state, and most other data structures used by blockchain can be found in `block.tlb` file in the TON monorepo. TypeScript functions for serializing and deserializing them are provided by `@ton/core` and `@ton/ton` libraries.

In general, the kind of library that converts data structures between cells and the format that is native to a programming language is called a _wrapper_ or _binding_. For example, functions that deserialize Jetton-related cell data to TypeScript objects can be found in [`assets-sdk`](https://github.com/ton-community/assets-sdk/blob/5285cd75a97acbb15999e7dfb3b8e4ec9e98b4ed/src/jetton/types/JettonBurnMessage.ts) library. Some high-level programming languages [can generate](/languages/tact) bindings out of source code of the contract. The "rule of thumb" is that production-grade code should not include low-level manipulation of binary data, and instead rely on a library with bindings instead. This reduces the chance of mistakes, and makes sure there are more users of this code. For a highly reused code, there are more opportunities to detect a mistake, and they're more likely to be fixed faster.

So, usually, to interact with blockchain, a couple of libraries should be used: one that handles the connection to the blockchain, and another to work with the specific type of data that is sent over the connection.

Not all of the computation has to be done _on-chain_, i.e. executed inside of TVM and paid with Toncoin. Computing and storing data on the blockchain is significantly more expensive than doing it on a regular CPU. Instead, a lot of it can be done in an _off-chain_ code, in a regular programming language, before or after it sends the request to the actual blockchain. The recommended development practice is to write a TypeScript library that calls contracts implemented in Tolk.

_Explorer_ is a kind of web app that displays information about the current state of accounts (including wallets, Jettons, and NFTs) and history of transactions.

A lot of popular contract types were standardized in TON Enhancement Proposals (_TEP_), mostly describing expected contracts' interfaces with TL-B schemas. This allows to reuse the tooling between similar contracts. For example, explorers detect TEP-standardized contracts, and display their binary messages in a user-friendly format.
