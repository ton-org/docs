---
title: "Execution phases and fees"
---

import { FeePlayground } from '/snippets/feePlayground.jsx';
import { Aside } from '/snippets/aside.jsx';

# Transactions and phases

When an event occurs on an account in The Open Network (TON) blockchain, it triggers a **transaction**.  
The most common event is receiving a message, but other events like `tick-tock`, `merge`, and `split` can also initiate transactions.

Each transaction consists of up to five phases:

1. **Storage phase**: calculates storage fees for the contract based on the space it occupies in the blockchain state.
2. **Credit phase**: updates the contract balance by accounting for incoming message values and storage fees.
3. **Compute phase**: executes the contract code on the TON Virtual Machine (TVM). The result includes `exit_code`, `actions`, `gas_details`, `new_storage`, and other data.
4. **Action phase**: processes actions from the compute phase if it succeeds.  
Actions may include sending messages, updating contract code, or modifying libraries. If an action fails (for example, due to a lack of funds), the transaction may revert or skip the action, depending on its mode. For example, `mode = 0, flag = 2` means that any errors arising while processing this message during the action phase are ignored.
5. **Bounce phase**: if the compute or action phase ends with an error and the inbound message has the bounce flag set, this phase generates a bounce message.

## Compute phase

The compute phase involves executing the contract code on TVM.

<Aside type="note" title="Background">
See section 4.3.5 of the [TON whitepaper](/resources/pdfs/tblkch.pdf). It may include outdated information.
</Aside>

### When the compute phase is skipped

The compute phase may be skipped under certain conditions, such as when the account is missing, uninitialized, or frozen, or when the incoming message lacks code or data fields. These scenarios are represented by specific constructors:

- `cskip_no_state$00`: the account or message lacks a valid state,  
for example, [missing code or data](https://testnet.tonviewer.com/transaction/7e78394d082882375a5d21affa6397dec60fc5a3ecbea87f401b0e460fb5c80c).
- `cskip_bad_state$01`: the message contains an invalid state,  
for example, incorrect state for a frozen or uninitialized account.
- `cskip_no_gas$10`: the account lacks enough funds to cover gas costs.

# Fee calculation

Verify the attached Toncoin covers storage, import, compute, action, and forwarding fees. Then calculate the transaction fee.

<Aside type="note" title="Reference">
For a comprehensive list of TVM opcodes, refer to [TVM instructions](/tvm/instructions).
</Aside>

## Basic fees formula

Fees on TON are calculated using this formula:

Not runnable
```cpp
transaction_fee = storage_fees
                + in_fwd_fees // also called import fee
                + computation_fees
                + action_fees
                + out_fwd_fees
```

Example of a fee calculator logic:
```jsx expandable
// Check https://txtracer.ton.org/?tx=b5e14a9c4a4e982fda42d6079c3f84fa48e76497a8f3fca872f9a3737f1f6262

function FeeCalculator() {
  // Config param 25 (fees): https://tonviewer.com/config#25 â€” names mirror config fields
  const lump_price = 400000;
  const bit_price = 26214400;
  const cell_price = 2621440000;
  const ihr_price_factor = 98304;
  const first_frac = 21845;
  const nano = 10 ** -9;
  const bit16 = 2 ** 16;

  const ihr_disabled = 0; // First, define whether IHR will be counted

  let fwd_fee =
    lump_price + Math.ceil((bit_price * 0 + cell_price * 0) / bit16);

  let ihr_fee;
  if (ihr_disabled) {
    ihr_fee = 0;
  } else {
    ihr_fee = Math.ceil((fwd_fee * ihr_price_factor) / bit16);
  }

  let total_fwd_fees = fwd_fee + ihr_fee;
  let gas_fees = 0.0011976; // Gas fees are out of scope here
  let storage_fees = 0.000000003; // Storage fees as well
  let total_action_fees = +((fwd_fee * first_frac) / bit16).toFixed(9);
  let import_fee =
    lump_price + Math.ceil((bit_price * 528 + cell_price * 1) / bit16);
  let total_fee =
    gas_fees +
    storage_fees +
    // total_action_fees * nano + <- already included in total_fwd_fees
    import_fee * nano +
    total_fwd_fees * nano; // <- not included in explorer's total fee

  return (
    <div>
      <p> Total fee: {+total_fee.toFixed(9)} TON</p>
      <p> Action fee: {+(total_action_fees * nano).toFixed(9)} TON </p>
      <p> Fwd fee: {+(total_fwd_fees * nano).toFixed(9)} TON </p>
      <p> Import fee: {+(import_fee * nano).toFixed(9)} TON </p>
      <p> IHR fee: {+(ihr_fee * nano).toFixed(9)} TON </p>
    </div>
  );
}
```

### Fee calculator

<FeePlayground />


## Elements of the transaction fee

- `storage_fees` is the amount you pay for storing a smart contract on the blockchain. In fact, you pay for every second the smart contract is stored on the blockchain.
  - _Example_: your TON wallet is also a smart contract, and it pays a storage fee every time you receive or send a transaction.
- `in_fwd_fees` is a charge for importing messages only from outside the blockchain, for example, `external` messages. Every time you make a transaction, it must be delivered to the validators who will process it. For ordinary messages from contract to contract, this fee does not apply. Read [the TON Blockchain paper](/resources/pdfs/tblkch.pdf) to learn more about inbound messages.
  - _Example_: each transaction you make with your wallet app (like Tonkeeper) must first be distributed among validators.
- `computation_fees` is the amount you pay for executing code in the virtual machine. Computation fees depend on executed operations (gas used), not code size.
  - _Example_: each time you send a transaction with your wallet (which is a smart contract), you execute the code of your wallet contract and pay for it.
- `action_fees` is a charge for sending outgoing messages made by a smart contract, updating the smart contract code, updating libraries, etc.
- `out_fwd_fees` is a charge for forwarding outgoing internal messages within TON between shardchains; it depends on message size and routing via Hypercube Routing (HR) or Instant Hypercube Routing (IHR).

## Storage fee

### Overview

In short, storage fees are the costs of storing a smart contract on the blockchain. You pay for every second the smart contract remains stored on the blockchain.

Use the [`GETSTORAGEFEE`](/tvm/instructions) opcode.

<Aside type="note" title="Deduplication">
The system counts only unique hash cells for storage and forward fees. For example, it counts three identical hash cells as one. This mechanism deduplicates data by storing the content of multiple equivalent sub-cells only once, even if they are referenced across different branches. [Read more about deduplication](/tvm/serialization/library).
</Aside>

### Calculation flow

Each contract has its own balance. You can calculate how many TON your contract requires to remain valid for a specified `seconds` duration using the function:

```func wrap
int get_storage_fee(int is_mc, int seconds, int bits, int cells) asm(cells bits seconds is_mc) "GETSTORAGEFEE";
```

You can then hardcode this value into the contract and calculate the current storage fee using:

```func wrap
;; functions from the FunC stdlib
() raw_reserve(int amount, int mode) impure asm "RAWRESERVE";
int get_storage_fee(int is_mc, int seconds, int bits, int cells) asm(cells bits seconds is_mc) "GETSTORAGEFEE";
int my_storage_due() asm "DUEPAYMENT";

;; constants from stdlib
;;; Creates an output action which reserves exactly x nanotons (if y = 0).
const int RESERVE_REGULAR = 0;
;;; Creates an output action which reserves at most x nanotons (if y = 2).
;;; Bit +2 in y ensures the external action does not fail if the specified amount cannot be reserved. Instead, it reserves all remaining balance.
const int RESERVE_AT_MOST = 2;
;;; In the case of action failure, the transaction is bounced. No effect if RESERVE_AT_MOST (+2) is used. TVM UPGRADE 2023-07.
const int RESERVE_BOUNCE_ON_ACTION_FAIL = 16;

() calculate_and_reserve_at_most_storage_fee(int balance, int msg_value, int workchain, int seconds, int bits, int cells) inline {
 int on_balance_before_msg = my_ton_balance - msg_value;
 int min_storage_fee = get_storage_fee(workchain, seconds, bits, cells); ;; You can hardcode this value if the contract code will not be updated.
 raw_reserve(max(on_balance_before_msg, min_storage_fee + my_storage_due()), RESERVE_AT_MOST);
}
```

If `min_storage_fee` is hardcoded, **remember to update it** during the contract update process. Not all contracts support updates, so this is an optional requirement.

## Computation fee

### Overview

In most cases, use the [`GETGASFEE`](/tvm/instructions) opcode.

### Calculation flow

```func wrap
int get_compute_fee(int is_mc, int gas_used) asm(gas_used is_mc) "GETGASFEE";
```

But how do you determine `gas_used`? Through testing!

To calculate `gas_used`, you should write a test for your contract that:

1. Executes a transfer.
2. Verifies its success and retrieves the transfer details.
3. Checks the amount of gas the transfer uses for computation.

The contract's computation flow can depend on input data. You should run the contract in a way that maximizes gas usage. Ensure you are using the most computationally expensive path to test the contract.

```ts expandable
// Initialization code
const deployerJettonWallet = await userWallet(deployer.address);
let initialJettonBalance = await deployerJettonWallet.getJettonBalance();
const notDeployerJettonWallet = await userWallet(notDeployer.address);
let initialJettonBalance2 = await notDeployerJettonWallet.getJettonBalance();
let sentAmount = toNano("0.5");
let forwardAmount = toNano("0.05");
let forwardPayload = beginCell().storeUint(0x1234567890abcdefn, 128).endCell();
// Ensure the payload is unique to charge cell loading for each payload.
let customPayload = beginCell().storeUint(0xfedcba0987654321n, 128).endCell();

// Let's use this case for fee calculation
// Embed the forward payload into the custom payload to ensure maximum gas usage during computation
const sendResult = await deployerJettonWallet.sendTransfer(
  deployer.getSender(),
  toNano("0.17"), // TON
  sentAmount,
  notDeployer.address,
  deployer.address,
  customPayload,
  forwardAmount,
  forwardPayload
);
expect(sendResult.transactions).toHaveTransaction({
  // excesses
  from: notDeployerJettonWallet.address,
  to: deployer.address,
});
/*
transfer_notification#7362d09c query_id:uint64 amount:(VarUInteger 16)
 sender:MsgAddress forward_payload:(Either Cell ^Cell)
 = InternalMsgBody;
*/
expect(sendResult.transactions).toHaveTransaction({
  // notification
  from: notDeployerJettonWallet.address,
  to: notDeployer.address,
  value: forwardAmount,
  body: beginCell()
    .storeUint(Op.transfer_notification, 32)
    .storeUint(0, 64) // default queryId
    .storeCoins(sentAmount)
    .storeAddress(deployer.address)
    .storeUint(1, 1)
    .storeRef(forwardPayload)
    .endCell(),
});
const transferTx = findTransactionRequired(sendResult.transactions, {
  on: deployerJettonWallet.address,
  from: deployer.address,
  op: Op.transfer,
  success: true,
});

let computedGeneric: (transaction: Transaction) => TransactionComputeVm;
computedGeneric = (transaction) => {
  if (transaction.description.type !== "generic")
    throw "Expected generic transaction";
  if (transaction.description.computePhase.type !== "vm")
    throw "Compute phase expected";
  return transaction.description.computePhase;
};

let printTxGasStats: (name: string, trans: Transaction) => bigint;
printTxGasStats = (name, transaction) => {
  const txComputed = computedGeneric(transaction);
  console.log(`${name} used ${txComputed.gasUsed} gas`);
  console.log(`${name} gas cost: ${txComputed.gasFees}`);
  return txComputed.gasFees;
};

const send_gas_fee = printTxGasStats("Jetton transfer", transferTx);
```

## Forward fee

### Overview

TON charges a forward fee for outgoing messages.

Generally, there are three scenarios for forward fee processing:

1. The message structure is deterministic, and you can predict the fee.
2. The message structure depends heavily on the incoming message structure.
3. You cannot predict the outgoing message structure at all.

### Calculation flow

1. If the message structure is deterministic, use the [`GETFORWARDFEE`](/tvm/instructions) opcode.


<Aside type="note" title="Deduplication">
The system counts only unique hash cells for storage and forward fees. For example, it counts three identical hash cells as one. This mechanism deduplicates data by storing the content of multiple equivalent sub-cells only once, even if they are referenced across different branches. [Read more about deduplication](/tvm/serialization/library).
</Aside>

2. However, if the outgoing message depends significantly on the incoming structure, you may not be able to fully predict the fee. In such cases, try using the [`GETORIGINALFWDFEE`](/tvm/instructions) opcode.

3. The [`SENDMSG`](/tvm/instructions) opcode is the least optimal way to calculate fees, but it is better than not checking.

<Aside type="caution" title="Caution">
`SENDMSG` uses an unpredictable amount of gas.  
Prefer the methods above whenever possible.
</Aside>

Use it with a serialized message cell and a message mode.

Important modes when estimating with `SENDMSG`:

- **`+1024`**: Returns the estimated fee without creating an output action. Other modes will send a message during the action phase.
- **`+128`**: Substitutes the value of the entire contract balance before the computation phase begins. This is slightly inaccurate because gas expenses, which cannot be estimated before the computation phase, are excluded.
- **`+64`**: Substitutes the entire balance of the incoming message as the outgoing value. This is also slightly inaccurate, as gas expenses that cannot be estimated until the computation is completed are excluded.
- Refer to the [message modes cookbook](/ton/message-modes) for additional modes.

With modes other than `+1024`, it creates an output action and returns the fee for creating a message. With `+1024`, it only returns the estimated fee and does not create an output action. In all cases, it uses an unpredictable amount of gas, which cannot be calculated using formulas. To measure gas usage, use `GASCONSUMED`:

```func
int send_message(cell msg, int mode) impure asm "SENDMSG";
int gas_consumed() asm "GASCONSUMED";
;; ... some code ...

() calculate_forward_fee(cell msg, int mode) inline {
 int gas_before = gas_consumed();
 int forward_fee = send_message(msg, mode);
 int gas_usage = gas_consumed() - gas_before;

 ;; forward fee -- fee value
 ;; gas_usage -- the amount of gas used to send the message
}
```

## See also

- [Stablecoin contract with fees calculation](https://github.com/ton-blockchain/stablecoin-contract)