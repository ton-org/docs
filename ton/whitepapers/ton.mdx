---
title: "The Open Network"
sidebarTitle: "The Open Network"
description: "Whitepaper by Dr. Nikolai Durov"
---

**Authors**: Nikolai Durov, TON Core <br />
**Date**: July 26, 2021 <br />
<Icon icon="file-pdf" size={16} />: [Original whitepaper, PDF](/resources/pdfs/ton.pdf)

## Abstract

The aim of this text is to provide a first description of the Telegram Open Network (TON) and related blockchain, peer-to-peer, distributed storage and service hosting technologies. To reduce the size of this document to reasonable proportions, we focus mainly on the unique and defining features of the TON platform that are important for it to achieve its stated goals.

## Introduction

The *Telegram Open Network (TON)* is a fast, secure and scalable blockchain and network project, capable of handling millions of transactions per second if necessary, and both user-friendly and service provider-friendly. We aim for it to be able to host all reasonable applications currently proposed and conceived. One might think about TON as a huge distributed supercomputer, or rather a huge "superserver", intended to host and provide a variety of services.

This text is not intended to be the ultimate reference with respect to all implementation details. Some particulars are likely to change during the development and testing phases.

## 1. Brief Description of TON Components

The *Telegram Open Network (TON)* is a combination of the following components:

- **A flexible multi-blockchain platform** (*[TON Blockchain](#2-ton-blockchain)*): Capable of processing millions of transactions per second, with Turing-complete smart contracts, upgradable formal blockchain specifications, multi-cryptocurrency value transfer, support for micropayment channels and off-chain payment networks. *TON Blockchain* presents some new and unique features, such as the ["self-healing" vertical blockchain](#2-1-14-correcting-invalid-shardchain-blocks) mechanism and [Instant Hypercube Routing](#2-1-3-messages-instant-hypercube-routing), which enable it to be fast, reliable, scalable and self-consistent at the same time.

- **A peer-to-peer network** (*TON P2P Network*, or just *[TON Network](#3-ton-networking)*): Used for accessing the TON Blockchain, sending transaction candidates, and receiving updates about only those parts of the blockchain a client is interested in (e.g., those related to the client's accounts and smart contracts), but also able to support arbitrary distributed services, blockchain-related or not.

- **A distributed file storage technology** (*[TON Storage](#4-1-4-example-keeping-files-off-chain-ton-storage)*): Accessible through *TON Network*, used by the TON Blockchain to store archive copies of blocks and status data (snapshots), but also available for storing arbitrary files for users or other services running on the platform, with torrent-like access technology.

- **A network proxy/anonymizer layer** (*[TON Proxy](#4-1-6-example-ton-proxy-is-a-fog-service)* and [tunnels](#3-1-6-channel-as-a-tunnel-identifier)): Similar to the $I^2P$ (Invisible Internet Project), used to hide the identity and IP addresses of *TON Network* nodes if necessary (e.g., nodes committing transactions from accounts with large amounts of cryptocurrency, or high-stake blockchain validator nodes who wish to hide their exact IP address and geographical location as a measure against DDoS attacks).

- **A Kademlia-like distributed hash table** (*[TON DHT](#3-2-ton-dht-kademlia-like-distributed-hash-table)*): Used as a ["torrent tracker"](#3-2-10-distributed-torrent-trackers-and-network-interest-groups) for *TON Storage*, as an ["input tunnel locator"](#3-2-14-locating-abstract-addresses) for *TON Proxy*, and as a [service locator](#3-2-12-locating-services) for *TON Services*.

- **A platform for arbitrary services** (*[TON Services](#4-ton-services-and-applications)*): Residing in and available through *TON Network* and *TON Proxy*, with [formalized interfaces](#4-3-8-public-interfaces-of-a-smart-contract) enabling browser-like or smartphone application interaction. These [formal interfaces and persistent service entry points](#4-3-11-locating-user-interfaces-via-ton-dns) can be published in the TON Blockchain; actual nodes providing service at any given moment can be looked up through the *TON DHT* starting from [information published in the TON Blockchain](#3-2-12-locating-services). Services may create smart contracts in the TON Blockchain to offer some guarantees to their [clients](#4-1-3-mixed-services).

- **[TON DNS](#4-3-1-ton-dns)**: A service for assigning human-readable names to accounts, smart contracts, services and network nodes.

- **[TON Payments](#5-ton-payments)**: A platform for micropayments, micropayment channels and a micropayment channel network. It can be used for fast off-chain value transfers, and for paying for services powered by *TON Services*.

- TON will allow easy integration with third-party messaging and social networking applications, thus making blockchain technologies and distributed services finally [available and accessible to ordinary users](#4-3-17-ton-www), rather than just to a handful of early cryptocurrency adopters. We will provide an example of such an integration in another of our projects, the [Telegram Messenger](#4-3-12-telegram-integration).

While the TON Blockchain is the core of the TON project, and the other components might be considered as playing a supportive role for the blockchain, they turn out to have useful and interesting functionality by themselves. Combined, they allow the platform to host more versatile applications than it would be possible by just using the [TON Blockchain](#2-8-19-is-it-possible-to-upload-facebook-into-a-blockchain) and [TON service implementations](#4-1-ton-service-implementation-strategies).


# 2. TON Blockchain

We start with a description of the Telegram Open Network (TON) Blockchain, the core component of the project. Our approach here is "top-down": we give a general description of the whole first, and then provide more detail on each component.

For simplicity, we speak here about *the* TON Blockchain, even though in principle several instances of this blockchain protocol may be running independently (for example, as a result of hard forks). We consider only one of them.

## 2.1. TON Blockchain as a Collection of 2-Blockchains

The TON Blockchain is actually a *collection* of blockchains (even a collection of *blockchains of blockchains*, or *2-blockchains*—this point will be clarified later in [Correcting invalid shardchain blocks](#2-1-17-correcting-invalid-shardchain-blocks)), because no single blockchain project is capable of achieving our goal of processing millions of transactions per second, as opposed to the now-standard dozens of transactions per second.

### 2.1.1. List of blockchain types

The blockchains in this collection are:

- The unique *master blockchain*, or *masterchain* for short, containing general information about the protocol and the current values of its parameters, the set of validators and their stakes, the set of currently active workchains and their "shards", and, most importantly, the set of hashes of the most recent blocks of all workchains and shardchains.

- Several (up to $2^{32}$) *working blockchains*, or *workchains* for short, which are actually the "workhorses", containing the value-transfer and smart-contract transactions. Different workchains may have different "rules", meaning different formats of account addresses, different formats of transactions, different virtual machines (VMs) for smart contracts, different basic cryptocurrencies and so on. However, they all must satisfy certain basic interoperability criteria to make interaction between different workchains possible and relatively simple. In this respect, the TON Blockchain is [*heterogeneous*](#2-8-2-blockchain-types-homogeneous-and-heterogeneous-systems), similarly to the [EOS](#2-8-17-eos) and [PolkaDot](#2-8-18-polkadot) projects.

- Each workchain is in turn subdivided into up to $2^{60}$ *shard blockchains*, or *shardchains* for short, having the same rules and block format as the workchain itself, but responsible only for a subset of accounts, depending on several first (most significant) bits of the account address. In other words, a form of [sharding](#2-8-5-sharding-support) is built into the system. Because all these shardchains share a common block format and rules, the TON Blockchain is [*homogeneous*](#2-8-2-blockchain-types-homogeneous-and-heterogeneous-systems) in this respect, similarly to what has been discussed in one of Ethereum scaling proposals.<sup>[1](#fn1)</sup>

- Each block in a shardchain (and in the masterchain) is actually not just a block, but a small blockchain. Normally, this "block blockchain" or "vertical blockchain" consists of exactly one block, and then we might think this is just the corresponding block of the shardchain (also called "horizontal blockchain" in this situation). However, if it becomes necessary to fix incorrect shardchain blocks, a new block is committed into the "vertical blockchain", containing either the replacement for the invalid "horizontal blockchain" block, or a "block difference", containing only a description of those parts of the previous version of this block that need to be changed. This is a TON-specific mechanism to replace detected invalid blocks without making a true fork of all shardchains involved; it will be explained in more detail in [Correcting invalid shardchain blocks](#2-1-17-correcting-invalid-shardchain-blocks). For now, we just remark that each shardchain (and the masterchain) is not a conventional blockchain, but a *blockchain of blockchains*, or *2D-blockchain*, or just a *2-blockchain*.

### 2.1.2. Infinite Sharding Paradigm

Almost all blockchain sharding proposals are "top-down": one first imagines a single blockchain, and then discusses how to split it into several interacting shardchains to improve performance and achieve scalability.

The TON approach to sharding is "bottom-up", explained as follows.

Imagine that sharding has been taken to its extreme, so that exactly one account or smart contract remains in each shardchain. Then we have a huge number of "account-chains", each describing the state and state transitions of only one account, and sending value-bearing messages to each other to transfer value and information.

Of course, it is impractical to have hundreds of millions of blockchains, with updates (i.e., new blocks) usually appearing quite rarely in each of them. In order to implement them more efficiently, we group these "account-chains" into "shardchains", so that each block of the shardchain is essentially a collection of blocks of account-chains that have been assigned to this shard. Thus the "account-chains" have only a purely virtual or logical existence inside the "shardchains".

We call this perspective the *Infinite Sharding Paradigm*. It explains many of the design decisions for the TON Blockchain.

### 2.1.3. Messages. Instant Hypercube Routing

The Infinite Sharding Paradigm instructs us to regard each account (or smart contract) as if it were in its own shardchain by itself. Then the only way one account might affect the state of another is by sending a *message* to it (this is a special instance of the so-called [Actor model](#2-4-2-accounts-as-processes-or-actors-actor-model), with accounts as Actors). Therefore, a system of messages between accounts (and shardchains, because the source and destination accounts are, generally speaking, located in different shardchains) is of paramount importance to a scalable system such as the TON Blockchain. In fact, a novel feature of the TON Blockchain, called [*Instant Hypercube Routing*](#2-4-23-instant-hypercube-routing-fast-path-for-messages), enables it to deliver and process a message created in a block of one shardchain into the very next block of the destination shardchain, *regardless of the total number of shardchains in the system.*

### 2.1.4. Quantity of masterchains, workchains and shardchains

A TON Blockchain contains exactly one masterchain. However, the system can potentially accommodate up to $2^{32}$ workchains, each subdivided into up to $2^{60}$ shardchains.

### 2.1.5. Workchains can be virtual blockchains, not true blockchains

Because a workchain is usually subdivided into shardchains, the existence of the workchain is "virtual", meaning that it is not a true blockchain in the sense of the [general definition](#2-2-1-general-blockchain-definition) provided below, but just a collection of shardchains. When only one shardchain corresponds to a workchain, this unique shardchain may be identified with the workchain, which in this case becomes a "true" blockchain, at least for some time, thus gaining a superficial similarity to customary single-blockchain design. However, the [Infinite Sharding Paradigm](#2-1-2-infinite-sharding-paradigm) tells us that this similarity is indeed superficial: it is just a coincidence that the potentially huge number of "account-chains" can temporarily be grouped into one blockchain.

### 2.1.6. Identification of workchains

Each workchain is identified by its *number* or *workchain identifier* ($\mathit{workchain\_id}:\mathtt{uint}_{32}$), which is simply an unsigned 32-bit integer. Workchains are created by special transactions in the masterchain, defining the (previously unused) workchain identifier and the formal description of the workchain, sufficient at least for the interaction of this workchain with other workchains and for superficial verification of this workchain's blocks.

### 2.1.7. Creation and activation of new workchains

The creation of a new workchain may be initiated by essentially any member of the community, ready to pay the (high) masterchain transaction fees required to publish the formal specification of a new workchain. However, in order for the new workchain to become active, a two-thirds consensus of validators is required, because they will need to upgrade their software to process blocks of the new workchain, and signal their readiness to work with the new workchain by special masterchain transactions. The party interested in the activation of the new workchain might provide some incentive for the validators to support the new workchain by means of some rewards distributed by a smart contract.

### 2.1.8. Identification of shardchains

Each shardchain is identified by a couple $(w,s)=(\mathit{workchain\_id}, \mathit{shard\_prefix})$, where $\mathit{workchain\_id}:\mathtt{uint}_{32}$ identifies the corresponding workchain, and $\mathit{shard\_prefix}:\mathbf{2}^{0\ldots 60}$ is a bit string of length at most 60, defining the subset of accounts for which this shardchain is responsible. Namely, all accounts with $\mathit{account\_id}$ starting with $\mathit{shard\_prefix}$ (i.e., having $\mathit{shard\_prefix}$ as most significant bits) will be assigned to this shardchain.

### 2.1.9. Identification of account-chains

Recall that account-chains have only a virtual existence ([Infinite Sharding Paradigm](#2-1-2-infinite-sharding-paradigm)). However, they have a natural identifier—namely, $(\mathit{workchain\_id},\mathit{account\_id})$—because any account-chain contains information about the state and updates of exactly one account (either a simple account or smart contract—the distinction is unimportant here).

### 2.1.10. Dynamic splitting and merging of shardchains

A less sophisticated system might use *static sharding*—for example, by using the top eight bits of the $\mathit{account\_id}$ to select one of 256 pre-defined shards.

An important feature of the TON Blockchain is that it implements [*dynamic sharding*](#2-7-splitting-and-merging-shardchains), meaning that the number of shards is not fixed. Instead, shard $(w,s)$ can be automatically subdivided into shards $(w,s.0)$ and $(w,s.1)$ if some formal conditions are met (essentially, if the transaction load on the original shard is high enough for a prolonged period of time). Conversely, if the load stays too low for some period of time, the shards $(w,s.0)$ and $(w,s.1)$ can be automatically merged back into shard $(w,s)$.

Initially, only one shard $(w,\emptyset)$ is created for workchain $w$. Later, it is subdivided into more shards, if and when this becomes necessary ([split necessity](#2-7-2-determining-the-necessity-of-split-operations) and [merge necessity](#2-7-4-determining-the-necessity-of-merge-operations)).

### 2.1.11. Basic workchain or Workchain Zero

While up to $2^{32}$ workchains can be defined with their specific rules and transactions, we initially define only one, with $\mathit{workchain\_id}=0$. This workchain, called Workchain Zero or the basic workchain, is the one used to work with *TON smart contracts* and transfer *TON coins*, also known as [*Grams*](#appendix-a-the-ton-coin-or-the-gram). Most applications are likely to require only Workchain Zero. Shardchains of the basic workchain will be called *basic shardchains*.

### 2.1.12. Block generation intervals

We expect a new block to be generated in each shardchain and the masterchain approximately once every five seconds. This will lead to reasonably small transaction confirmation times. New blocks of all shardchains are generated approximately simultaneously; a new block of the masterchain is generated approximately one second later, because it must contain the hashes of the latest blocks of all shardchains.

### 2.1.13. Using the masterchain to make workchains and shardchains tightly coupled

Once the hash of a block of a shardchain is incorporated into a block of the masterchain, that shardchain block and all its ancestors are considered "canonical", meaning that they can be referenced from the subsequent blocks of all shardchains as something fixed and immutable. In fact, each new shardchain block contains a hash of the most recent masterchain block, and all shardchain blocks referenced from that masterchain block are considered immutable by the new block.

Essentially, this means that a transaction or a message committed in a shardchain block may be safely used in the very next blocks of the other shardchains, without needing to wait for, say, twenty confirmations (i.e., twenty blocks generated after the original block in the same blockchain) before forwarding a message or taking other actions based on a previous transaction, as is common in most proposed ["loosely-coupled"](#2-8-7-interaction-between-blockchains-loosely-coupled-and-tightly-coupled-systems) systems, such as [EOS](#2-8-17-eos). This ability to use transactions and messages in other shardchains a mere five seconds after being committed is one of the reasons we believe our "tightly-coupled" system, the first of its kind, will be able to deliver unprecedented performance ([sharding support](#2-8-5-sharding-support) and [blockchain interaction](#2-8-7-interaction-between-blockchains-loosely-coupled-and-tightly-coupled-systems)).

### 2.1.14. Masterchain block hash as a global state

According to [Using the masterchain](#2-1-13-using-the-masterchain-to-make-workchains-and-shardchains-tightly-coupled), the hash of the last masterchain block completely determines the overall state of the system from the perspective of an external observer. One does not need to monitor the state of all shardchains separately.

### 2.1.15. Generation of new blocks by validators

The TON Blockchain uses a Proof-of-Stake (PoS) approach for generating new blocks in the shardchains and the masterchain. This means that there is a set of, say, up to a few hundred *validators*—special nodes that have deposited *stakes* (large amounts of TON coins) by a special masterchain transaction to be eligible for new block generation and validation.

Then a smaller subset of validators is assigned to each shard $(w,s)$ in a deterministic pseudorandom way, changing approximately every 1024 blocks. This subset of validators suggests and reaches consensus on what the next shardchain block would be, by collecting suitable proposed transactions from the clients into new valid block candidates. For each block, there is a pseudorandomly chosen order on the validators to determine whose block candidate has the highest priority to be committed at each turn.

Validators and other nodes check the validity of the proposed block candidates; if a validator signs an invalid block candidate, it may be automatically punished by losing part or all of its stake, or by being suspended from the set of validators for some time. After that, the validators should reach consensus on the choice of the next block, essentially by an efficient variant of the BFT (Byzantine Fault Tolerant; [DPOS vs. BFT](#2-8-1-variants-of-proof-of-stake-dpos-vs-bft)) consensus protocol, similar to [PBFT](http://pmg.csail.mit.edu/papers/osdi99.pdf) or [Honey Badger BFT](https://eprint.iacr.org/2016/199.pdf). If consensus is reached, a new block is created, and validators divide between themselves the transaction fees for the transactions included, plus some newly-created ("minted") coins.

Each validator can be elected to participate in several validator subsets; in this case, it is expected to run all validation and consensus algorithms in parallel.

After all new shardchain blocks are generated or a timeout is passed, a new masterchain block is generated, including the hashes of the latest blocks of all shardchains. This is done by BFT consensus of *all* validators.<sup>[2](#fn2)</sup>

More detail on the TON PoS approach and its economical model is provided in [Creating and Validating New Blocks](#2-6-creating-and-validating-new-blocks).

### 2.1.16. Forks of the masterchain

A complication that arises from our tightly-coupled approach is that switching to a different fork in the masterchain will almost necessarily require switching to another fork in at least some of the shardchains. On the other hand, as long as there are no forks in the masterchain, no forks in the shardchain are even possible, because no blocks in the alternative forks of the shardchains can become "canonical" by having their hashes incorporated into a masterchain block.

The general rule is that *if masterchain block $B'$ is a predecessor of $B$, $B'$ includes hash $\mathrm{Hash}(B'_{w,s})$ of $(w,s)$-shardchain block $B'_{w,s}$, and $B$ includes hash $\mathrm{Hash}(B_{w,s})$, then $B'_{w,s}$ **must** be a predecessor of $B_{w,s}$; otherwise, the masterchain block $B$ is invalid.*

We expect masterchain forks to be rare, next to non-existent, because in the BFT paradigm adopted by the TON Blockchain they can happen only in the case of incorrect behavior by a *majority* of validators ([validators](#2-1-15-generation-of-new-blocks-by-validators) and [new masterchain blocks](#2-6-10-generation-of-new-masterchain-blocks)), which would imply significant stake losses by the offenders. Therefore, no true forks in the shardchains should be expected. Instead, if an invalid shardchain block is detected, it will be corrected by means of the "vertical blockchain" mechanism of the 2-blockchain ([Correcting invalid shardchain blocks](#2-1-17-correcting-invalid-shardchain-blocks)), which can achieve this goal without forking the "horizontal blockchain" (i.e., the shardchain). The same mechanism can be used to fix non-fatal mistakes in the masterchain blocks as well.

### 2.1.17. Correcting invalid shardchain blocks

Normally, only valid shardchain blocks will be committed, because validators assigned to the shardchain must reach a two-thirds Byzantine consensus before a new block can be committed. However, the system must allow for detection of previously committed invalid blocks and their correction.

Of course, once an invalid shardchain block is found—either by a validator (not necessarily assigned to this shardchain) or by a ["fisherman"](#2-6-3-fishermen-obtaining-money-by-pointing-out-others-mistakes) (any node of the system that made a certain deposit to be able to raise questions about block validity)—the invalidity claim and its proof are committed into the masterchain, and the validators that have signed the invalid block are punished by losing part of their stake and/or being temporarily suspended from the set of validators (the latter measure is important for the case of an attacker stealing the private signing keys of an otherwise benign validator).

However, this is not sufficient, because the overall state of the system (TON Blockchain) turns out to be invalid because of the invalid shardchain block previously committed. This invalid block must be replaced by a newer valid version.

Most systems would achieve this by "rolling back" to the last block before the invalid one in this shardchain and the last blocks unaffected by messages propagated from the invalid block in each of the other shardchains, and creating a new fork from these blocks. This approach has the disadvantage that a large number of otherwise correct and committed transactions are suddenly rolled back, and it is unclear whether they will be included later at all.

The TON Blockchain solves this problem by making each "block" of each shardchain and of the masterchain ("horizontal blockchains") a small blockchain ("vertical blockchain") by itself, containing different versions of this "block", or their "differences". Normally, the vertical blockchain consists of exactly one block, and the shardchain looks like a classical blockchain. However, once the invalidity of a block is confirmed and committed into a masterchain block, the "vertical blockchain" of the invalid block is allowed to grow by a new block in the vertical direction, replacing or editing the invalid block. The new block is generated by the current validator subset for the shardchain in question.

The rules for a new "vertical" block to be valid are quite strict. In particular, if a virtual ["account-chain block"](#2-1-2-infinite-sharding-paradigm) contained in the invalid block is valid by itself, it must be left unchanged by the new vertical block.

Once a new "vertical" block is committed on top of the invalid block, its hash is published in a new masterchain block (or rather in a new "vertical" block, lying above the original masterchain block where the hash of the invalid shardchain block was originally published), and the changes are propagated further to any shardchain blocks referring to the previous version of this block (e.g., those having received messages from the incorrect block). This is fixed by committing new "vertical" blocks in vertical blockchains for all blocks previously referring to the "incorrect" block; new vertical blocks will refer to the most recent (corrected) versions instead. Again, strict rules forbid changing account-chains that are not really affected (i.e., that receive the same messages as in the previous version). In this way, fixing an incorrect block generates "ripples" that are ultimately propagated towards the most recent blocks of all affected shardchains; these changes are reflected in new "vertical" masterchain blocks as well.

Once the "history rewriting" ripples reach the most recent blocks, the new shardchain blocks are generated in one version only, being successors of the newest block versions only. This means that they will contain references to the correct (most recent) vertical blocks from the very beginning.

The masterchain state implicitly defines a map transforming the hash of the first block of each "vertical" blockchain into the hash of its latest version. This enables a client to identify and locate any vertical blockchain by the hash of its very first (and usually the only) block.

### 2.1.18. TON coins and multi-currency workchains

The TON Blockchain supports up to $2^{32}$ different "cryptocurrencies", "coins", or "tokens", distinguished by a 32-bit $\mathit{currency\_id}$. New cryptocurrencies can be added by special transactions in the masterchain. Each workchain has a basic cryptocurrency, and can have several additional cryptocurrencies.

There is one special cryptocurrency with $\mathit{currency\_id}=0$, namely, the *TON coin*, also known as the [*Gram*](#appendix-a-the-ton-coin-or-the-gram). It is the basic cryptocurrency of Workchain Zero. It is also used for transaction fees and validator stakes.

In principle, other workchains may collect transaction fees in other tokens. In this case, some smart contract for automated conversion of these transaction fees into Grams should be provided.

### 2.1.19. Messaging and value transfer

Shardchains belonging to the same or different workchains may send *messages* to each other. While the exact form of the messages allowed depends on the receiving workchain and receiving account (smart contract), there are some common fields making inter-workchain messaging possible. In particular, each message may have some *value* attached, in the form of a certain amount of Grams (TON coins) and/or other registered cryptocurrencies, provided they are declared as acceptable cryptocurrencies by the receiving workchain.

The simplest form of such messaging is a value transfer from one (usually not a smart-contract) account to another.

### 2.1.20. TON Virtual Machine

The *TON Virtual Machine*, also abbreviated as *TON VM* or *TVM*, is the virtual machine used to execute smart-contract code in the masterchain and in the basic workchain. Other workchains may use other virtual machines alongside or instead of the TVM.

Here we list some of its features. They are discussed further in [Peculiarities of TON VM](#2-3-11-peculiarities-of-ton-vm), [TVM Cells](#2-3-13-tvm-cells) and elsewhere.

- TVM represents all data as a collection of [*(TVM) cells*](#2-3-13-tvm-cells). Each cell contains up to 128 data bytes and up to 4 references to other cells. As a consequence of the ["everything is a bag of cells"](#2-5-1-low-level-perspective-bag-of-cells) philosophy, this enables TVM to work with all data related to the TON Blockchain, including blocks and blockchain global state if necessary.

- TVM can work with values of arbitrary [algebraic data types](#2-3-11-peculiarities-of-ton-vm), represented as trees or directed acyclic graphs of TVM cells. However, it is agnostic towards the existence of algebraic data types; it just works with cells.

- TVM has built-in support for [hashmaps](#2-3-7-definition-of-hashmap-type-as-a-patricia-tree).

- TVM is a stack machine. Its stack keeps either 64-bit integers or cell references.

- 64-bit, 128-bit and 256-bit arithmetic is supported. All $n$-bit arithmetic operations come in three flavors: for unsigned integers, for signed integers and for integers modulo $2^n$ (no automatic overflow checks in the latter case).

- TVM has unsigned and signed integer conversion from $n$-bit to $m$-bit, for all $0\leq m,n\leq 256$, with overflow checks.

- All arithmetic operations perform overflow checks by default, greatly simplifying the development of smart contracts.

- TVM has "multiply-then-shift" and "shift-then-divide" arithmetic operations with intermediate values computed in a larger integer type; this simplifies implementing fixed-point arithmetic.

- TVM offers support for bit strings and byte strings.

- Support for 256-bit Elliptic Curve Cryptography (ECC) for some predefined curves, including Curve25519, is present.

- Support for Weil pairings on some elliptic curves, useful for fast implementation of zk-SNARKs, is also present.

- Support for popular hash functions, including $\mathrm{sha256}$, is present.

- TVM can work with [Merkle proofs](#5-1-10-ton-vm-support-for-smart-payment-channels).

- TVM offers support for "large" or "global" smart contracts. Such smart contracts must be aware of [sharding](#2-3-16-local-and-global-smart-contracts-smart-contract-instances) and [TVM data structures](#2-3-15-support-for-sharding-in-ton-vm-data-structures). Usual (local) smart contracts can be sharding-agnostic.

- TVM supports closures.

- A ["spineless tagless $G$-machine"](https://www.cambridge.org/core/journals/journal-of-functional-programming/article/implementing-lazy-functional-languages-on-stock-hardware-the-spineless-tagless-gmachine/354FFB29102309CCD2A3824F894A2799) can be easily implemented inside TVM.

Several high-level languages can be designed for TVM, in addition to the "TVM assembly". All these languages will have static types and will support algebraic data types. We envision the following possibilities:

- A Java-like imperative language, with each smart contract resembling a separate class.
- A lazy functional language (think of Haskell).
- An eager functional language (think of ML).

### 2.1.21. Configurable parameters

An important feature of the TON Blockchain is that many of its parameters are *configurable*. This means that they are part of the masterchain state, and can be changed by certain special proposal/vote/result transactions in the masterchain, without any need for hard forks. Changing such parameters will require collecting two-thirds of validator votes and more than half of the votes of all other participants who would care to take part in the voting process in favor of the proposal.

---
# 2.2. Generalities on Blockchains

## 2.2.1. General blockchain definition

In general, any *(true) blockchain* is a sequence of *blocks*, each block $B$ containing a reference $\mathrm{blk\text{-}prev}(B)$ to the previous block (usually by including the hash of the previous block into the header of the current block), and a list of *transactions*. Each transaction describes some transformation of the *global blockchain state*; the transactions listed in a block are applied sequentially to compute the new state starting from the old state, which is the resulting state after the evaluation of the previous block.

## 2.2.2. Relevance for the TON Blockchain

Recall that the *TON Blockchain* is not a true blockchain, but a [collection of 2-blockchains](#2-1-ton-blockchain-as-a-collection-of-2-blockchains) (i.e., of blockchains of blockchains), so the above is not directly applicable to it. However, we start with these generalities on true blockchains to use them as building blocks for our more sophisticated constructions.

## 2.2.3. Blockchain instance and blockchain type

One often uses the word *blockchain* to denote both a general *blockchain type* and its specific *blockchain instances*, defined as sequences of blocks satisfying certain conditions. For example, [General blockchain definition](#2-2-1-general-blockchain-definition) refers to blockchain instances.

In this way, a blockchain type is usually a "subtype" of the type $\mathit{Block}^*$ of lists (i.e., finite sequences) of blocks, consisting of those sequences of blocks that satisfy certain compatibility and validity conditions:

$$
\mathit{Blockchain} \subset \mathit{Block}^*
$$

A better way to define $\mathit{Blockchain}$ would be to say that $\mathit{Blockchain}$ is a *dependent couple type*, consisting of couples $(\mathbb{B},v)$, with first component $\mathbb{B}:\mathit{Block}^*$ being of type $\mathit{Block}^*$ (i.e., a list of blocks), and the second component $v:\mathit{isValidBc}(\mathbb{B})$ being a proof or a witness of the validity of $\mathbb{B}$. In this way,

$$
\mathit{Blockchain}\equiv\Sigma_{(\mathbb{B}:\mathit{Block}^*)}\mathit{isValidBc}(\mathbb{B})
$$

We use here the notation for dependent sums of types borrowed from [Homotopy Type Theory](https://homotopytypetheory.org/book).

## 2.2.4. Dependent type theory, Coq and TL

Note that we are using (Martin-Löf) dependent type theory here, similar to that used in the [Coq](https://coq.inria.fr) proof assistant. A simplified version of dependent type theory is also used in *TL (Type Language)*,<sup>[3](#fn3)</sup> which will be used in the formal specification of the TON Blockchain to describe the serialization of all data structures and the layouts of blocks, transactions, and the like.

In fact, dependent type theory gives a useful formalization of what a proof is, and such formal proofs (or their serializations) might become handy when one needs to provide proof of invalidity for some block, for example.

## 2.2.5. TL, or the Type Language

Since TL (Type Language) will be used in the formal specifications of TON blocks, transactions, and network datagrams, it warrants a brief discussion.

TL is a language suitable for description of dependent algebraic *types*, which are allowed to have numeric (natural) and type parameters. Each type is described by means of several *constructors*. Each constructor has a (human-readable) identifier and a *name*, which is a bit string (32-bit integer by default). Apart from that, the definition of a constructor contains a list of fields along with their types.

A collection of constructor and type definitions is called a *TL-scheme*. It is usually kept in one or several files with the suffix `.tl`.

An important feature of TL-schemes is that they determine an unambiguous way of serializing and deserializing values (or objects) of algebraic types defined. Namely, when a value needs to be serialized into a stream of bytes, first the name of the constructor used for this value is serialized. Recursively computed serializations of each field follow.

The description of a previous version of TL, suitable for serializing arbitrary objects into sequences of 32-bit integers, is available at https://core.telegram.org/mtproto/TL. A new version of TL, called *TL-B*, is being developed for the purpose of describing the serialization of objects used by the TON Project. This new version can serialize objects into streams of bytes and even bits (not just 32-bit integers), and offers support for serialization into a tree of [TVM cells](#2-3-13-tvm-cells). A description of TL-B will be a part of the formal specification of the TON Blockchain.

## 2.2.6. Blocks and transactions as state transformation operators

Normally, any blockchain (type) $\mathit{Blockchain}$ has an associated global state (type) $\mathit{State}$, and a transaction (type) $\mathit{Transaction}$. The semantics of a blockchain are to a large extent determined by the transaction application function:

$$
\mathit{ev\_trans}':\mathit{Transaction}\times\mathit{State}\to\mathit{State}^?
$$

Here $X^?$ denotes $\mathit{Maybe}\,X$, the result of applying the $\mathit{Maybe}$ monad to type $X$. This is similar to our use of $X^*$ for $\mathit{List}\,X$. Essentially, a value of type $X^?$ is either a value of type $X$ or a special value $\bot$ indicating the absence of an actual value (think about a null pointer). In our case, we use $\mathit{State}^?$ instead of $\mathit{State}$ as the result type because a transaction may be invalid if invoked from certain original states (think about attempting to withdraw from an account more money than it is actually there).

We might prefer a curried version of $\mathit{ev\_trans}'$:

$$
\mathit{ev\_trans}:\mathit{Transaction}\to\mathit{State}\to\mathit{State}^?
$$

Because a block is essentially a list of transactions, the block evaluation function

$$
\mathit{ev\_block}:\mathit{Block}\to\mathit{State}\to\mathit{State}^?
$$

can be derived from $\mathit{ev\_trans}$. It takes a block $B:\mathit{Block}$ and the previous blockchain state $s:\mathit{State}$ (which might include the hash of the previous block) and computes the next blockchain state $s'=\mathit{ev\_block}(B)(s):\mathit{State}$, which is either a true state or a special value $\bot$ indicating that the next state cannot be computed (i.e., that the block is invalid if evaluated from the starting state given—for example, the block includes a transaction trying to debit an empty account.)

## 2.2.7. Block sequence numbers

Each block $B$ in the blockchain can be referred to by its *sequence number* $\mathrm{blk\text{-}seqno}(B)$, starting from zero for the very first block, and incremented by one whenever passing to the next block. More formally,

$$
\mathrm{blk\text{-}seqno}(B)=\mathrm{blk\text{-}seqno}\bigl(\mathrm{blk\text{-}prev}(B)\bigr)+1
$$

Notice that the sequence number does not identify a block uniquely in the presence of *forks*.

## 2.2.8. Block hashes

Another way of referring to a block $B$ is by its hash $\mathrm{blk\text{-}hash}(B)$, which is actually the hash of the *header* of block $B$ (however, the header of the block usually contains hashes that depend on all content of block $B$). Assuming that there are no collisions for the hash function used (or at least that they are very improbable), a block is uniquely identified by its hash.

## 2.2.9. Hash assumption

During formal analysis of blockchain algorithms, we assume that there are no collisions for the $k$-bit hash function $\mathrm{Hash}:\mathit{Bytes}^*\to\mathbf{2}^{k}$ used:

$$
\mathrm{Hash}(s)=\mathrm{Hash}(s')\Rightarrow s=s'\quad\text{for any }s, s'\in\mathit{Bytes}^* \tag{1}
$$

Here $\mathit{Bytes}=\{0\ldots255\}=\mathbf{2}^8$ is the type of bytes, or the set of all byte values, and $\mathit{Bytes}^*$ is the type or set of arbitrary (finite) lists of bytes; while $\mathbf{2}=\{0,1\}$ is the bit type, and $\mathbf{2}^k$ is the set (or actually the type) of all $k$-bit sequences (i.e., of $k$-bit numbers).

Of course, (1) is impossible mathematically, because a map from an infinite set to a finite set cannot be injective. A more rigorous assumption would be

$$
\forall s, s': s\neq s', P\bigl(\mathrm{Hash}(s)=\mathrm{Hash}(s')\bigr)=2^{-k} \tag{2}
$$

However, this is not so convenient for the proofs. If (2) is used at most $N$ times in a proof with $2^{-k}N<\epsilon$ for some small $\epsilon$ (say, $\epsilon=10^{-18}$), we can reason as if (1) were true, provided we accept a failure probability $\epsilon$ (i.e., the final conclusions will be true with probability at least $1-\epsilon$).

Final remark: in order to make the probability statement of (2) really rigorous, one must introduce a probability distribution on the set $\mathit{Bytes}^*$ of all byte sequences. A way of doing this is by assuming all byte sequences of the same length $l$ equiprobable, and setting the probability of observing a sequence of length $l$ equal to $p^l-p^{l+1}$ for some $p\to1-$. Then (2) should be understood as a limit of conditional probability $P\bigl(\mathrm{Hash}(s)=\mathrm{Hash}(s')|s\neq s'\bigr)$ when $p$ tends to one from below.

## 2.2.10. Hash used for the TON Blockchain

We are using the 256-bit $\mathrm{sha256}$ hash for the TON Blockchain for the time being. If it turns out to be weaker than expected, it can be replaced by another hash function in the future. The choice of the hash function is a [configurable parameter](#2-1-21-configurable-parameters) of the protocol, so it can be changed without hard forks.


## Footnotes

<span id="fn1">1.</span> https://github.com/ethereum/wiki/wiki/Sharding-FAQ [Back ↑](#2-1-1-list-of-blockchain-types)

<span id="fn2">2.</span> Actually, two-thirds by stake is enough to achieve consensus, but an effort is made to collect as many signatures as possible. [Back ↑](#2-1-15-generation-of-new-blocks-by-validators)

<span id="fn3">3.</span> https://core.telegram.org/mtproto/TL [Back ↑](#2-2-4-dependent-type-theory-coq-and-tl)