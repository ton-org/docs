---
title: "FunC reserved keywords and built-ins"
sidebarTitle: "Reserved keywords and built-ins"
noindex: true
---

import { Aside } from '/snippets/aside.jsx';

## Reserved keywords

FunC reserves the following symbols and words. These cannot be used as identifiers.

### Symbols 

`+` &emsp; `-` &emsp; `*` &emsp; `/`

`%` &emsp; `?` &emsp; `:` &emsp; `,`

`;` &emsp; `(` &emsp; `)` &emsp; `[` 

`]` &emsp; `{` &emsp; `}` &emsp; `=`

`_` &emsp; `<` &emsp; `>` &emsp; `&` 

`|` &emsp; `^` &emsp; `~` &emsp; `==`

`!=` &emsp; `<=` &emsp; `>=` &emsp; `<=>`

`<<` &emsp; `>>` &emsp; `~>>` &emsp; `^>>`

`~/` &emsp; `^/` &emsp; `~%` &emsp; `^%`

`/%` &emsp; `+=` &emsp; `-=` &emsp; `*=`

`/=` &emsp; `~/=` &emsp; `^/=` &emsp; `%=`

`~%=` &emsp; `^%=` &emsp; `<<=` &emsp; `>>=`

`~>>=` &emsp; `^>>=` &emsp; `&=` &emsp; `|=`

`^=` &emsp; `->`

### Words

`return` &emsp; `var` &emsp; `repeat` &emsp; `do`

`while` &emsp; `until` &emsp; `try` &emsp; `catch`

`if` &emsp; `ifnot` &emsp; `then` &emsp; `else`

`elseif` &emsp; `elseifnot` &emsp; `int` &emsp; `cell`

`slice` &emsp; `builder` &emsp; `cont` &emsp; `tuple`

`type` &emsp; `forall` &emsp; `extern` &emsp; `global`

`asm` &emsp; `impure` &emsp; `inline` &emsp; `inline_ref`

`auto_apply` &emsp; `method_id` &emsp; `operator` &emsp; `infix`

`infixl` &emsp; `infixr` &emsp; `const` &emsp; `#pragma`

`#include`

## Built-ins

Built-ins are language constructs outside the core that the optimizer handles efficiently. Although they could be implemented in [the standard library](stdlib), keeping them built-in enables better optimization.

In addition, FunC does not allow the built-in names in this section to be used as identifiers.
However, there is an exception: [built-ins with non-symbolic names](#built-ins-with-non-symbolic-names) 
_can_ be used as identifiers for local variables.

### Built-ins with symbolic names

`_+_` &emsp; `_-_` &emsp; `-_` &emsp; `_*_`
 
`_/_` &emsp; `_~/_` &emsp; `_^/_` &emsp; `_%_`

`_~%_` &emsp; `_^%_` &emsp; `_/%_` &emsp; `_<<_`

`_>>_` &emsp; `_~>>_` &emsp; `_^>>_` &emsp; `_&_`

`_|_` &emsp; `_^_` &emsp; `~_` &emsp; `^_+=_`

`^_-=_` &emsp; `^_*=_` &emsp; `^_/=_` &emsp; `^_~/=_`

`^_^/=_` &emsp; `^_%=_` &emsp; `^_~%=_` &emsp; `^_^%=_`

`^_<<=_` &emsp; `^_>>=_` &emsp; `^_~>>=_` &emsp; `^_^>>=_`

`^_&=_` &emsp; `^_|=_` &emsp; `^_^=_` &emsp; `_==_`

`_!=_` &emsp; `_<_` &emsp; `_>_` &emsp; `_<=_`

`_>=_` &emsp; `_<=>_` 
  
### Built-ins with non-symbolic names

[`divmod`](#divmod) &emsp; `~divmod` &emsp; `moddiv` &emsp; `~moddiv`

[`muldiv`](#muldiv) &emsp; `muldivr` &emsp; `muldivc` &emsp; `muldivmod`

[`true`](#true) &emsp; [`false`](#false) &emsp; `nil` &emsp; `Nil` 

[`null?`](#null%3F) &emsp; [`throw`](#throw) &emsp; [`throw_if`](#throw-if) &emsp; [`throw_unless`](#throw-unless)

[`throw_arg`](#throw-arg) &emsp; [`throw_arg_if`](#throw-arg-if) &emsp; [`throw_arg_unless`](#throw-arg-unless) &emsp; `load_int`

`load_uint` &emsp; `preload_int` &emsp; `preload_uint` &emsp; `store_int`

`store_uint` &emsp; `~store_int` &emsp; `~store_uint` &emsp; `load_bits`

`preload_bits` &emsp; `int_at` &emsp; `cell_at` &emsp; `slice_at`

`tuple_at` &emsp; [`at`](#at) &emsp; [`touch`](#touch-and-touch) &emsp; [`~touch`](#touch-and-touch)

`touch2` &emsp; `~touch2` &emsp; [`~dump`](#dump) &emsp; [`~strdump`](#strdump)

`run_method0` &emsp; `run_method1` &emsp; `run_method2` &emsp; `run_method3`



#### `throw`

`throw` emits an unconditional exception. `throw` takes only one argument—the error code—since it always triggers an exception.

#### `throw_if`

`throw_if` emits an exception only if the provided condition is true. It receives two arguments: the error code, which defines the exception type, and 
the condition.

#### `throw_unless`

`throw_unless` emits an exception only if the provided condition is false. It receives two arguments: the error code, which defines the exception type, and 
the condition.

#### `throw_arg`

`throw_arg` is an unconditional exception with a parameter. It is the parameterized version of `throw`.
The first argument is a parameter of any type, the second argument defines the error code, and the third argument is the condition.

#### `throw_arg_if`

Parameterized version of `throw_if`.
The first argument is a parameter of any type, the second argument defines the error code, and the third argument is the condition.

#### `throw_arg_unless`

Parameterized version of `throw_unless`.
The first argument is a parameter of any type, the second argument defines the error code, and the third argument is the condition.

#### `~dump` {#dump}

`~dump` outputs a variable to the debug log.

#### `~strdump` {#strdump}

`~strdump` outputs a string to the debug log.

#### `divmod`

`divmod` takes two numbers as input and returns the quotient and remainder of their division.

#### `muldiv`

`muldiv` performs a multiply-then-divide operation.
It uses a 513-bit intermediate result to prevent overflow if the final result fits within 257 bits.

#### `true`

`true` is an alias for `-1`.

#### `false`

`false` is an alias for `0`.

#### `null?`

`null?` checks if the given argument is `null`. In FunC, the value `null` belongs to the TVM type `Null`, which represents the absence of a value for certain atomic types. 
See [null values](/language/func/types#null-values) for details.
 

#### `touch` and `~touch`

`touch` pushes a variable to the top of the stack. `~touch` is identical to `touch`, but it is adapted for use in [modifying methods](functions#modifying-functions). 

#### `at` 

The function `at` returns the value of a tuple element at the specified position.
