---
title: "FunC literals"
sidebarTitle: "Literals"
noindex: "true"
---

import { Aside } from '/snippets/aside.jsx';

## Number literals

FunC supports decimal and hexadecimal integer literals, including those with leading zeros.

**Examples of valid integer literals:** `0`, `123`, `-17`, `00987`, and `-0`.

**Examples of valid hexadecimal literals:** `0xef`, `0xEF`, `0x0`, `-0xfFAb`, `0x0001`, and `-0x0`.

## Identifiers

FunC allows a broad range of identifiers for functions and variable names.
Any **single-line string** that meets the following conditions qualifies as a valid identifier:

- It **does not** contain special symbols: `;`, `,`, `(`, `)`, `[`, `]`, spaces including tabs, `~`, and `.`.
- It **does not** start as a [comment](comments) or a [string literal](#string-literals) (i.e., with `"` at the beginning).
- It is **not** a [number literal](#number-literals).
- It is **not** an underscore `_`.
- It is **not** a [reserved keyword](built-ins#reserved-keywords).
- It is **not** the name of a [built-in](built-ins#built-ins).

Additionally, **function** names in function definitions can start with `.` or `~`.

<Aside>
  FunC allows an exception regarding identifiers for local variables. Local variables can use the name of a
  [built-in with a non-symbolic name](built-ins#built-ins-with-non-symbolic-names).
</Aside>

**Examples of valid identifiers:**

- `query`, `query'`, `query''`
- `elem0`, `elem1`, `elem2`
- `CHECK`
- `_internal_value`
- `message_found?`
- `get_pubkeys&signatures`
- `dict::udict_set_builder`
- `fatal!`

**Examples of less common, but still valid identifiers:**

- `123validname`
- `2+2=2*2`
- `-alsovalidname`
- `0xefefefhahaha`
- `{hehehe}`
- ``pa{--}in"`aaa`"``

**Examples of valid function names:**

- `fun_a`
- `~fun_a?`
- `._how123`

**Examples of invalid identifiers:**

- `take(first)Entry` - contains parentheses `(` and `)`
- `"not_a_string` - starts with a `"`, like a string literal
- `msg.sender` - includes a `.`
- `send_message,then_terminate` - contains a `,`
- `_` - just an underscore, which is not valid on its own
- ``pa;;in"`aaa`"`` - contains `;`
- `{-aaa-}` - it is a comment
- `aa(bb` - contains an opening parenthesis
- `123` - a number literal
- `_+_` - it is a reserved builtin name

**Special identifiers in backticks:**

FunC allows identifiers enclosed in backticks `` ` ``. These identifiers can contain any characters except:

- Newline characters `\n`
- Backticks `` ` `` themselves, except the opening and closing ones.

**Examples of valid backtick identifiers:**

- `` `I'm a variable identifier too` ``
- `` `any symbols ; ~ () are allowed here...` ``

<Aside type="tip">
  Identifiers in FunC usually follow these naming conventions:

  - **Apostrophe `'` at the end:** used when a variable is a modified version of its original value.

    - Example:
      ```
      cell dict' = udict_set(dict, 100, 0, v);
      ```
      Here, function `udict_set` updates key `0` with value `v` in dictionary `dict`. The updated dictionary name is `dict'`.

  - **Question mark (?) at the end:** typically used for boolean variables or functions that return a success flag.
    - Example:
      ```
      (slice v, int found?) = udict_get?(dict, 100, 0);
      ```
      Here, function `udict_get?` looks up index `0` in dictionary `dict`, and returns the associated value `v` (if found) and a flag
      `found?` which indicates whether the index was found in the dictionary.
</Aside>

## Constants

FunC allows defining **compile-time constants** that are substituted and pre-computed during compilation.

**Syntax:**

```func
const optional-type identifier = value-or-expression;
```

- `optional-type` (e.g., `int` or `slice`) is optional but improves readability and ensures type correctness.
- `value-or-expression`can be a literal or an expression involving literals and previously defined constants.

Multiple constants can be defined in the same `const` declaration by separating them with `,`.

**Example usage:**

```func
const int101 = 101;                      ;; Numeric constant
const str1 = "const1", str2 = "aabbcc"s; ;; Multiple string constants separated with ,
const int int240 = (int101 * 10) << 3;   ;; Constant computed from an expression
const slice str2r = str2;                ;; Constant referencing another constant
```

<Aside type="tip">
  Numeric constants are replaced during compilation,
  which means that all optimizations and pre-computations apply efficiently.
</Aside>

## Compile-time built-ins

FunC has a special syntax for compile-time operations that compute slices and integer hashes out of ASCII strings.
These compile-time operations are invoked by enclosing the ASCII string in double quotes `"`, followed
by a suffix representing the compile-time operation to apply on the string, like:

```func
"this is a string"u
```

where the suffix `u` represents the compile-time operation to invoke on the ASCII string.

These built-ins are evaluated during compilation time, which means that the FunC compiler replaces the built-in call anywhere
it occurs with the result of the call. In particular, it is possible to use these compile-time built-ins while declaring constants:

```
const c = "some string"s;
```

We now describe the possible string suffixes.

### String without suffix

If no suffix is provided, the compiler computes a slice from the ASCII string, such that the contents of the slice is the binary code of the ASCII string.

```func
const c = "hello";     ;; c has the slice x{68656c6c6f}, where 68656c6c6f 
                       ;; is the slice contents in hexadecimal, representing
                       ;; the ASCII code of the string.
```

### String with suffix `s`

Suffix `s` interprets the string as an hexadecimal number and produces a slice having the binary representation of the hexadecimal number.
If the string is not an hexadecimal number, the compiler signals an error.

```func
const c = "abcdef"s;   ;; c has the slice x{abcdef}, where abcdef is the 
                       ;; slice contents in hexadecimal. 
                       ;; Note that abcdef is a valid hexadecimal number.
```

### String with suffix `a`

Suffix `a` interprets the string as an address and creates a slice containing a [`MsgAddressInt` structure]() from the address.

<Aside type="danger">
  MsgAddressInt structure link is missing!!
</Aside>

```func
;; c has slice x{9FE6666666666666666666666666666666666666666666666666666666666666667_}
;; The slice contents represent the MsgAddressInt structure: 
;; addr_std$10 anycast:none$0 workchain_id:int8=0xFF address:bits256=0x33...33
const c = "Ef8zMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM0vF"a;
```

### String with suffix `u`

Suffix `u` produces the decimal representation of the binary code of the ASCII string.

```
const c = "NstK"u;     ;; c has the integer 1316189259
                       ;; which is the decimal representation of the 
                       ;; ASCII code of the string
```

### String with suffix `h`

Suffix `h` generates an integer from the first 32 bits of the string's SHA-256 hash.

```func
const c = "transfer(slice, int)"h;  ;; c has the integer 2053302440
```

### String with suffix `H`

Suffix `H` generates an integer from the full 256-bit SHA-256 hash of the string.

```func
;; c has the integer 
;; 55356924298749527416066000120313684523410504308849542670649639903159354505593
const c = "transfer(slice, int)"H   
```

### String with suffix `c`

Suffix `c` generates an integer from the `crc32` value of the string.

```func
const c = "transfer(slice, int)"c   ;; c has the integer 2235694568
```

### String with multiple lines

Special characters like `\n` are not supported in strings, but you can create multi-line strings by writing the text across multiple lines,
all surrounded by triple quotes `"""`. The triple quotes syntax also supports the previously described suffixes.

For example:

```func
int a = """
   hash me baby one more time
   .... Oh, baby, baby
"""h;     ;; a has value 876244482
```
