---
title: "NFT: Reference implementation"
sidebarTitle: "Reference implementation"
---

The NFT standard (TEP-62) describes necessary messages, get-methods. The NFT royalty standard (TEP-66) describes standard way of implementing royalty information for NFT sales. The token data standard (TEP-64) describes available formats for metdata of tokens. There is a [reference implementation](https://github.com/ton-blockchain/token-contract/tree/1182ad99413242f09925d50e70ccb7e0e09f94d4/nft) following all these standards, that is widely used for cases of simple NFTs without extra custom mechanics. This article explains that implementation's details to give an understanding of the source code, and to show what parts of it can be changed or extended, and what should remain untouched.

The implementation contains multiple smart contracts written in FunC language, including additional ones for NFT sales. This article will only describe collection and item smart contracts, as they are the only necessary ones per standard.

## Collection

The full source code is in [nft-collection.fc](https://github.com/ton-blockchain/token-contract/blob/1182ad99413242f09925d50e70ccb7e0e09f94d4/nft/nft-collection.fc) file.

The TEP-62 standard only requires the implementation of get-methods: `get_collection_data()`, `get_nft_address_by_index(int index)`, and `get_nft_content(int index, cell individual_content)`. The TEP-66 standard also adds the `royalty_params()` get-method, `get_royalty_params` message for requesting royalty parameters on-chain, and `report_royalty_params` message for response containing these parameters. Everything else is up to the implementation and can be arbitrary. This includes any kind of modifications to the logic of minting new items, managing ownership of the collection, changing metadata, and any other features. The reference implementation, for example, implements the ownership management feature, and two ways of minting items: singular and batched. Both of these are outside of the scope of standards, but are pretty common and needed in most cases. They can technically be removed or changed in any way too.

Below is a table showing what messages and get-methods of reference collection smart contract are forced by standards and what are not.

| Capatibility                                                      | Requirement                                       |
| ----------------------------------------------------------------- | ------------------------------------------------- |
| `get_collection_data` (get-method)                                | Required by TEP-62                                |
| `get_nft_address_by_index` (get-method)                           | Required by TEP-62                                |
| `get_nft_content` (get-method)                                    | Required by TEP-62, data format follows TEP-64    |
| `royalty_params` (get-method)                                     | Required by TEP-66                                |
| `get_royalty_params` (inbound internal message) | Required by TEP-66                                |
| `report_royalty_params` (outbound internal message) | Required by TEP-66                                |
| `op=1` (internal message, owner-only)                             | Optional — deploy single item (reference impl)    |
| `op=2` (internal message, owner-only)                             | Optional — deploy batch of items (reference impl) |
| `op=3` (internal message, owner-only)                             | Optional — change owner (reference impl)          |

### Storage

The storage scheme itself is not defined by these standards, so it can be arbitrary. The reference collection contract contains 5 fields: `owner_address`, `next_item_index` , `content`, `nft_item_code`, and `royalty_params`. Some of them are self-explanatory, while `content` and `royalty_params ` will need additional explanations below.

Storage loading and saving is implemented with simple functions `load_data` and `save_data`:

```func
(slice, int, cell, cell, cell) load_data() inline {
  var ds = get_data().begin_parse();
  return
    (ds~load_msg_addr(), ;; owner_address
     ds~load_uint(64), ;; next_item_index
     ds~load_ref(), ;; content
     ds~load_ref(), ;; nft_item_code
     ds~load_ref()  ;; royalty_params
     );
}

() save_data(slice owner_address, int next_item_index, cell content, cell nft_item_code, cell royalty_params) impure inline {
  set_data(begin_cell()
    .store_slice(owner_address)
    .store_uint(next_item_index, 64)
    .store_ref(content)
    .store_ref(nft_item_code)
    .store_ref(royalty_params)
    .end_cell());
}
```

The `content` cell in this contract contains 2 cells in references: `collection_content` containing metdata of the collection itself, and `common_content` containing the common prefix for individual items metadata.

The `royalty_params` cell contains 3 values: `royalty_factor` which is a numerator, `royalty_base` which is a denominator, and `royalty_address` which is a destination address to where the royalties should be sent.

### Child contracts

The collection and item contracts implement a classic pattern of parent-child contracts, where collection plays a role of a parent, and items are children. Therefore, collection implements functionality to deploy its children, and that's why we had to keep `nft_item_code` field in storage.

Before moving to how collection handles incoming messages, let's take a look at helper functions defined for composing stateinit, calculating address, and sending a deploy message for NFT items, as they are used in multiple places.

Let's start with `calculate_nft_item_state_init` function that composes a stateinit cell of an NFT item with a given `item_index`. It composes a data cell following the expected storage schema of the item contract, that will be described later. Then the data and code cells, are placed in a final stateinit cell following the format required by TON blockchain. It uses `store_dict` functions but doesn't actually work with dictionaries - this function can be replaced with a more self-explanatory `store_maybe_ref` function which does the same thing. It stores a single bit `0` in a builder if the cell is null, otherwise bit `1` and a cell as a reference.

```func
cell calculate_nft_item_state_init(int item_index, cell nft_item_code) {
  cell data = begin_cell().store_uint(item_index, 64).store_slice(my_address()).end_cell();
  return begin_cell().store_uint(0, 2).store_dict(nft_item_code).store_dict(data).store_uint(0, 1).end_cell();
}
```

Then comes the `calculate_nft_item_address` function that takes `state_init` composed by `calculate_nft_item_state_init`, along with `wc` which is a workchain for the resulting address. This function is boilerplate - it calculates the address by taking the hash of the stateinit and composes a `MsgAddressInt` slice according to the format required by TON blockchain.

```func
slice calculate_nft_item_address(int wc, cell state_init) {
  return begin_cell().store_uint(4, 3)
                     .store_int(wc, 8)
                     .store_uint(cell_hash(state_init), 256)
                     .end_cell()
                     .begin_parse();
}
```

Then there is function which is mostly boilerplate: `deploy_nft_item`. It deployes an item with provided index, code, amount of Toncoin to attach and the content for metadata. It first calls `calculate_nft_item_state_init` to compose stateinit, then uses it to calculate the address by calling `nft_address` and providing a constant hardcoded `workchain()` equal to 0 in this implementation. Then it uses both stateinit and address to compose and send a message for deploying that item contract.

```func
() deploy_nft_item(int item_index, cell nft_item_code, int amount, cell nft_content) impure {
  cell state_init = calculate_nft_item_state_init(item_index, nft_item_code);
  slice nft_address = calculate_nft_item_address(workchain(), state_init);
  var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(nft_address)
            .store_coins(amount)
            .store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1)
            .store_ref(state_init)
            .store_ref(nft_content);
  send_raw_message(msg.end_cell(), 1); ;; pay transfer fees separately, revert on errors
}
```

These 3 functions will be used for minting new items, and returning addresses of items in get-methods.

### Internal messages

NFT standards only require one message to be processed in a specific way: `get_royalty_params`. All other logic for processing incoming messages can be arbitrary, but this reference contract shows a good example of how it can be organized for NFTs.

The `recv_internal` function starts with incoming message parsing boilerplate:

```func
() recv_internal(cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore empty messages
        return ();
    }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4); ;; the `int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool` part of CommonMsgInfo

    if (flags & 1) { ;; ignore all bounced messages by checking last bit of `flags` variable
        return ();
    }
    slice sender_address = cs~load_msg_addr(); ;; the `src:MsgAddressInt` part of CommonMsgInfo
    ;; ...
}
```

Then it parses `op` and `query_id` from incoming message body, and loads the storage data:

```func
() recv_internal(cell in_msg_full, slice in_msg_body) impure {
    ;; ...
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    var (owner_address, next_item_index, content, nft_item_code, royalty_params) = load_data();
    ;; ...
}
```

#### get\_royalty\_params

Then comes the only messages handling part required by standard, the implementation of `get_royalty_params` message. All it does is sends a `report_royalty_params` message back to sender providing the `royalty_params` field taken from storage. The `send_royalty_params` function is mostly boilerplate. It sends a non-bounceable message to a desired address with a body following the standard. It carries the value of the incoming message.

```func
() send_royalty_params(slice to_address, int query_id, slice data) impure inline {
  var msg = begin_cell()
    .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 011000
    .store_slice(to_address)
    .store_coins(0)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .store_uint(op::report_royalty_params(), 32) ;; opcode required by standard
    .store_uint(query_id, 64) ;; same query_id as request
    .store_slice(data);
  send_raw_message(msg.end_cell(), 64); ;; carry all the remaining value of the inbound message
}

() recv_internal(cell in_msg_full, slice in_msg_body) impure {
    ;; ...
    if (op == op::get_royalty_params()) {
        send_royalty_params(sender_address, query_id, royalty_params.begin_parse());
        return ();
    }
    ;; ...
}
```

Then the contract implements multiple owner-only features, so it checks the ownership beforehand:

```func
() recv_internal(cell in_msg_full, slice in_msg_body) impure {
    ;; ...
    throw_unless(401, equal_slices(sender_address, owner_address));
    ;; ...
}
```

Then there are 3 features: deploy single item (opcode `1`), deploy a batch of items (opcode `2`), and change owner (opcode `3`). The chosen opcodes are arbitrary.

#### Deploy single item

It parses the incoming message and expectes it to contain 3 values: `item_index:uint64`, `amount:Coins` and `content:^Cell`. It checks the item index to be lower than or equal than the `next_item_index` from storage. Then it calls a helper function `deploy_nft_item` which deploys that new NFT item. And lastly, in case if the item index equals `next_item_index`, it increments `next_item_index` to update the last item index.

```func
() recv_internal(cell in_msg_full, slice in_msg_body) impure {
    ;; ...
    if (op == 1) { ;; deploy new nft
      int item_index = in_msg_body~load_uint(64);
      throw_unless(402, item_index <= next_item_index);
      var is_last = item_index == next_item_index;
      deploy_nft_item(item_index, nft_item_code, in_msg_body~load_coins(), in_msg_body~load_ref());
      if (is_last) {
        next_item_index += 1;
        save_data(owner_address, next_item_index, content, nft_item_code, royalty_params);
      }
      return ();
    }
    ;; ...
}
```

#### Deploy batch of items

Now let's go through the batched deploy feature. It is useful for cases when you need to deploy many NFTs at once, for example when minting some initial items. It takes a single `deploy_list` dictionary from message where keys are item indices and values are cells containing amounts of Toncoin to attach to deployment, and content cells, similarly to values parsed by singular deploy feature above. It traverses it in ascending order of indices, up to 249 items from the dict, so that it does not hit an actions limit. The actions limit is actually 254 out messages, but this reference contract sets a lower limit, which is an arbitrary choice.

The logic here is straight forward, the loop uses `~udict::delete_get_min(64)` function to get and delete the item from the dictionary with minimum unsigned 64-bit integer key. It does that on each iteration of the loop, eventually iterating through the dictionary, and increments `counter` on each step to catch the case of the messages quantity limit. The deployment logic is same as for the singular deployment feature above.

```func
() recv_internal(cell in_msg_full, slice in_msg_body) impure {
    ;; ...
    if (op == 2) { ;; batch deploy of new nfts
      int counter = 0;
      cell deploy_list = in_msg_body~load_ref();
      do {
        var (item_index, item, f?) = deploy_list~udict::delete_get_min(64);
        if (f?) {
          counter += 1;
          if (counter >= 250) { ;; Limit due to limits of action list size
            throw(399);
          }

          throw_unless(403 + counter, item_index <= next_item_index);
          deploy_nft_item(item_index, nft_item_code, item~load_coins(), item~load_ref());
          if (item_index == next_item_index) {
            next_item_index += 1;
          }
        }
      } until ( ~ f?);
      save_data(owner_address, next_item_index, content, nft_item_code, royalty_params);
      return ();
    }
    ;; ...
}
```

#### Change owner

The last incoming message handler is for changing ownership of the collection. It just parses `new_owner` address from the incoming message body and saves contract storage with it instead of the previous `owner`.

```func
() recv_internal(cell in_msg_full, slice in_msg_body) impure {
    ;; ...
    if (op == 3) { ;; change owner
      slice new_owner = in_msg_body~load_msg_addr();
      save_data(new_owner, next_item_index, content, nft_item_code, royalty_params);
      return ();
    }
    ;; ...
}
```

And finally, in case if none of the conditions above are met, which means that opcode provided in the message does not match any of the expected ones, it throws `0xffff` which is a common exit code for "unknown opcode" error:

```func
() recv_internal(cell in_msg_full, slice in_msg_body) impure {
    ;; ...
    throw(0xffff);
}
```

### Get-methods

Collection contract implements only the get-methods required by standards: `get_collection_data`, `get_nft_address_by_index`, `royalty_params`, and `get_nft_content`.

#### get\_collection\_data

This get-method is expected to return the count of deployed items, collection content, and an owner address. It loads the contract storage, loads the first reference from `content` cell which contains the collection content, and returns those values. The content cell structure was explained earlier.

```func
(int, cell, slice) get_collection_data() method_id {
  var (owner_address, next_item_index, content, _, _) = load_data();
  slice cs = content.begin_parse();
  return (next_item_index, cs~load_ref(), owner_address);
}
```

#### get\_nft\_address\_by\_index

This get-method is expected to take an item index and return this item's address. It uses helper functions `calculate_nft_item_state_init` and `calculate_nft_item_address` to calculate the address.

```func
slice get_nft_address_by_index(int index) method_id {
    var (_, _, _, nft_item_code, _) = load_data();
    cell state_init = calculate_nft_item_state_init(index, nft_item_code);
    return calculate_nft_item_address(workchain(), state_init);
}
```

#### royalty\_params

This get-method is expected to return royalty parameters: `numerator`, `denominator`, and `destination`, as required by the standard. These values are stored in a `royalty` cell in data which we parse here to return.

```func
(int, int, slice) royalty_params() method_id {
     var (_, _, _, _, royalty) = load_data();
     slice rs = royalty.begin_parse();
     return (rs~load_uint(16), rs~load_uint(16), rs~load_msg_addr());
}
```

#### get\_nft\_content

This get-method is expected to take an item index and item content, and returns full content of the item. It composes and returns a cell following the offchain format for metadata from TEP-64 standard.

This reference implementation works with offchain metadata format, joining common prefix stored in collection contract with individual item content from item contract. The specific way of composing the full item's content is not forced by standard, and can be implemented in any way. Since item content in offchain format is an URL pointing to a JSON with all the metadata fields, the common prefix is usually an URL to the endpoint for getting metadata for each item or a directory with all the JSONs, for example `https://example-collection.com/items/`. Then each item can contain just the suffix of the full url, which can be `123.json` for example. Then composing a full URL means joining these two strings, which this method does. This is a most common way of doing so, but it's possible to implement any custom logic of composing item content, like calcualting the suffix right in get method from the index and allowing items to not hold any additional content.

The common prefix for content is stored as a second reference in `content` cell from collection's contract storage. The resulting cell is then composed as an offchain tag `0x01`, followed by a common prefix, and finally with an individual content stored as a reference. Since content is a text in this format, it is stored in a "snake" format in a cell, meaning that text can be split in parts and stored as a chain of cells. For example, it could be composed of 4 cells, each containing just 3 letters and referencing the next one: `[abc] -> [def] -> [ghi] -> [jkl]`, and this tree of cells would represent the `abcdefghijkl` string.

```func
cell get_nft_content(int index, cell individual_nft_content) method_id {
  var (_, _, content, _, _) = load_data();
  slice cs = content.begin_parse();
  cs~load_ref();
  slice common_content = cs~load_ref().begin_parse();
  return (begin_cell()
                      .store_uint(1, 8) ;; offchain tag
                      .store_slice(common_content)
                      .store_ref(individual_nft_content)
          .end_cell());
}
```

## Item

The full source code is in [nft-item.fc](https://github.com/ton-blockchain/token-contract/blob/1182ad99413242f09925d50e70ccb7e0e09f94d4/nft/nft-item.fc) file.

The TEP-62 standard defines `transfer` and `get_static_data` messages that must be processed by item contract, and a single `get_nft_data` get-method that it must implement. With this contract, the reference implementation does not go beyond the requirements and only implement these three core features.

Below is a table showing what messages and get-methods of reference collection smart contract are forced by standards and what are not.

| Capatibility                                                     | Requirement                                    |
| ---------------------------------------------------------------- | ---------------------------------------------- |
| `get_nft_data` (get-method)                                      | Required by TEP-62, data format follows TEP-64 |
| `transfer` (inbound internal message) | Required by TEP-62                             |
| `excesses`, `ownership_assigned` (outbound internal messages) | Required by TEP-62                             |
| `get_static_data`, `report_static_data` (internal messages)      | Required by TEP-62                             |

### Storage

Same as for collection, the storage schema itself is not defined by the standard and it can be arbitrary. Here, we only have the essentials: `index` of the item, `collection_address`, `owner_address`, and `content` with individual item's content. But an important consideration with this contract is that it has two states: initialized or not initialized. It is made this way to properly support deployments only by the collection contract. When the item is not initialized yet, it only has an index and collection address - since those define its address per stateinit, while content and owner address are nulls until initialized. Below are `load_data` and `save_data` for item contract. Note that `load_data` also returns as the first value the boolean initialization flag, equal to `-1` if item is initialized and `0` if not.

```func
(int, int, slice, slice, cell) load_data() {
    slice ds = get_data().begin_parse();
    var (index, collection_address) = (ds~load_uint(64), ds~load_msg_addr());
    if (ds.slice_bits() > 0) { ;; initialized
      return (-1, index, collection_address, ds~load_msg_addr(), ds~load_ref());
    } else { ;; not initialized
      return (0, index, collection_address, null(), null()); ;; nft not initialized yet
    }
}

() store_data(int index, slice collection_address, slice owner_address, cell content) impure {
    set_data(
        begin_cell()
            .store_uint(index, 64)
            .store_slice(collection_address)
            .store_slice(owner_address)
            .store_ref(content)
            .end_cell()
    );
}
```

### Internal messages

There is a boilerpalte helper function for sending messages in this contract, just for convenience. It composes and sends a message by taking high-level arguments like `op` and `payload`:

```func
() send_msg(slice to_address, int amount, int op, int query_id, builder payload, int send_mode) impure inline {
  var msg = begin_cell()
    .store_uint(0x10, 6) ;; nobounce - int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddress -> 010000
    .store_slice(to_address)
    .store_coins(amount)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .store_uint(op, 32)
    .store_uint(query_id, 64);

  if (~ builder_null?(payload)) {
    msg = msg.store_builder(payload);
  }

  send_raw_message(msg.end_cell(), send_mode);
}
```

The `recv_internal` function begins with boilerplate code for parsing flags, sender address and estimating the forward fee. The forward fee estimation assumes that all outbound messages will not be bigger in size than the inbound message, and calculates the original forward fee of the inbound message as an upper bound. The `muldiv` operation multiplying the `fwd_fee` by 3 and dividing by 2 is an outdated way of doing that, as there exists a `get_original_fwd_fee` function which mostly does the same thing.

```func
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore empty messages
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4); ;; the `int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool` part of CommonMsgInfo

    if (flags & 1) { ;; ignore all bounced messages by checking last bit of `flags` variable
        return ();
    }
    slice sender_address = cs~load_msg_addr(); ;; the `src:MsgAddressInt` part of CommonMsgInfo

    cs~load_msg_addr(); ;; skip `dest:MsgAddressInt`
    cs~load_coins(); ;; skip `grams:Grams` from `value:CurrencyCollection`
    cs~skip_bits(1); ;; skip `other:ExtraCurrencyCollection` from `value:CurrencyCollection`
    cs~load_coins(); ;; skip ihr_fee:Grams
    int fwd_fee = muldiv(cs~load_coins(), 3, 2); ;; we use message fwd_fee for estimation of forward_payload costs
    ;; ...
}
```

Then it loads the data and handles the case when item is not initialized yet, by checking whether the incoming message was sent by the collection contract, and if it was - parses the message body and saves the new `content` and `owner_address`:

```func
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    ;; ...
    (int init?, int index, slice collection_address, slice owner_address, cell content) = load_data();
    if (~ init?) {
      throw_unless(405, equal_slices(collection_address, sender_address));
      store_data(index, collection_address, in_msg_body~load_msg_addr(), in_msg_body~load_ref());
      return ();
    }
    ;; ...
}
```

Then it parses `op` and `query_id` from the incoming message body:

```func
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    ;; ...
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);
    ;; ...
}
```

And then there are two conditions for opcodes, processing either `transfer` or `get_static_data` messages required by standard.

#### transfer

The transfer message's structure is defined by standard. It must contain, apart from opcode and `query_id`: `new_owner` which is the destination address of the item transfer, `response_destination` which is an address where contract should send the remaining Toncoin left after the transfer along with a confirmation message, `custom_payload` for extensions of the standard and additional custom logic, `forward_amount` amount of Toncoin to send to a new owner with the item transfer, and `forward_payload` which is a cell for any arbitrary data to send to a new owner with the item transfer.

The `transfer` message handler checks whether the `sender_address` equals to `owner_address`, parses those fields from the message, checks workchain of the new owner address, checks all the Toncoin values to make sure it has enough balance to complete the transfer, and finally completes the transfer by updating the `owner_address` field in storage. It also sends from 0 to 2 messages, depending on whether response message is required and whether there is any `forward_amount`. The `custom_payload` is ignored in this implementation.

The response message has `excesses` opcode and only contains the original `query_id`, with its only purpose being forwarding the remaining Toncoin value of the transfer message to some address, usually sender address.

The `ownership_assigned` message is sent only if `forward_amount` is greater than 0. It has `ownership_assigned` opcode and includes `query_id`, previous `owner_address`, and the `forward_payload` which at this point in code is the only thing left in `in_msg_body` from the original transfer message. This message is often used for processing item transfers in destination smart contracts, as well as attaching comments to transfers, and attaching any Toncoin value by specifying `forward_amount`.

```func
() transfer_ownership(int my_balance, int index, slice collection_address, slice owner_address, cell content, slice sender_address, int query_id, slice in_msg_body, int fwd_fees) impure inline {
    throw_unless(401, equal_slices(sender_address, owner_address));

    slice new_owner_address = in_msg_body~load_msg_addr();
    force_chain(new_owner_address);
    slice response_destination = in_msg_body~load_msg_addr();
    in_msg_body~load_int(1); ;; this nft don't use custom_payload
    int forward_amount = in_msg_body~load_coins();
    throw_unless(708, slice_bits(in_msg_body) >= 1);

    int rest_amount = my_balance - min_tons_for_storage();
    if (forward_amount) {
      rest_amount -= (forward_amount + fwd_fees);
    }
    int need_response = response_destination.preload_uint(2) != 0; ;; if NOT addr_none: 00
    if (need_response) {
      rest_amount -= fwd_fees;
    }

    throw_unless(402, rest_amount >= 0); ;; base nft spends fixed amount of gas, will not check for response

    if (forward_amount) {
      send_msg(new_owner_address, forward_amount, op::ownership_assigned(), query_id, begin_cell().store_slice(owner_address).store_slice(in_msg_body), 1);  ;; paying fees, revert on errors
    }
    if (need_response) {
      force_chain(response_destination);
      send_msg(response_destination, rest_amount, op::excesses(), query_id, null(), 1); ;; paying fees, revert on errors
    }

    store_data(index, collection_address, new_owner_address, content);
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    ;; ...
    if (op == op::transfer()) {
      transfer_ownership(my_balance, index, collection_address, owner_address, content, sender_address, query_id, in_msg_body, fwd_fee);
      return ();
    }
    ;; ...
}
```

#### get\_static\_data

The item contract must respond with `report_static_data` message containing item's `index` and `collection` address when receiving `get_static_data` message. This handler does exactly this, composing and sending a message with index and collection address in body.

```func
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    ;; ...
    if (op == op::get_static_data()) {
      send_msg(sender_address, 0, op::report_static_data(), query_id, begin_cell().store_uint(index, 256).store_slice(collection_address), 64);  ;; carry all the remaining value of the inbound message
      return ();
    }
    ;; ...
}
```

And finally, in case if none of the conditions above are met, which means that opcode provided in the message does not match any of the expected ones, it throws `0xffff` which is a common exit code for "unknown opcode" error:

```func
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    ;; ...
    throw(0xffff);
}
```

### Get-methods

The standard only requries `get_nft_data` get-method.

#### get\_nft\_data

It returns `init?` flag showing whether item is initialized or not, `index`, `collection_address`, `owner_address`, and `individual_content`. In case of this implementation, it returns all the values from `load_data` function as is, including the logic for setting `init?` flag.

Importantly, the `content` returned by this contract follows the format required by the collection contract, where it only includes the suffix of the URL pointing to an offchain JSON with metadata. But this is not forced by the standard, and the format can be arbitrary - the only requirements are that collection's `get_nft_content` must return a full content following TEP-64, and that if item has no collection it must return full content right away at this point, but the latter is out of the scope here.

```func
(int, int, slice, slice, cell) get_nft_data() method_id {
  (int init?, int index, slice collection_address, slice owner_address, cell content) = load_data();
  return (init?, index, collection_address, owner_address, content);
}
```
