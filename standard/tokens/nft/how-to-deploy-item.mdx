---
title: "How to deploy an NFT item"
sidebarTitle: "Deploy an NFT item"
---

import { Image } from '/snippets/image.jsx';

The creator sends a message to the collection contract, which deploys a new non‑fungible token (NFT) item with the specified data: the initial owner and the item‑specific content. The [TEP‑62](https://github.com/ton-blockchain/TEPs/blob/1fbc23cac69723c53251f686ec90d81bf0e83443/text/0062-nft-standard.md) standard does not prescribe how this data must be supplied; implementations may vary. Typically, the creator provides the initial owner and item‑specific content for each NFT, or this information is derived from the collection itself (see [cNFT](/standard/tokens/nft/cNFT-how-it-works)).

<Image
  src="/resources/images/nft/nft_deploy.svg"
  alt="NFT deployment"
/>

Since the deployment process is not specified by the standard, logic can vary and the recipes on this page might not apply to every contract. The [reference NFT implementation](/standard/tokens/nft/reference-implementation) and most modifications follow the same path: the collection owner sends a message with deploy parameters to the collection, and the collection deploys the item.

## Deploy with wallet

To deploy an item from a [wallet](/standard/wallets/how-it-works), send a message from the wallet to the collection contract. The following example uses the @ton/ton stack for TypeScript. These libraries provide interfaces to work with wallet contracts and compose messages.

### Prerequisites

- Node.js 22+
- Packages: `@ton/ton`, `@ton/core`, `@ton/crypto`
- A funded Testnet wallet mnemonic in `MNEMONIC` environment variable

```ts
import { Address, beginCell, internal, toNano } from "@ton/core";
import { TonClient, WalletContractV5R1, SendMode } from "@ton/ton";
import { mnemonicToPrivateKey } from "@ton/crypto";

async function main() {
  const msg = internal({
    to: Address.parse("<COLLECTION_ADDR>"),
    value: toNano("0.01"), // 0.01 TON for fees
    bounce: true,
    body: beginCell()
      .storeUint(1, 32) // deploy opcode
      .storeUint(0, 64) // query id
      .storeUint(0, 64) // item index
      .storeCoins(toNano("0.005")) // 0.005 TON will be sent to item contract on deployment
      .storeRef(
        beginCell()
          .storeAddress(Address.parse("<OWNER_ADDR>"))
          .storeRef(beginCell().storeStringTail("<ITEM_CONTENT>").endCell()) // individual content
          .endCell(),
      )
      .endCell(),
  });

  // Testnet Toncenter endpoint
  const client = new TonClient({
    endpoint: "https://testnet.toncenter.com/api/v2/jsonRPC",
  });

  const MNEMONIC = process.env.MNEMONIC;
  if (!MNEMONIC) throw new Error("Set MNEMONIC to a test mnemonic (testnet).");
  const keyPair = await mnemonicToPrivateKey(MNEMONIC.split(" "));
  const walletContract = client.open(
    WalletContractV5R1.create({
      workchain: 0, // basechain
      publicKey: keyPair.publicKey,
    }),
  );

  // send the mint message through the wallet
  const seqno = await walletContract.getSeqno();
  await walletContract.sendTransfer({
    seqno: seqno,
    secretKey: keyPair.secretKey,
    // good practice to use these modes for regular wallet transfers
    sendMode: SendMode.IGNORE_ERRORS | SendMode.PAY_GAS_SEPARATELY,
    messages: [msg],
  });
}

void main();
```

Where

- `<COLLECTION_ADDR>` — the collection contract address.
- `<OWNER_ADDR>` — the initial owner address for the new item.
- `<ITEM_CONTENT>` — item‑specific content path or key (for example, `0.json`).

### Verify

- Confirm the transaction succeeded in a block explorer for `<COLLECTION_ADDR>`.
- Call `get_nft_address_by_index(0)` on the collection to fetch the new item address, or open the item link in the explorer.

It composes a message, creates a `TonClient` object to interact with the chain through [Toncenter](/ecosystem/api/toncenter/overview), initializes a wallet from mnemonic, and send a message.

## Deploy with smart contract

To deploy an item from a smart contract, send a message from the contract to the collection contract. The following example provides a minimal example that implements only the item deployment logic. In realistic cases this is integrated into a larger flow.

### Prerequisites

- Enough Testnet TON to cover fees for contract and item deployments

```tolk
// SnakeString describes a (potentially long) string inside a cell;
// short strings are stored as-is, like "my-picture.png";
// long strings are nested refs, like "xxxx".ref("yyyy".ref("zzzz"))
type SnakeString = slice

fun SnakeString.unpackFromSlice(mutate s: slice) {
    // SnakeString can be only the last: it's "the remainder";
    // for correctness, it's better to validate it has no more refs:
    assert (s.remainingRefsCount() <= 1) throw 5;
    val snakeRemainder = s;
    s = createEmptySlice(); // no more left to read
    return snakeRemainder
}

fun SnakeString.packToBuilder(self, mutate b: builder) {
    b.storeSlice(self)
}

struct NftItemInitAtDeployment {
    ownerAddress: address
    content: Cell<SnakeString>
}

struct (0x00000001) DeployNft {
    queryId: uint64
    itemIndex: uint64
    attachTonAmount: coins
    initParams: Cell<NftItemInitAtDeployment>
}

fun onInternalMessage(in: InMessage) {
    // The whole logic will be in `onInternalMessage`
    // for example purposes. In realistic cases this should
    // usually be gated behind some auth and other checks.

    val deploy = DeployNft {
        queryId: 0,
        itemIndex: 0,
        attachTonAmount: ton("0.005"), // will be sent to item contract on deployment
        initParams: NftItemInitAtDeployment {
            ownerAddress: address("<OWNER_ADDR>"),
            content: ("<ITEM_CONTENT>" as SnakeString).toCell()
        }.toCell()
    };

    val msg = createMessage({
        bounce: true,
        dest: address("<COLLECTION_ADDR>"),
        value: ton("0.01"),
        body: deploy
    });

    msg.send(SEND_MODE_PAY_FEES_SEPARATELY);
}
```

Where

- `<COLLECTION_ADDR>` — the collection contract address.
- `<OWNER_ADDR>` — the initial owner address for the new item.
- `<ITEM_CONTENT>` — item‑specific content path or key (for example, `0.json`).

The top of the snippet defines structs for the deploy message and can be modified depending on the NFT implementation specifics. The sending logic lives in `onInternalMessage` for simplicity. It composes a message with hard‑coded example values and sends that message to the collection contract.

### Verify

- Confirm the transaction succeeded in a block explorer for `<COLLECTION_ADDR>`.
- Call `get_nft_address_by_index(0)` on the collection to fetch the new item address, or open the item link in the explorer.
