---
title: "How to deploy NFT item"
sidebarTitle: "How to deploy NFT item"
---

import { Aside } from '/snippets/aside.jsx';
import { Image } from '/snippets/image.jsx';

The creator sends a message to the collection contract, which deploys a new NFT item with the specified data, including initial owner and item‑specific content. The [TEP‑62](https://github.com/ton-blockchain/TEPs/blob/1fbc23cac69723c53251f686ec90d81bf0e83443/text/0062-nft-standard.md) standard does not prescribe exactly how this data must be supplied. Custom modifications of NFT contracts can implement this logic differently. Typically the creator provides the initial owner and item‑specific content for each NFT, or this information is derived from the collection itself (see [cNFT](/standard/tokens/nft/cNFT-how-it-works)).

<Image
  src="/resources/images/nft/nft_deploy.svg"
  alt="NFT deployment"
/>

Since the deployment process is not specified by the standard, the logic can vary and recipes listed on this page might not apply. But the [reference NFT implementation](/standard/tokens/nft/reference-implementation) and most modifications follow the same path where collection's owner sends a message with deploy parameters to collection, and collection then actually deploys the item.

## Deploy with wallet

To deploy an item from a [wallet](/standard/wallets/how-it-works) we have to send a message from that wallet to collection contract. The following example uses @ton/ton stack for TypeScript. These libraries provide interfaces to work with wallet contracts and composse messages.

```ts
import { Address, beginCell, internal, toNano } from "@ton/core";
import { TonClient, WalletContractV5R1, SendMode } from "@ton/ton";
import { mnemonicToPrivateKey } from "@ton/crypto";

async function main() {
  const msg = internal({
    to: Address.parse("EQASkeWqAUdq4-9AS68fsvxuHr8sze7KushNeDKHdCDCFCVF"), // collection
    value: toNano("0.01"), // 0.01 ton for fees
    bounce: true,
    body: beginCell()
      .storeUint(1, 32) // deploy opcode
      .storeUint(123, 64) // query id
      .storeUint(0, 64) // item index
      .storeCoins(toNano("0.005")) // 0.005 ton will be sent to item contract on deployment
      .storeRef(
        beginCell()
          .storeAddress(
            Address.parse("UQBKgXCNLPexWhs2L79kiARR1phGH1LwXxRbNsCFF9doczSI"),
          ) // owner
          .storeRef(beginCell().storeStringTail("0.json").endCell()) // individual content
          .endCell(),
      )
      .endCell(),
  });

  // testnet toncenter endpoint
  const client = new TonClient({
    endpoint: "https://testnet.toncenter.com/api/v2/jsonRPC",
  });

  const MNEMONIC = process.env.MNEMONIC;
  if (!MNEMONIC) throw new Error("Set MNEMONIC to a test mnemonic (testnet).");
  const keyPair = await mnemonicToPrivateKey(MNEMONIC.split(" "));
  const walletContract = client.open(
    WalletContractV5R1.create({
      workchain: 0, // basechain
      publicKey: keyPair.publicKey,
    }),
  );

  // send the mint message through your wallet
  const seqno = await walletContract.getSeqno();
  await walletContract.sendTransfer({
    seqno: seqno,
    secretKey: keyPair.secretKey,
    // good practice to use these modes for regular wallet transfers
    sendMode: SendMode.IGNORE_ERRORS | SendMode.PAY_GAS_SEPARATELY,
    messages: [msg],
  });
}

void main();
```

It composes a message, creates a `TonClient` object to interact with the chain through [Toncenter](/ecosystem/api/toncenter/overview), initializes a wallet from mnemonic, and send a message.

## Deploy with smart contract

To deploy an item from a smart contract we have to send a message from that smart contract to collection contract. The following example implements a minimal reproducible example, without any extra logic apart from the item deployment. In realistic cases this would be integrated as a part of some larger logic.

```tolk
// SnakeString describes a (potentially long) string inside a cell;
// short strings are stored as-is, like "my-picture.png";
// long strings are nested refs, like "xxxx".ref("yyyy".ref("zzzz"))
type SnakeString = slice

fun SnakeString.unpackFromSlice(mutate s: slice) {
    // SnakeString can be only the last: it's "the remainder";
    // for correctness, it's better to validate it has no more refs:
    assert (s.remainingRefsCount() <= 1) throw 5;
    val snakeRemainder = s;
    s = createEmptySlice(); // no more left to read
    return snakeRemainder
}

fun SnakeString.packToBuilder(self, mutate b: builder) {
    b.storeSlice(self)
}

struct NftItemInitAtDeployment {
    ownerAddress: address
    content: Cell<SnakeString>
}

struct (0x00000001) DeployNft {
    queryId: uint64
    itemIndex: uint64
    attachTonAmount: coins
    initParams: Cell<NftItemInitAtDeployment>
}

fun onInternalMessage(in: InMessage) {
    // The whole logic will be in `onInternalMessage`
    // for example purposes. In realistic cases this should
    // usually be gated behind some auth and other checks.

    val deploy = DeployNft {
        queryId: 123,
        itemIndex: 0,
        attachTonAmount: ton("0.005"), // will be sent to item contract on deployment
        initParams: NftItemInitAtDeployment {
            ownerAddress: address("UQBKgXCNLPexWhs2L79kiARR1phGH1LwXxRbNsCFF9doczSI"),
            content: ("0.json" as SnakeString).toCell()
        }.toCell()
    };

    val msg = createMessage({
        bounce: true,
        dest: address("EQDmJlN-cAQp9AQFmJ6an8MTF90FDsjNazuQg4YbKZwlzNnz"), // collection
        value: ton("0.01"),
        body: deploy
    });

    msg.send(SEND_MODE_PAY_FEES_SEPARATELY);
}
```

Top of the snippet define structs for the deploy message, and can be modified depending on the NFT implementation specifics. The sending logic lives in `onInternalMessage` for simplicity. It composes a message with hardcoded example values and sends that message to collection contract.
