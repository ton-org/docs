---
title: "Airdrop"
---

import { Aside } from '/snippets/aside.jsx';

## The problem: distributing at scale

You want to reward thousands (or millions) of users. Sending assets to each address proactively looks simple-until you see the bill. Network fees add up fast when the sender pays for every transfer.

## The twist: let users claim

An airdrop flips the model. Instead of the distributor paying all fees, each eligible user claims their allocation and covers the network fees themselves.

The straightforward approach is to keep a precomputed mapping of recipient → allocation in the contract. When a user sends a claim message, the contract releases the preassigned drop for that user.

![Claim](/standard/tokens/pictures/claim.png)

## The naive approach-and its limit

Keep a precomputed mapping of recipient → allocation in the contract. When a user sends a claim message, the contract releases the preassigned amount. This works-until the list becomes too large. A single contract has storage limits.

## The scalable design: shard and prove

To scale, we split state across many contracts ([contract sharding](/techniques/contract-sharding)) and keep only a compact commitment to the list on-chain: a root hash of a dictionary (see [hashmap](/language/TL-B/complex-and-non-trivial-examples#hashmap)). Users then present a [Merkle proof](/ton/proofs/basic-proof-concepts) to claim.

We must also prevent double-claims. The airdrop deploys a small per-user proxy contract (related to [contract sharding](/techniques/contract-sharding)) that serves as a marker of whether the user has already claimed. This proxy blocks any subsequent attempts.

<Aside>
  Why not simply update the Merkle root with each claim?

  With many users, several claims are likely to arrive concurrently. After the first update, all other in-flight proofs become stale, causing many transactions to fail.
</Aside>

## How to prepare

1. Prepare a list of eligible recipients and their allocations, and construct a dictionary (see [hashmap](/language/TL-B/complex-and-non-trivial-examples#hashmap)).
1. Store the root hash in the airdrop contract.
1. Provide each user with their [Merkle proof](/ton/proofs/basic-proof-concepts) (or enable self-service proof retrieval).

## Claim flow

1. The user sends a message that deploys their per-user proxy contract (see [contract sharding](/techniques/contract-sharding)) along with their Merkle proof.
1. If valid, the proxy records that the claim has been made and rejects further requests.
1. The airdrop contract verifies the [Merkle proof](/ton/proofs/basic-proof-concepts) and transfers the asset to the address specified in the proof.

![Merkle claim](/standard/tokens/pictures/merkle-claim.png)
