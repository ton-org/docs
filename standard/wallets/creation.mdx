---
title: "How to interact with TON wallet"
sidebarTitle: "How to interact"
---

import { Aside } from '/snippets/aside.jsx'

In this article we will overview how to create wallet programmatically, how to match it with wallets created from mnemonic in user applications (e.g. TonKeeper, TonWallet) and how to deploy it, if it has state uninit. Also we will look at

## Wallet address

Wallets in TON [are smart contracts](/standard/wallets/how-it-works). That means that wallet address is derived using the same rules as for any other account on the blockchain - address is derived from [State Init](/foundations/addresses/overview).

In case of a wallet contract, two fields determine its address:

- `public_key`, [dependent on mnemonic](/standard/wallets/mnemonics)
- `wallet_id`, special [salt-like](https://en.wikipedia.org/wiki/Salt_\(cryptography\)) field, dependent on wallet contract type and network

<Aside type="note">
  Sometimes `wallet_id` is also called `subwallet_id` in some of the libraries and documentation. They mean the same thing.
</Aside>

This means that if you have correct mnemonic, you will need to match `wallet_id` to get the expected wallet address.

## Matching wallet applications

The most common use-case for wallet addresses is to match wallet created from the wallet application (e.g. TonKeeper, TonWallet) and the one you get in your source code for programming. The first obvious thing is to use the same mnemonic/public key - you can't match wallet address without it. [Read here](/standard/wallets/mnemonics) to learn more about mnemonics.

Next, you will need to match `wallet_id`. It is different between wallet versions and network (mainnet and testnet).

### Default wallet\_id values

| Network | Wallet V4R2              | Wallet V5                 |
| ------- | ------------------------ | ------------------------- |
| Mainnet | `0x29a9a317` (698983191) | `0x7FFFFF11` (2147483409) |
| Testnet | `0x29a9a317` (698983191) | `0x7FFFFFFD` (2147483645) |

Explanation:

For Wallet V4R2 `wallet_id` is defined as first 4 bytes from TON mainnet blockchain initial state hash. There is no specific logic why this number was chosen, community needed some default value and this one works well enough.

For Wallet V5, as you can see above, `wallet_id` is different between Mainnet and Testnet. This is implemented for security reasons, so that you will get different wallet addresses for different networks with same mnemonic and it will save some developers and users from fund loss.

This value is obtained from 4 parameters:

- `network_id`: `-239` for mainnet, `-3` for testnet
- `wallet_version`: for now always `0`
- `subwallet_number`: `0` by default
- `workchain`: `0` for Basechain

Algorithm for generating `wallet_id` from this parameters:

<Aside type="note">
  Algorithm here is presented for education purpose, in most cases you won't need to implement it yourself, instead use existing implementation from libraries.
</Aside>

```ts
type WalletIdV5 = {
    // always 0 for now
    readonly walletVersion: number;

    /**
     * -239 is mainnet, -3 is testnet
     */
    readonly networkGlobalId: number;

    // 0 for Basechain
    readonly workchain: number;

    // 0 for the first wallet with this mnemonic
    readonly subwalletNumber: number;
}

export function storeWalletIdV5(walletId: WalletIdV5) {
    return (builder: Builder) => {
        builder.storeInt(walletId.networkGlobalId, 32);
        builder.storeInt(walletId.workchain, 8);
        builder.storeUint(walletId.walletVersion, 8);
        builder.storeUint(walletId.subwalletNumber, 32);
    }
}
```

## Examples

We will use `@ton/ton` Typescript library for wallet wrappers.

### Wallet V4R2

```ts
import { mnemonicToPrivateKey } from '@ton/crypto';
import { WalletContractV4 } from '@ton/ton';

// this magic number is default wallet_id for V4R2 wallet contract;
const walletIdV4R2 = 0x29a9a317;

// your 12‑ or 24‑word mnemonic (space‑separated)
const mnemonicV4 = 'bread table ...';

// async function for await
const main = async () => {
  const keyPairV4 = await mnemonicToPrivateKey(mnemonicV4.split(' '));

  const walletContractV4 = WalletContractV4.create({
        workchain: 0,
        publicKey: keyPairV4.publicKey,
        walletId: walletIdV4R2,
    });

  console.log(walletContractV4.address);
}

main();
```

### Wallet V5

```ts
import { mnemonicToPrivateKey } from '@ton/crypto';
import { WalletContractV5R1 } from '@ton/ton';

// your 12‑ or 24‑word mnemonic (space‑separated).
const mnemonicV5 = 'bread table ...';

// async function for await
const main = async () => {
  const keyPairV5 = await mnemonicToPrivateKey(mnemonicV5.split(' '));

  // testnet
  const testnetV5Wallet = WalletContractV5R1.create({
        walletId: {
            networkGlobalId: -3,
        },
        publicKey: keyPairV5.publicKey,
        workchain: 0,
    });

  console.log(testnetV5Wallet.address);

  // mainnet
  const mainnetV5Wallet = WalletContractV5R1.create({
        walletId: {
            networkGlobalId: -239,
        },
        publicKey: keyPairV5.publicKey,
        workchain: 0,
    });

  console.log(mainnetV5Wallet.address);
}

main();
```

After creating wallet contract instance, you can use it to [send messages to the blockchain](/standard/wallets/v5-api).

## Transfer comments

TON [wallet apps](/ecosystem/wallet-apps/overview) can attach short human-readable notes — commonly called _comments_ — to outgoing internal messages. On-chain they are just message bodies with a specific layout that wallets agree to interpret as text.

### Comment format

- The first 32 bits of the incoming message body must be the opcode `0x00000000`. This value signals that the rest of the payload should be treated as a comment.
- The remaining bytes are UTF-8 encoded text. Wallets should decode the bytes as-is and tolerate invalid or empty strings — many senders emit messages without a comment or with zero-length payloads.
- When parsing, always inspect the opcode before assuming a text comment. If the opcode differs, fall back to handling other contract-specific payloads.

Because comments ride inside ordinary internal messages, the format works identically for:

- native Toncoin transfers between wallets;
- Jetton transfers, where the wallet forwards an internal message to the token wallet along with the comment payload;
- NFT transfers, where the comment travels in the same forwarding message that moves the ownership record.

### Attaching a comment when sending

To include a comment in an outgoing transfer, construct an internal message body that starts with `0x00000000` and append the UTF-8 bytes of the note you want to share. Most wallet libraries expose helpers for this, but the underlying steps are:

1. Allocate a cell.
1. Store the 32-bit zero opcode.
1. Store the text as a [byte string](/languages/TL-B/simple-examples) (UTF-8 encoded).
1. Send the internal message along with the desired Toncoin, [Jettons](/standard/tokens/jettons/how-it-works), or [NFT](/standard/tokens/nfts/how-it-works) payload.

Receivers that follow the convention will display the decoded text to the user. Contracts that do not recognize the opcode will simply ignore it or treat the message body as opaque data, so comments are backward-compatible with existing transfers.

### Example: Sending a comment with `@ton/ton`

```ts
import { Cell, beginCell } from '@ton/core';

function createCommentCell(comment: string): Cell {
    return beginCell()
        .storeUint(0, 32) // opcode for comment
        .storeStringTail(comment) // UTF-8 encoded text in snake encoding
        .endCell();
}
```
