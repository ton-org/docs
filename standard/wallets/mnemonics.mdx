---
title: "Mnemonics"
sidebarTitle: "Mnemonics"
---

import { Aside } from '/snippets/aside.jsx';


## Key pair 

TON Blockchain uses asymmetric cryptography, such as the [Ed25519](https://en.wikipedia.org/wiki/EdDSA#Ed25519) signature scheme.

There are multiple ways to derive a key pair from a mnemonic. Below is the most common approach in TON.

<Aside>
  Some apps in the TON ecosystem may use a different derivation method, eventually producing an Ed25519-conformant key pair.
</Aside>

## Key pair from a mnemonic

To transform a mnemonic phrase into a key pair, a `seed` is first derived using [PBKDF2](https://en.wikipedia.org/wiki/PBKDF2), and the key pair is then derived from that `seed`.

PBKDF2 has [five input parameters](https://en.wikipedia.org/wiki/PBKDF2#Key_derivation_process): `PRF`, `Password`, `Salt`, `c`, and `dkLen`. Each of those parameters is assigned a concrete value.

The most commonly used values are:

| Parameter  | Description | Value
| :--------- | :---------- | :----
| `PRF`      | Pseudo-random function of two parameters | [HMACâ€‘SHA512](https://en.wikipedia.org/wiki/HMAC)
| `Password` | Master password from which a derived key is generated | `""`
| `Salt`     | Sequence of bits, known as a [cryptographic salt](https://en.wikipedia.org/wiki/Salt_(cryptography)) | `"TON default seed"`
| `c`        | Number of iterations desired | 100000
| `dkLen`    | Desired bit-length of the derived key | 64

### Generate a key pair 

```ts title="TypeScript"
import { mnemonicToPrivateKey, mnemonicNew } from "@ton/crypto";

// Replace with your own persisted mnemonic phrase (see note below).
const mnemonicArray = await mnemonicNew();

// derive private and public keys from the mnemonic
const keyPair = await mnemonicToPrivateKey(mnemonicArray); 

console.log("Public Key: " + keyPair.publicKey.toString('hex'));
console.log("Private Key: " + keyPair.secretKey.toString('hex'));
```

The private key is needed to sign messages, and the public key is stored in the wallet's smart contract. When new external messages arrive on that smart contract, the public key would be used to check the authenticity of the messages signed using the corresponding private key.

<Aside type="caution" title="Important">
  Persist the generated mnemonic seed phrase. If you need deterministic behavior during development, print and reuse the exact phrase so the wallet derives the same key pair on every run.
</Aside>

## Mnemonic validation 

1. Check that all the words are from the list of [BIP-39](https://github.com/ton-org/ton-crypto/blob/c3435833a0da52a96f674c352c4c6f91fcc07f6d/src/mnemonic/wordlist.ts#L9). 
2. If we have a password: the first byte of the derived `seed` with parameters `c` - `1` and `Salt` is `"TON fast seed version"` must be equal `0`.
3. If we don't have a password: the first byte of the derived `seed` with parameters `c` - $\mathrm{floor}(\frac{100000}{256}) = 390$, 'Slat' is `"TON seed version"` must be equal `1`.

Random mnemonic phrases are generated until PBKDF2 yields a seed whose first byte is zero, and then function returns valid mnemonic.

### Generate a mnemonic

```ts title="TypeScript"
import { mnemonicNew } from "@ton/crypto";

const mnemonicArray = await mnemonicNew(); 
console.log(mnemonicArray); 
```