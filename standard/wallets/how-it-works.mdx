---
title: "How TON wallets work"
sidebarTitle: "How they work"
---

import { Aside } from '/snippets/aside.jsx';

Wallets are often the entry point of transactions in TON. See [external messages](/foundations/whitepapers/ton#2-4-6-external-messages%2C-or-messages-from-nowhere).

### General principle

A wallet smart contract stores two critical variables — the public key and the sequence number (`seqno`). Together, they secure the wallet.

Using the public key, the contract verifies that the request comes from the wallet owner; using `seqno`, it protects against replayed transactions (see [How replay protection works](#how-replay-protection-works)).

## Why wallet contracts don't store a `balance` field

In TON, an account's balance is not stored inside the smart contract's persistent data. It is a part of the protocol-level account state, maintained by validators and updated automatically when value is received/sent and when fees are paid.

Therefore, a wallet contract does not and should not keep a separate `balance` variable in storage. Doing so would be redundant and could drift out of sync with the actual account state.

From outside, the balance is exposed via RPC and blockchain explorers as part of the public account state.

## How ownership verification works

Wallet contracts use the Ed25519 signature scheme.
You generate a private key (keep it safe) and a public key (stored in the contract; readable by anyone).

<Aside
  type="caution"
  title="Important"
>
  The public key is not the wallet address. The address is derived from the contract’s `StateInit` and other parameters. See [address formats](/foundations/addresses/formats).
</Aside>

An external message is sent to the contract (containing a 512‑bit signature and the desired payload). Ed25519 verifies that the provided signature matches the hash of the message.

## How replay protection works

<Aside
  type="note"
  title="Why do we need replay protection?"
>
  Imagine Alice has 100 TON. Alice sends 10 Toncoin to Bob as a gift. Bob, being sneaky, forwards an identical message to Alice's wallet and would receive another 10 TON — unless the wallet prevents replays.
</Aside>

Each transaction carries a counter value (in our case, `seqno`) that must be unique and strictly increasing for every outgoing transaction. Because `seqno` changes, the message hash changes as well, making it impossible to reuse a previous signature.

### Role of `valid_until`

`valid_until` is a Unix timestamp embedded into the wallet’s signing message. The wallet rejects any external message if the current time exceeds this value. This limits the lifetime of a signature and prevents an attacker from replaying a captured message indefinitely.

It also makes retries safe: a client may re-send the same signed message until the deadline; after it expires, the client must re-sign with a new `valid_until`. Combined with `seqno` equality (the contract accepts only the exact current `seqno` and increments it on success), this provides robust replay protection.

## Subwallet ID

`subwallet_id` is a 32‑bit identifier tied to a wallet instance. It is set at wallet creation time and is included in the signing message. On each external call, the wallet verifies that the provided `subwallet_id` matches its own; otherwise, the message is rejected.

By varying `subwallet_id`, you can deploy multiple independent wallet contracts controlled by the same public key, each with its own address and `seqno`. This is useful for separating accounts, environments, or business lines while keeping a single keypair.

<Aside
  type="caution"
  title="Important"
>
  Changing `subwallet_id` creates a different wallet address. Funds are not shared across subwallets even if they use the same public key.
</Aside>

## Transfer comments

Ton wallets can attach short human-readable notes — commonly called _comments_ — to outgoing internal messages. On-chain they are just message bodies with a specific layout that wallets agree to interpret as text.

### Comment format

- The first 32 bits of the incoming message body must be the opcode `0x00000000`. This value signals that the rest of the payload should be treated as a comment.
- The remaining bytes are UTF-8 encoded text. Wallets should decode the bytes as-is and tolerate invalid or empty strings — many senders emit messages without a comment or with zero-length payloads.
- When parsing, always inspect the opcode before assuming a text comment. If the opcode differs, fall back to handling other contract-specific payloads.

Because comments ride inside ordinary internal messages, the format works identically for:

- native Toncoin transfers between wallets;
- Jetton transfers, where the wallet forwards an internal message to the token wallet along with the comment payload;
- NFT transfers, where the comment travels in the same forwarding message that moves the ownership record.

### Attaching a comment when sending

To include a comment in an outgoing transfer, construct an internal message body that starts with `0x00000000` and append the UTF-8 bytes of the note you want to share. Most wallet libraries expose helpers for this, but the underlying steps are:

1. Allocate a cell.
1. Store the 32-bit zero opcode.
1. Store the text as a byte string (UTF-8 encoded).
1. Send the internal message along with the desired Toncoin, Jettons, or NFT payload.

Receivers that follow the convention will display the decoded text to the user. Contracts that do not recognize the opcode will simply ignore it or treat the message body as opaque data, so comments are backward-compatible with existing transfers.
