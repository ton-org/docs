---
title: "Debugging smart contracts"
---

import {Aside} from "/snippets/aside.jsx";

<Aside>
  All examples from this article are available on [Github](https://github.com/ton-org/docs-examples/tree/main/guidebook/debug).
</Aside>

Errors in smart contracts can produce unexpected [exit code](/tvm/exit-codes), often indicating a bug in the contract.
Use debugging methods to locate and fix the issue.

## Log to the console

Print common values — such as transactions and get-method results — to debug your contract.

- Use `findTransaction()` to find a transaction by its properties.
- Use `flattenTransaction()` to inspect transactions in a developer-friendly format.

```ts TypeScript
import { toNano } from '@ton/core';
import { Blockchain } from '@ton/sandbox';
import '@ton/test-utils';
import { Test } from './output/sample_Test';
import { findTransaction, flattenTransaction } from '@ton/test-utils';

const setup = async () => {
    const blockchain = await Blockchain.create();
    const owner = await blockchain.treasury('deployer');
    const contract = blockchain.openContract(await Test.fromInit());
    const deployResult = await contract.send(owner.getSender(), { value: toNano(0.5), bounce: true }, null);

    return { blockchain, owner, contract, deployResult };
};

it('should deploy correctly', async () => {
    const { contract, deployResult } = await setup();

    const txToInspect = findTransaction(deployResult.transactions, {
        to: contract.address,
        deploy: true,
    });
    if (txToInspect === undefined) {
        throw new Error('Requested tx was not found.');
    }
    // User-friendly output
    console.log(flattenTransaction(txToInspect));
    // Verbose output
    console.log(txToInspect);
});
```

## Dump values from a contract

There are three TVM debug [instructions](/tvm/instructions#fe-debug): `DUMPSTK`, `STRDUMP`, and `DUMP`.

Availability depends on the language you use.

These instructions are wrapped in functions with different names in each language:

- In Tolk, use functions from the globally available `debug` object.
- In FunC, these methods are available globally in `stdlib.fc`.
- In Tact, use `dumpStack` for `DUMPSTK` and the [dump function](https://docs.tact-lang.org/ref/core-debug/#dump) for the other two. Tact also prints the exact line where `dump` is called, so you can quickly find it in your code.

<Aside
  type="caution"
>
  Debug instructions consume gas and affect gas measurement. Remove them before measuring gas or deploying to production.
</Aside>

## Explore TVM logs

```ts TypeScript
const blockchain = await Blockchain.create();
blockchain.verbosity.vmLogs = "vm_logs";
```

Of all [verbosity levels](/ecosystem/blueprint/testing/reference#verbosity-2), two are the most useful:

- `vm_logs` — outputs VM logs for each transaction; includes executed instructions and occurred exceptions.
- `vm_logs_full` — outputs full VM logs for each transaction; includes executed instructions with binary offsets, the current stack for each instruction, and gas used by each instruction.

Typical output for `vm_logs` looks like this:

```text
...
execute SWAP
execute PUSHCONT x30
execute IFJMP
execute LDU 64
handling exception code 9: cell underflow
default exception handler, terminating vm with exit code 9
```

The contract attempts to load a 64-bit integer from the slice using `LDU 64.`
Since there is not enough data, [exit code 9](/tvm/exit-codes#9%3A-cell-underflow) is triggered.

Inspect the same code with the `vm_logs_full` verbosity level. The output is heavily truncated at the top.

```text
...
execute PUSHCONT x30
gas remaining: 999018
stack: [ 500000000 CS{Cell{02b168008d0d4580cd8f09522be7c0390a7a632bda4a99291c435b767c95367ebe78e9af0023d36bc5f97853f4c898f868f95b035ae8f555a321d0ffce8d9f6165e2252d7a9077359400060e9fc800000000003d0902d1b85b3919} bits: 711..711; refs: 2..2} 0 Cont{vmc_std} ]
code cell hash: F9EAC82B7999AEEF696D592FE2469B9069FB05ED35C92213D7EE516F45AB97CA offset: 344
execute IFJMP
gas remaining: 999000
stack: [ 500000000 CS{Cell{02b168008d0d4580cd8f09522be7c0390a7a632bda4a99291c435b767c95367ebe78e9af0023d36bc5f97853f4c898f868f95b035ae8f555a321d0ffce8d9f6165e2252d7a9077359400060e9fc800000000003d0902d1b85b3919} bits: 711..725; refs: 2..2} ]
code cell hash: F9EAC82B7999AEEF696D592FE2469B9069FB05ED35C92213D7EE516F45AB97CA offset: 352
execute LDU 64
handling exception code 9: cell underflow
default exception handler, terminating vm with exit code 9
```

<Aside type="tip">
  To investigate the error in more detail, examine the TVM source code for the `LDU` instruction.
  Sometimes several instructions are implemented within a single `exec_*` method. For example, [LDU](/tvm/instructions#d3-ldu) (`load_uint`), [LDI](/tvm/instructions#d2-ldi) (`load_int`) and it's preload versions (`preload_uint`and`preload_int`).

  Check how `LDU` [is implemented](https://github.com/ton-blockchain/ton/blob/34823b1ea378edbe3bc59f3bcc48126480a0b768/crypto/vm/cellops.cpp#L981).
</Aside>

Stack is printed as `[bottom, ..., top]`, where `top` is the top of the stack.

Here, the stack contains two values:

- **Top:** the slice from which data is being read — `CS{Cell{...} bits: 711..725; refs: 2..2}`
- **Bottom:** an integer value — `500000000`

However, the slice contains only **725** bits, of which **711** bits and both [references](/tvm/serialization/cells) have already been read. The contract attempted to read **64** more bits, but the slice did not contain enough remaining data.

In FunC, locate the `load_uint(64)` call causing the issue and ensure enough bits are available or adjust the read width.

**TVM log limits**

The size of TVM debug output depends on the verbosity level:

| Level |                                     Setting                                    |        Max size       |
| ----- | :----------------------------------------------------------------------------: | :-------------------: |
| 0     |                                     `none`                                     | 256 bytes _(default)_ |
| 1–4   | `vm_logs` <br /> `vm_logs_location` <br /> `vm_logs_gas` <br /> `vm_logs_full` |          1 MB         |
| 5     |                                `vm_logs_verbose`                               |         32 MB         |

When the output exceeds its limit, it is truncated **from the bottom** —
older entries are discarded, and only the most recent lines are kept.
Logs are **not rotated**.

## Explore the trace

For traces that are not too large, print all transactions and inspect them.

```ts TypeScript
const deployRes = await contract.send(owner.getSender(), { value: toNano(0.5), bounce: true }, null);
for (const tx of deployRes.transactions) {
    console.log(flattenTransaction(tx));
}
```

For complex traces, use a GUI tool. Two tools are commonly used:

- [TonDevWallet trace view](/ecosystem/wallet-apps/dev) — requires the TonDevWallet application; does not require a custom `@ton/sandbox`; requires the `@tondevwallet/traces` package.
- [TxTracer Sandbox](https://txtracer.ton.org/sandbox/) — requires a custom `@ton/sandbox` package; runs in your browser.

Also, these tools allow you to explore each transaction's logs.

## Debugging with TVM Retracer

Even when a contract executes successfully (exit code = `0`) with no errors, the actions may not produce the expected on-chain result. [TVM Retracer](https://retracer.ton.org/) lets you replay the transaction and inspect VM-level execution.

### Scenarios for retracing

- All [execution phases](/foundations/phases) complete without errors, yet the expected outcome is missing.
- An action is skipped, or a transfer does not reach its destination.
- You need a step-by-step view of how the TVM executed your contract logic.

### How to analyze a transaction

1. Obtain the transaction hash from a [blockchain explorer](/ecosystem/explorers/overview).
1. Open [TVM Retracer](https://retracer.ton.org/) and enter the transaction hash.
1. Review the execution:

- Inspect **Logs section** for executed instructions and exceptions.
- Examine **Actions cell (C5)** to review data passed between contracts.
- Check **message modes** — some modes can suppress errors, causing actions to be skipped.
