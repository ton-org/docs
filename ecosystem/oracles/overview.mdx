---
title: "Oracles overview"
sidebarTitle: "Overview"
---

Blockchain oracles are entities that connect the blockchain to external systems, allowing smart contracts to be executed based on real-world inputs.

## How blockchain oracles work

Although oracles are **not part** of the blockchain itself, they play a key role in its functionality by acting as **trusted intermediaries** that deliver verified external data to smart contracts.

Most oracles are decentralized, reducing the risks of relying on a single data source. The distributed design improves security and reliability by verifying data across multiple nodes before it is used in smart contracts. This approach also minimizes manipulation and errors, ensuring that the information provided is accurate and up-to-date.

## Types of blockchain oracles

Blockchain oracles can be classified by how they operate, where oracles obtain data, the direction of data flow, and their governance structure. This section focuses on the most common types.

### Push and pull oracles

Push and pull oracles differ in how data is delivered to on-chain smart contracts.

- In **push oracles**, the data provider continuously _pushes_ the latest data to the centralized trusted contract.

- In **pull oracles**, users retrieve the latest data from off-chain providers and then verify it through the oracle contract. Pull oracles work better for real-world applications in TON. Learn more about the pull model in TON [here](#oracles-in-ton).

See [ChainLink - Pull vs Push oracles](https://chain.link/education-hub/pull-oracles-vs-push-oracles) for a detailed explanation of push and pull oracle models.

### Centralized and decentralized oracles

- Centralized oracles are controlled by a single party, which creates security and reliability risks.

- Decentralized oracles use multiple nodes to verify data, making them more secure and reliable.

### Cross-chain oracles

Cross-chain oracles _transfer data between different blockchains_ and are a key component of bridges. They enable decentralized applications to perform cross-chain transactions, such as transferring crypto assets between networks.

## Application of blockchain oracles

Blockchain oracles bridge the digital world of blockchains and the real world, enabling a wide range of applications. The following are some of the most common use cases.

### DeFi (decentralized finance)

Oracles provide market price and cryptocurrency data to DeFi platforms, enabling token values to be linked to real assets. This is essential for controlling liquidity and securing users' positions. Accurate price feeds are necessary for lending platforms to ensure proper collateral valuation and risk management, improving transparency, security, and stability of financial transactions.

### Prediction markets

Oracles aggregate and analyze data from multiple sources to determine real-world events. This enables prediction and insurance contracts to automatically pay claims, reducing manual processing and speeding up response times.

### Random number generation

Generating random numbers in smart contracts is difficult because all operations must be reproducible and predictable, which contradicts the concept of randomness. Computational oracles solve this problem by supplying external data to contracts to produce verifiable random numbers for games and lotteries, ensuring fairness and transparency.

Read more: [Randomness in TON](/contract-dev/random)

## Oracles in TON

Since TON's execution model is [asynchronous](/guides/from-ethereum), classic methods for interacting with oracles, such as get methods during a transaction, cannot be applied.

Instead, the recommended way to retrieve data from an oracle is the [carry-value pattern](/patterns/carry-value), where a contract sends an internal message to the oracle contract and verifies the response to obtain the needed data.

This pattern works efficiently with **pull** oracles, providing minimal latency. Pull oracles allow full control over update frequency, enabling contracts to obtain data as often as needed.

With **push** oracles, two internal messages — carry and value — are required to retrieve data. Data relevance depends on the provider’s up-time and update intervals. For example, if updates occur every 10 minutes, the data may be outdated by approximately 5 minutes.

### Push oracle flow

1. The data provider pushes the latest data on-chain.
1. The user contract, which needs prices on-chain, sends a request message to the trusted oracle contract.
1. The oracle contract replies to the sender address with a response internal message, containing the requested data.
1. The user contract receives an oracle response, verifies the sender address, and then is ready to use the provided data.

### Pull oracle flow

1. Users' off-chain backend calls the API method on the data provider.
1. Provider responds with signed price data, including a timestamp till this data is valid.

3-4. The user sends a message to his on-chain contract, which requires prices and other business logic.

5. User contract sends "Verify that this price is correctly signed and valid" internal message to the oracle contract
5. Oracle contract verifies signature, timestamp, and price feed ID. If everything is okay, it sends a response with the prices back
5. The user contract receives a response from the oracle contract, checks if the sender is really the oracle, and then can use the provided data

![oracle-flow](/resources/images/oracles/oracle-flow.svg)

## List of oracles in TON

- [RedStone](/ecosystem/oracles/redstone)
- [Pyth](/ecosystem/oracles/pyth)
