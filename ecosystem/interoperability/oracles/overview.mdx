---
title: "Oracles overview"
sidebarTitle: "Overview"
---

import { Aside } from '/snippets/aside.jsx';

Blockchain oracles are entities that connect the blockchain to external systems, allowing smart contracts to be executed based on real-world inputs.

## How blockchain oracles work

Blockchain oracles are specialized services that act as bridges between the real world and blockchain technology. They provide smart contracts with relevant and necessary information from the outside world, such as exchange rates, payment statuses, or even weather conditions. This data helps to automate and fulfill the terms of contracts without direct human intervention.

The basic principle behind oracles is their ability to function outside of the blockchain by connecting to various online sources to collect data. Although oracles are not part of the blockchain itself, they play a key role in making it functional by acting as a trusted intermediary that reliably feeds external data into the system.

Most oracles tend to be decentralized, avoiding the risks associated with dependence on a single source of data. This provides greater security and reliability to the system as data is verified and validated through a network of nodes before it is used in smart contracts. This approach minimizes the risk of manipulation and errors, ensuring that the information provided is accurate and up-to-date.

## Varieties of blockchain oracles

Blockchain oracles are categorized according to various aspects: mechanism of operation, data sources, data direction, and governance structure. Let's take a look at the most common types of oracles.

### Push and pull oracles

Push and pull oracles differ in how they deliver data to an on-chain smart contract.

For push oracle, the data provider constantly updates info, *pushing* the newest data to the centralized trusted contract.

Read more about oracle model differences: [ChainLink - Pull vs Push oracles](https://chain.link/education-hub/pull-oracles-vs-push-oracles).

For pull oracle, users should retrieve the latest data from the off-chain data provider themselves, then verify it using the oracle contract. [Learn more](#oracles-in-ton) about data verification flow with pull model oracles.

Given TON actor-model, pull oracles prove to be more suited for real world applications.

### Centralized and decentralized oracles

Centralized oracles are controlled by a single party, which creates security and reliability risks. Decentralized oracles use multiple nodes to verify data, making them more secure and reliable.

### Cross-chain oracles

These oracles are used to transfer data between different blockchains and are a critical component of bridges. They are used for decentralized applications that use cross-chain transactions, such as cross-chain transfer of crypto assets from one network to another.

## Application of blockchain oracles

Blockchain oracles build bridges between the digital world of blockchains and real life, opening up a wide range of applications. Let's take a look at some of the most popular uses of oracles.

### DeFi (decentralized finance)

Oracles play a critical role in the DeFi ecosystem by providing market price and cryptocurrency data. Price oracles allow DeFi platforms to link token values to real assets, which is essential for controlling liquidity and securing users' positions. Additionally, oracles are vital for lending platforms, where accurate price data ensures proper collateral valuation and risk management, safeguarding both lenders and borrowers. This makes transactions more transparent and secure, contributing to the stability and reliability of financial transactions.

### Prediction markets

Oracles can automatically read and analyze data from a variety of sources to determine the occurrence of real-life events. This enables prediction and insurance contracts to automatically pay claims, reducing the need for manual processing of each case and speeding up response times to events.

### Random number generation

It is difficult to generate random numbers in smart contracts because all operations must be reproducible and predictable, which contradicts the concept of randomness. Computational oracles solve this problem by bringing data from the outside world into contracts. They can generate verifiable random numbers for games and lotteries, ensuring fairness and transparency of results.

Read more: [Randomness in TON](/techniques/random)

## Oracles in TON

Since the TON execution model is asynchronous, the classic ways to interact with oracles (get methods during transaction) can't be applied here. You can learn about the differences in ["Coming from Ethereum"](/guidebook/from-ethereum) article. The best pattern to retrieve data from an oracle is the [Request-Response pattern](/techniques/carry-value) - you send an internal message to the oracle contract and verify the response, getting the needed data.

This model works well with pull oracles, since you can always guarantee the lowest possible latency for real-world data. If you use push oracle, you will still need to process two internal messages (request and response) to retrieve data. However, data relevance is limited by the data provider's up-time and pushing intervals: if the data provider pushes updated data every 10 minutes, you will commonly receive information that is outdated by 5 minutes. But using pull oracle, you can ensure pushes as often as your service needs by updating the data yourself.

### Push oracle flow

0. Data provider pushes the latest data on-chain

1. The user contract, which needs prices on-chain, sends a request message to the trusted oracle contract

2. Oracle contract replies to the sender address with a response internal message, containing the requested data

3. User contract receives oracle response, verifies sender address, and then is ready to use the provided data

### Pull oracle flow

1. Users' off-chain backend calls the API method on the data provider

2. Provider responds with signed price data (including timestamp till this data is valid)

3-4. User sends a message to his on-chain contract that will need prices (and the rest of the business logic)

5. User contract sends "Verify that this price is correctly signed and valid" internal message to the oracle contract

6. Oracle contract verifies signature, timestamp, and price feed ID. If everything is okay, it sends a response with the prices back

7. User contract receives a response from the oracle contract, checks if the sender is really the oracle, and then can use the provided data


![oracle-flow](/resources/images/oracles/oracle-flow.svg)



## List of oracles in TON

- [RedStone](/ecosystem/interoperability/oracles/redstone)
- [Pyth](/ecosystem/interoperability/oracles/pyth)
