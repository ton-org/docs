---
title: "Toncoin payments processing"
sidebarTitle: "Toncoin"
---

import { Aside } from "/snippets/aside.jsx";

Processing Toncoin payments requires choosing between two architectural approaches: invoice-based deposits to a single address or unique deposit addresses per user. Each approach has different security characteristics, implementation complexity, and operational requirements.

## Invoice-based deposits

Invoice-based processing uses a single wallet address to receive payments from multiple users. Each payment includes a unique identifier in the transaction comment field, allowing the service to attribute deposits to specific users.

The implementation deploys one wallet contract (typically [Highload](/standard/wallets/highload/overview)) and generates unique invoice identifiers for each deposit. Users send Toncoin to this shared address with their invoice identifier as the comment. The service polls the wallet's transaction history, extracts comments from incoming messages, matches them against stored invoices, and credits user accounts accordingly.

Transaction comments in TON use the text message format with opcode `0x00000000` (first 32 bits of incoming internal message body) followed by UTF-8 encoded text. When parsing incoming messages, check the message body's first 32 bits for this opcode before reading the comment. Some wallets may send empty comments or messages without text format, so handle these cases gracefully.

<Aside type='tip'>
  Users can send transactions with arbitrary comments, including duplicates of valid invoice identifiers. Validate that invoice identifiers haven't been used previously and match expected formats. Implement amount verification to ensure deposits meet minimum requirements. Mark invoices as used immediately after crediting to prevent double-spending if the same invoice appears in multiple transactions.
</Aside>


**Advantages**:
- Single wallet simplifies key management
- Reduced gas costs for deployments
- Withdrawals can batch multiple user requests into one transaction using a Highload wallet
- The approach scales well for high transaction volumes

**Disadvantages**:
- Privacy is reduced since all users deposit to the same observable address
- Users must correctly input the invoice identifier, and mistakes result in lost or misdirected funds
- Comment parsing adds complexity
- Some wallets don't support comments, limiting accessibility

Reference education-only implementation: [Invoice-based Toncoin deposits](https://github.com/ton-org/docs-examples/blob/processing/guidebook/payment-processing/src/deposits.ts).

## Unique deposit addresses

Unique address deposits generate a separate wallet contract for each user. The user deposits to their dedicated address, and the service monitors all deployed wallets for incoming transactions. No comment parsing is required since each address maps to exactly one user.

Implementation requires a wallet generation strategy. The most common approach uses a deterministic scheme based on a master seed and user identifiers. For V4 and V5 wallets, use different `subwallet_id` combinations. Alternatively, generate unique keypairs per user, though this increases key management complexity. (TODO: security!)

Wallet deployment happens lazily when users first request their deposit address. Generate the address deterministically without deploying the contract. When the user sends their first deposit to the undeployed address, send the transaction in non-bounceable mode. The contract doesn't exist yet, so bounceable messages would return the funds. After the first deposit arrives, deploy the contract using funds from that deposit or from an external source.

Monitor all user wallets by maintaining a list of deployed addresses and polling their transactions. For large user bases, this becomes resource-intensive. Optimization strategies include monitoring only active wallets (those with recent deposits), using batched RPC calls to check multiple wallets per request.

TON's sharding mechanism splits the network across multiple chains based on address prefixes. The shard prefix comes from the first bits of the address hash. Deploying wallets in the same shard reduces cross-shard communication overhead. TODO: ton/core prefix

<Aside type='tip'>
 Each wallet requires separate key management. Store private keys encrypted and implement access controls. Lazy deployment means undeployed addresses can receive funds but cannot send them until deployment completes. Monitor for deployment status and automate deployment when deposits arrive. Validate that incoming transactions genuinely target the user's address and not another address with a similar hash.
</Aside>

Withdrawal processing must gather funds from multiple wallets. Either maintain a minimum balance in each wallet for gas fees or implement a fund collection system that periodically sweeps deposits to a central hot wallet. Highload wallets handle batch withdrawals efficiently, while standard V4/V5 wallets process messages sequentially using `seqno`, creating bottlenecks under high load.

**Advantages**:
- No comment parsing removes a major source of user error
- Better privacy since each user has a unique address
- Transaction monitoring is straightforward - any incoming transaction to a user's address is their deposit

**Disadvantages**:
- Higher operational complexity managing multiple wallets
- Deployment costs multiply by the number of users
- Withdrawal processing requires coordination across wallets
- Storage fees apply to each deployed contract (currently ~0.001 TON per year per contract)

## Withdrawal batching

[Highload wallets](/standard/wallets/highload/overview) support parallel message processing by storing processed request identifiers instead of sequential `seqno`. This enables batching multiple withdrawals into one transaction, reducing fees and improving throughput.

## Monitoring best practices

Implement exponential backoff for RPC failures. Network issues or node maintenance can interrupt transaction polling. When `getTransactions` fails, wait before retrying with increasing delays to avoid overwhelming the endpoint.

Store transaction state persistently. Record the last processed `lt` value and transaction hash to resume monitoring after restarts without reprocessing transactions. This prevents duplicate deposit credits.

Use multiple RPC endpoints for reliability. TON has several public API providers and liteserver networks. Implement fallback logic to switch endpoints if the primary becomes unavailable. Compare results across endpoints to detect potential inconsistencies.

Log all processing decisions including deposit credits, withdrawal submissions, and failed transactions. These logs are essential for debugging user reports and auditing system behavior. Include transaction hashes, logical times, amounts, and user identifiers in logs.
